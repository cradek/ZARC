   1:				; *******************************************************
   2:				; * Disassembly Routines for ZARC Z80 Computer          *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 27/9/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Routines to disassembly Z80 object codes into something resembling source. This
   8:				; is based on an algorithm by Toni Baker, published in Mastering Machine Code on
   9:				; Your ZX80 / ZX81. It includes some optimisations by "Thunor" from:
  10:				; http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter16.html
  11:				;
  12:				;
  13:     -	0001'         	monitor         equ 1                   ; Flag part of monitor build
  14:     -	0001'         	disass          equ 1                   ; Flag module for includes
  15:				;
  16:				;
  17:				;
  18:				; ************
  19:				; * Includes *
  20:				; ************
  21:				;
  22:				;
  23:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				
**** disass.z80 ****
  24:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** disass.z80 ****
  25:				                include "zarc.i"        ; Hardware definitions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//zarc.i ****
   1:				; ***********************************
   2:				; * ZARC Definitions                *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 26/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the ZARC system.
   8:				;
   9:				;
  10:				; ************
  11:				; * Hardware *
  12:				; ************
  13:				;
  14:				; Interrupt vector numbers in INT_VEC_TABLE.
  15:				; Address is INT_VEC_TABLE + 2 * vector number).
  16:     -	0000'         	INT_SER1_TX_VEC     equ INT_SER1_TX_BIT ; Serial port 1 transmitter buffer is half full or less
  17:     -	0001'         	INT_SER1_RX_VEC     equ INT_SER1_RX_BIT ; Serial port 1 receiver has data
  18:     -	0002'         	INT_SER2_TX_VEC     equ INT_SER2_TX_BIT ; Serial port 2 transmitter buffer is half full or less
  19:     -	0003'         	INT_SER2_RX_VEC     equ INT_SER2_RX_BIT ; Serial port 2 receiver has data
  20:     -	0004'         	INT_TICK_VEC        equ INT_TICK_BIT    ; Regular timekeeping
  21:				;
  22:     -	0064'         	MS_PER_TICK         equ 100             ; ms per tick
  23:     -	000A'         	TICK_FREQ           equ 10              ; Tick rate in Hz
  24:				;
  25:				
**** disass.z80 ****
  26:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  18:     -	0001'         	                ifndef main         ; Inhibit for this module
  19:				; Constants
  20:				;
  21:				; Variables 
  22:				                extern tikcnt       ; Tick counter
  23:				;
  24:				; Functions
  25:				                extern panic        ; System error exception
  26:				                extern rusby        ; Read byte from user space
  27:				                extern ruswd        ; Read 16-bit word from user space
  28:				                extern wusby        ; Write byte to user space
  29:				                extern wuswd        ; Write 16-bit word to user space
  30:				;
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** disass.z80 ****
  27:				                include "io_map.i"      ; I/O addresses mapping
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io_map.i ****
   1:				; ***********************************
   2:				; * ZARC I/O Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 3/9/2019          *
   5:				; ***********************************
   6:				
   7:				; *** I/O register address mapping ***
   8:				
   9:				; This should be kept in sync with the Definitions.vhd package file.
  10:     -	0000'         	IOA_FPGA_MAJREV equ 0x00        ; FPGA major revision
  11:     -	0001'         	IOA_FPGA_MINREV equ 0x01        ; FPGA minor revision
  12:     -	0002'         	IOA_CONTROL     equ 0x02        ; System control register
  13:     -	0003'         	IOA_FP_SW       equ 0x03        ; Front panel data switches
  14:				
  15:				; Paging
  16:     -	0004'         	IOA_MMAP_0      equ 0x04        ; Page, supervisor and protection for bank 0 (0x0000 to 0x3fff)
  17:     -	0005'         	IOA_MMAP_1      equ 0x05        ; Page, supervisor and protection for bank 1 (0x4000 to 0x7fff)
  18:     -	0006'         	IOA_MMAP_2      equ 0x06        ; Page, supervisor and protection for bank 2 (0x8000 to 0xbfff)
  19:     -	0007'         	IOA_MMAP_3      equ 0x07        ; Page, supervisor and protection for bank 3 (0xc000 to 0xffff)
  20:				
  21:				; Interrupts
  22:				; Note: Up to eight interrupts are supported. IM 2 is anticipated, and the
  23:				; fixed vector associated with each interrupt is supplied when the interrupt
  24:				; is serviced. Routine address is “I*256+databus”. Vector supplied is
  25:				; 0xe0 + 2 * interrupt number (0 to 7).
  26:				; Note: addresses 0x09 and 0x0b reserved for use if more than eight interrupt
  27:				; sources are required.
  28:     -	0008'         	IOA_INT_EN      equ 0x08        ; Enables
  29:     -	000A'         	IOA_INT_PEND    equ 0x0a        ; Pending interrupts
  30:				;
  31:				;NMI
  32:     -	000C'         	IOA_NMI_REASONS equ 0x0c        ; NMI reasons flags
  33:				;
  34:				; Serial.
  35:     -	0010'         	IOA_SER1_CSR    equ 0x10        ; Port 1 control / status
  36:     -	0011'         	IOA_SER1_DATA   equ 0x11        ; Port 1 data
  37:     -	0012'         	IOA_SER2_CSR    equ 0x12        ; Port 2 serial control / status
  38:     -	0013'         	IOA_SER2_DATA   equ 0x13        ; Port 2 serial data
  39:				
  40:				; RTC (DS1672)
  41:				; I2C, implemented using a byte interface to the CPU. Writing to the data port
  42:				; shifts out a byte. Input puts are shifted into the “other end” of the same
  43:				; register.
  44:     -	0018'         	IOA_I2C_CSR     equ 0x18        ; Control
  45:     -	0019'         	IOA_I2C_DATA    equ 0x19        ; Data
  46:				;
  47:				; SD Card
  48:				; Uses SPI mode, with a generally similar interface to that of the I2C.
  49:     -	0020'         	IOA_SPI_CSR     equ 0x20        ; Control
  50:     -	0021'         	IOA_SPI_DATA    equ 0x21        ; Data
  51:				
  52:				; CRC16 / XMODEM and MultiMediaCard CRC16
  53:				; Write to the CRC register to set the initial value. Writing to the input
  54:				; data register updates the CRC.
  55:     -	0024'         	IOA_CRC_0       equ 0x24        ; CRC register (low)
  56:     -	0025'         	IOA_CRC_1       equ 0x25        ; CRC register (high)
  57:     -	0026'         	IOA_CRC_DATA    equ 0x26        ; Input data
  58:				
  59:				; *** Proposed features ***
  60:				; Video
  61:				;IOA_VID_CTRL    equ 0x30;       ; Control (cursor on/off ...)
  62:				;IOA_VID_DATA    equ 0x31;       ; Data
  63:				;IOA_VID_CUR_X   equ 0x32;       ; Cursor X (0 to 127)
  64:				;IOA_VID_CUR_Y   equ 0x33;       ; Cursor Y (0 to 63)
  65:				;IOA_VID_START_L equ 0x34        ; Display start address (low byte)
  66:				;IOA_VID_START_H equ 0x35        ; Display start address (high byte)
  67:				
  68:				; Video palette
  69:				; Each entry consists of 6 bits of colour data. Foreground and background
  70:				; colour pairs are selected from the above palette using eight of the 22
  71:				; control codes in the display character set. This leaves codes for
  72:				; double-height, double-width etc.
  73:				;IOA_VID_PALBG0  equ 0x40        ; Background colour 0
  74:				;IOA_VID_PALFG0  equ 0x41        ; Foreground colour 0
  75:				;IOA_VID_PALBG1  equ 0x42        ; Background colour 1
  76:				;IOA_VID_PALFG1  equ 0x43        ; Foreground colour 1
  77:				;IOA_VID_PALBG2  equ 0x44        ; Background colour 2
  78:				;IOA_VID_PALFG2  equ 0x45        ; Foreground colour 2
  79:				;IOA_VID_PALBG3  equ 0x46        ; Background colour 3
  80:				;IOA_VID_PALFG3  equ 0x47        ; Foreground colour 3
  81:				;IOA_VID_PALBG4  equ 0x48        ; Background colour 4
  82:				;IOA_VID_PALFG4  equ 0x49        ; Foreground colour 4
  83:				;IOA_VID_PALBG5  equ 0x4a        ; Background colour 5
  84:				;IOA_VID_PALFG5  equ 0x4b        ; Foreground colour 5
  85:				;IOA_VID_PALBG6  equ 0x4c        ; Background colour 6
  86:				;IOA_VID_PALFG6  equ 0x4d        ; Foreground colour 6
  87:				;IOA_VID_PALBG7  equ 0x4e        ; Background colour 7
  88:				;IOA_VID_PALFG7  equ 0x4f        ; Foreground colour 7
  89:				
  90:				; Arithmetic
  91:				; Multiply, divide … based on 68000 DIV, DIVU, MUL, MULU.
  92:				; Multiply does A[16] * B[16] => C[32].
  93:				; Divide does A[32] / B[16] => C[32] (16-bit remainder [high bits] and
  94:				; 16-bit quotient [low bits]).
  95:				; Status bits include “complete” and “overflow”.
  96:				;IOA_ARITH_A_L   equ 0x50        ; A register (low)
  97:				;IOA_ARITH_A_H   equ 0x51        ; A register (high)
  98:				;IOA_ARITH_B_L   equ 0x54        ; B register (low)
  99:				;IOA_ARITH_B_H   equ 0x57        ; B register (high)
 100:				;IOA_ARITH_C_0   equ 0x58        ; C register (low)
 101:				;IOA_ARITH_C_1   equ 0x59 
 102:				;IOA_ARITH_C_2   equ 0x5a
 103:				;IOA_ARITH_C_3   equ 0x5b        ; C register (high)
 104:				;IOA_ARITH_CSR   equ 0x5c        ; Command / status
 105:				
 106:				
 107:				; *** Register bits allocation ***
 108:				
 109:				; IOA_CONTROL register
 110:     -	        	BITDEF SYSCTRL_TRARM, 0         ; 1 arms the trace interrupt
 111:     -	        	BITDEF SYSCTRL_MMAP, 1          ; 1 enables memory mapping
 112:     -	        	BITDEF SYSCTRL_NMCLR, 2         ; NMI mapping clear
 113:     -	        	BITDEF SYSCTRL_MAPARM, 3        ; NMI out arm
 114:     -	        	BITDEF SYSCTRL_MMAPN, 4         ; State of MMAP when an NMI occurred
 115:     -	        	BITDEF SYSCTRL_TRPRE0, 5        ; Number of prefixes for trace
 116:     -	        	BITDEF SYSCTRL_TRPRE1, 6
 117:     -	        	BITDEF SYSCTRL_RESERVED, 7      ; Unused bit
 118:				;
 119:				; MMAP page registers
 120:     -	        	BITDEF MMAP_PROT, 7             ; Write protection
 121:     -	        	BITDEF MMAP_SUPER, 6            ; I/O enable
 122:     -	003F'         	MMAP_PAGE_MASK  equ 0x3f        ; RAM page number bits
 123:				;
 124:				; IOA_INT_EN and IOA_INT_PEND registers.
 125:     -	0008'         	INTS_NUM        equ 8           ; Number of possible interrupt sources
 126:     -	        	BITDEF INT_SER1_TX, 0           ; Serial port 1 transmitter buffer is half full or less
 127:     -	        	BITDEF INT_SER1_RX, 1           ; Serial port 1 receiver has data
 128:     -	        	BITDEF INT_SER2_TX, 2           ; Serial port 2 transmitter buffer is half full or less
 129:     -	        	BITDEF INT_SER2_RX, 3           ; Serial port 2 receiver has data
 130:     -	        	BITDEF INT_TICK, 4              ; Regular timekeeping
 131:				;
 132:				; IOA_NMI_REASONS register.
 133:     -	0004'         	NMI_REASONS_NUM equ 4           ; Number of reasons for an NMI
 134:     -	        	BITDEF NMI_SWITCH, 0;           ; Front panel switch
 135:     -	        	BITDEF NMI_PROT_VIOL, 1;        ; Write protection violation
 136:     -	        	BITDEF NMI_SUPER_VIOL, 2;       ; Supervisor violation
 137:     -	        	BITDEF NMI_TRACE, 3;            ; Debugger trace (single step)
 138:     -	000F'         	NMI_REASONS_ALL equ NMI_SWITCH_MASK + NMI_PROT_VIOL_MASK + NMI_SUPER_VIOL_MASK + NMI_TRACE_MASK
 139:				;
 140:				; Serial CSRs (IOA_SER1_CSR and IOA_SER2_CSR).
 141:     -	        	BITDEF SER_CSR_RX_EMPTY, 0      ; Receiver buffer is empty
 142:     -	        	BITDEF SER_CSR_RX_ALHALF, 1     ; Receiver buffer is at least half full
 143:     -	        	BITDEF SER_CSR_RX_FULL, 2       ; Receiver buffer is full
 144:     -	        	BITDEF SER_CSR_FRAME_ERR, 3     ; Framing error in last character
 145:     -	        	BITDEF SER_CSR_TX_EMPTY, 4      ; Transmitter buffer is empty
 146:     -	        	BITDEF SER_CSR_TX_ALHALF, 5     ; Transmitter buffer is at least half full
 147:     -	        	BITDEF SER_CSR_TX_FULL, 6       ; Transmitter buffer is full
 148:				; Bit 7 is not used.
 149:				;
 150:				; I2C (Inter-Integrated Circuit) master interface. Used for RTC (DS1672).
 151:				; Bits in IOA_I2C_CSR
 152:     -	        	BITDEF I2C_CSR_ACKN, 0          ; (Read / write) acknowledge from receiving device
 153:     -	        	BITDEF I2C_CSR_START, 1         ; (Write only) trigger start sequence
 154:     -	        	BITDEF I2C_CSR_STOP, 2          ; (Write only) trigger stop sequence
 155:     -	        	BITDEF I2C_CSR_BUSY, 7          ; (Read only) transceiver busy
 156:				;
 157:				; SPI (Serial Peripheral Interface) master interface. Used for memory card.
 158:				; Bits in IOA_SPI_CSR
 159:     -	        	BITDEF SPI_CSR_FAST, 0          ; (Read / write) SPI speed select
 160:     -	        	BITDEF SPI_CSR_MC_SS, 1         ; (Read / write) memory card slave select
 161:     -	        	BITDEF SPI_CSR_BUSY, 7          ; (Read only) transceiver busy
 162:				
**** disass.z80 ****
  28:				                include "io.i"          ; I/O routines
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io.i ****
   1:				; ***********************************
   2:				; * ZARC Basic I/O Extern Symbols   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and extern statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef io           ; Inhibit for this module
  16:				;
  17:				                ; Variables
  18:				                extern coport   ; Current console port (PRT_xxx)
  19:				                extern trport   ; Current data transfer port (PRT_xxx)
  20:				;
  21:				                ; Routines
  22:				                extern conwch   ; Write character to the console
  23:				                extern conrch   ; Read character from the console
  24:				                extern consta   ; Fetch console port status
  25:				                extern trawch   ; Write character to the data transfer port
  26:				                extern trarch   ; Read character from the data transfer port
  27:				                extern s1wch    ; Write character to serial port 1
  28:				                extern s1rch    ; Read character from serial port 1
  29:				                extern s1sta    ; Fetch serial port 1 status
  30:				                extern s2wch    ; Write character to serial port 2
  31:				                extern s2rch    ; Read character from serial port 2
  32:				                extern s2sta    ; Fetch serial port 2 status
  33:				                extern i2cwr    ; Write to I2C device
  34:				                extern i2crd    ; Read from I2C device
  35:				                extern spiini   ; Initialise SPI interface and set speed
  36:				                extern spiss    ; Set SPI slave select(s)
  37:				                extern spitr    ; Transfer byte to / from SPI device
  38:				;
  39:				                endif
  40:				            endif
  41:				;
  42:				;
  43:				; Port enumeration. Used for console and transfer port selection. Definitions must
  44:				; match names in prt_name_list (monitor.z80).
  45:     -	        	                ENUM_START
  46:     -	        	                ENUM PORT_SER1          ; Serial port 1
  47:     -	        	                ENUM PORT_SER2          ; Serial port 2
  48:     -	        	                ENUM_END PORT_STATES    ; Number of states
  49:				;
  50:				
**** disass.z80 ****
  29:				                include "disass.i"      ; Z80 disassembler
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//disass.i ****
   1:				; ***************************************
   2:				; * ZARC Monitor Disassembly Routines   *
   3:				; * Written by: Merlin Skinner          *
   4:				; * Date Started: 27/9/2020             *
   5:				; ***************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0000'         	                ifndef disass   ; Inhibit for this module
  21:				                endif
  22:				            endif
  23:				;
  24:     -	0010'         	DIS_BUF_SIZE    equ 16          ; Length of intermediate disassembly buffer
  25:     -	0004'         	DIS_MAX_INSTLEN equ 4           ; Maximum length of instructions
  26:				; Note: invalid instructions may exceed this length.
**** disass.z80 ****
  30:				                include "utility.i"     ; Utility functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//utility.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Utility Routines   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef utility      ; Inhibit for this module
  16:				;
  17:				                extern cwnwln       ; Write new line characters to console.
  18:				                extern conwms       ; Print null-terminated string to the console
  19:				                extern conwmn       ; Print message <n> in a list
  20:				                extern skpspc       ; Step hl past spaces
  21:				                extern toupca       ; Convert character in A to upper case
  22:				                extern toloca       ; Convert character in A to lower case
  23:				                extern cwvich       ; Print only visible 7-bit characters
  24:				                extern cwpspc       ; Print a space
  25:				                extern mtwdli       ; Match word in a string against list of options
  26:				                extern cwphnb       ; Print least-significant nibble in A in hexadecimal
  27:				                extern cwphby       ; Print A in hexadecimal
  28:				                extern cwphwd       ; Print HL in hexadecimal
  29:				                extern cwpdby       ; Print A in decimal. Leading zeros are suppressed
  30:				                extern cwpdwd       ; Print HL in decimal. Leading zeros are suppressed
  31:				                extern cwpdlo       ; Print DEHL in decimal. Leading zeros are suppressed
  32:				                extern rdhxwd       ; Read a 16-bit hexadecimal number from a string
  33:				                extern rdduwd       ; Read a 16-bit unsigned decimal number from a string
  34:				                extern rddulo       ; Read a 32-bit unsigned decimal number from a string
  35:				;
  36:				                endif
  37:				            endif
  38:				;
  39:				;
  40:				; mtwdli (match word in a string against list of options) option bits. Each bit
  41:				; has the described effect if set.
  42:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  43:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  44:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  45:				
**** disass.z80 ****
  31:				;
  32:				;
  33:				;
  34:				; *************
  35:				; * Externals *
  36:				; *************
  37:				;
  38:				;
  39:				; Routines
  40:				                public diproc   ; Disassemble an instruction to intermediate form
  41:				                public diprnt   ; Print the result
  42:				;
  43:				; Variables
  44:				; None
  45:				;
  46:				;
  47:				;
  48:				; *************
  49:				; * Constants *
  50:				; *************
  51:				;
  52:				;
  53:				; None
  54:				;
  55:				;
  56:				;
  57:				; *************
  58:				; * Main Code *
  59:				; *************
  60:				;
  61:				;
  62:				                cseg                ; Code segment
  63:				;
  64:				;
  65:				; Disassemble an instruction into an intermediate format for printing by diprnt.
  66:				; It is also useful on its own as a means of aligning with the instruction stream.
  67:				; Call with:
  68:				; HL - points to first byte of instruction
  69:				; Returns with:
  70:				; HL - points to first byte of next instruction
  71:				;
  72:				; class and index are used internally to keep track of the instruction type. The
  73:				; states are shown in the following table.
  74:				;
  75:				; +-------+------------------------------+
  76:				; |       |           index              |
  77:				; +-------+--------+----------+----------+
  78:				; | class |  0 HL  |   1 IX   |   2 IY   |
  79:				; +-------+--------+----------+----------+
  80:				; |   0   | xx     | DDxx     | FDxx     |
  81:				; |   1   | CBxx   | DDCBddxx | FDCBddxx |
  82:				; |   2   | EDxx   |    --    |    --    |
  83:				; +-------+--------+----------+----------+
  84:				;
  85:				; The intermediate buffer dis_buf contains ASCII text with the following exceptions
  86:				; (all upper-case characters). This prevents having to implement a hexadecimal print
  87:				; for dis_buf.
  88:				; "V" is replaced by the following 8-bit value in hex.
  89:				; "W" is replaced by the following 16-bit value in hex.
  90:				; "O" is replaced by the following 8-bit signed offset in decimal [e.g. (IX + 10)]
  91:				; "*" is replaced by the word "illegal", to indicate an illegal instruction.
  92:				;
  93:    0+11	0000' C5      	diproc          push bc
  94:   11+11	0001' D5      	                push de
  95:   22+16	0002' 220000  	                ld (pc), hl         ; Instruction pointer
  96:   38+16	0005' 220200  	                ld (start_pc), hl   ; Remember start
  97:   54+4	0008' AF      	                xor a
  98:   58+13	0009' 322100  	                ld (db_count), a    ; Reset output buffer (dis_buf)
  99:   71+13	000C' 320800  	                ld (instr_len), a   ; Reset instruction buffer
 100:				; Define two variables, class and Index, and initially let both of them equal zero.
 101:   84+13	000F' 320900  	                ld (class), a
 102:   97+13	0012' 320A00  	                ld (index), a
 103:				; Write the byte being disassembled in binary, and split it into three parts; F,
 104:				; G, and H. F consists of bits 7 and 6, G of bits 5, 4, and 3, and H of bits 2,
 105:				; 1, and 0.
 106:  110+17	0015' CD7804  	dip_inst        call di_fetch       ; Fetch instruction
 107:  127+4	0018' 4F      	                ld c, a             ; Save it for later
 108:  131+10	0019' 110000  	                ld de, 0            ; Reset F and G
 109:  141+4	001C' 07      	                rlca                ; Rotate bit 7 into carry
 110:  145+8	001D' CB12    	                rl d                ; Rotate bit 7 into F
 111:  153+4	001F' 07      	                rlca                ; ... bit 6
 112:  157+8	0020' CB12    	                rl d
 113:				; Perform a similar process for G.
 114:  165+4	0022' 07      	                rlca                ; ... bit 5
 115:  169+8	0023' CB13    	                rl e
 116:  177+4	0025' 07      	                rlca                ; ... bit 4
 117:  181+8	0026' CB13    	                rl e
 118:  189+4	0028' 07      	                rlca                ; ... bit 3
 119:  193+8	0029' CB13    	                rl e                
 120:				; Find H
 121:  201+4	002B' 79      	                ld a, c
 122:  205+7	002C' E607    	                and 7               ; Bits 0 to 2
 123:				; A - H
 124:				; C - current instruction
 125:				; DE - F (high) and G (low)
 126:  212+13	002E' 320D00  	                ld (inst_h), a
 127:  225+4	0031' 7B      	                ld a, e
 128:  229+13	0032' 320C00  	                ld (inst_g), a
 129:  242+4	0035' 7A      	                ld a, d
 130:  246+13	0036' 320B00  	                ld (inst_f), a
 131:				; Next, split G into two parts; J and K; with J consisting of bits 2 and 1, and K
 132:				; just bit 0.
 133:  259+4	0039' 7B      	                ld a, e
 134:  263+4	003A' 1F      	                rra
 135:  267+7	003B' E603    	                and 3
 136:  274+13	003D' 320E00  	                ld (inst_j), a
 137:  287+4	0040' 7B      	                ld a, e
 138:  291+7	0041' E601    	                and 1
 139:  298+13	0043' 320F00  	                ld (inst_k), a
 140:				;
 141:				; Prefix processing complete. Since nearly all paths from now on result in a
 142:				; disassembled instruction, we can stack the destination address and just return
 143:				; in each case.
 144:  311+10	0046' 214904  	                ld hl, dip_done
 145:  321+11	0049' E5      	                push hl
 146:				;
 147:				; What we do next depends on CLASS.
 148:  332+13	004A' 3A0900  	                ld a, (class)
 149:  345+4	004D' A7      	                and a
 150:  349+7+5	004E' 280B    	                jr z, di_class_zero
 151:  356+4	0050' 3D      	                dec a
 152:  360+10	0051' CAFD02  	                jp z, di_class_one
 153:  370+4	0054' 3D      	                dec a
 154:  374+10	0055' CA4503  	                jp z, di_class_two
 155:				; If we end up here then something has gone horribly wrong.
 156:  384+17	0058' CD0000  	                call panic          ; System panic
 157:				;
 158:				; Class is 0.
 159:				; If the byte is 0xCB then...
 160:  401+4	005B' 79      	di_class_zero   ld a, c
 161:  405+7	005C' FECB    	                cp 0xcb
 162:  412+7+5	005E' 2015    	                jr nz, dic0_not_cb
 163:				; Handle CB prefix
 164:				; If INDEX <> zero then point past displacement.
 165:  419+13	0060' 3A0A00  	                ld a, (index)
 166:  432+4	0063' A7      	                and a
 167:  436+7+5	0064' 2806    	                jr z, dic0_idx_skip
 168:  443+17	0066' CD7804  	                call di_fetch       ; Fetch index offset
 169:  460+13	0069' 321000  	                ld (idx_offset), a
 170:				; Let CLASS equal one and start again.
 171:  473+7	006C' 3E01    	dic0_idx_skip   ld a, 1
 172:  480+13	006E' 320900  	                ld (class), a
 173:  493+6	0071' 33      	                inc sp              ; Remove address from stack
 174:  499+6	0072' 33      	                inc sp
 175:  505+12	0073' 18A0    	                jr dip_inst         ; Process next byte
 176:				; 0xCB processing complete.
 177:				;If INDEX equals zero then...
 178:  517+13	0075' 3A0A00  	dic0_not_cb     ld a, (index)
 179:  530+4	0078' A7      	                and a
 180:  534+7+5	0079' 202A    	                jr nz, dic0_pref_dn
 181:				; If the byte is ED then let CLASS equal two and start again.
 182:  541+4	007B' 79      	                ld a, c
 183:  545+7	007C' FEED    	                cp 0xed
 184:  552+7+5	007E' 2009    	                jr nz, dic0_not_ed
 185:  559+7	0080' 3E02    	                ld a, 2
 186:  566+13	0082' 320900  	                ld (class), a
 187:  579+6	0085' 33      	                inc sp              ; Remove address from stack
 188:  585+6	0086' 33      	                inc sp
 189:  591+12	0087' 188C    	                jr dip_inst         ; Process next byte
 190:				; If the byte is DD then let INDEX equal one and start again.
 191:  603+7	0089' FEDD    	dic0_not_ed     cp 0xdd
 192:  610+7+5	008B' 200A    	                jr nz, dic0_not_dd
 193:  617+7	008D' 3E01    	                ld a, 1
 194:  624+13	008F' 320A00  	                ld (index), a
 195:  637+6	0092' 33      	                inc sp              ; Remove address from stack
 196:  643+6	0093' 33      	                inc sp
 197:  649+10	0094' C31500  	                jp dip_inst         ; Process next byte
 198:				; If the byte is FD then let INDEX equal two and start again.
 199:  659+7	0097' FEFD    	dic0_not_dd     cp 0xfd
 200:  666+7+5	0099' 200A    	                jr nz, dic0_pref_dn
 201:  673+7	009B' 3E02    	                ld a, 2
 202:  680+13	009D' 320A00  	                ld (index), a
 203:  693+6	00A0' 33      	                inc sp              ; Remove address from stack
 204:  699+6	00A1' 33      	                inc sp
 205:  705+10	00A2' C31500  	                jp dip_inst         ; Process next byte
 206:				;
 207:				; What we do next depends on F.
 208:  715+13	00A5' 3A0B00  	dic0_pref_dn    ld a, (inst_f)
 209:  728+4	00A8' A7      	                and a
 210:  732+7+5	00A9' 280F    	                jr z, dic0f0
 211:  739+4	00AB' 3D      	                dec a
 212:  743+10	00AC' CACD01  	                jp z, dic0f1
 213:  753+4	00AF' 3D      	                dec a
 214:  757+10	00B0' CAED01  	                jp z, dic0f2
 215:  767+4	00B3' 3D      	                dec a
 216:  771+10	00B4' CAFC01  	                jp z, dic0f3
 217:				; If we end up here then something has gone horribly wrong.
 218:  781+17	00B7' CD0000  	                call panic          ; System panic
 219:				;
 220:				; If F equals zero then...
 221:				; What we do next depends on H.
 222:  798+13	00BA' 3A0D00  	dic0f0          ld a, (inst_h)
 223:  811+4	00BD' A7      	                and a
 224:  815+7+5	00BE' 281D    	                jr z, dic0f0h0
 225:  822+4	00C0' 3D      	                dec a
 226:  826+7+5	00C1' 2844    	                jr z, dic0f0h1
 227:  833+4	00C3' 3D      	                dec a
 228:  837+7+5	00C4' 286B    	                jr z, dic0f0h2
 229:  844+4	00C6' 3D      	                dec a
 230:  848+10	00C7' CA7C01  	                jp z, dic0f0h3
 231:  858+4	00CA' 3D      	                dec a
 232:  862+10	00CB' CA9A01  	                jp z, dic0f0h4
 233:  872+4	00CE' 3D      	                dec a
 234:  876+10	00CF' CAA601  	                jp z, dic0f0h5
 235:  886+4	00D2' 3D      	                dec a
 236:  890+10	00D3' CAB201  	                jp z, dic0f0h6
 237:  900+4	00D6' 3D      	                dec a
 238:  904+10	00D7' CAC401  	                jp z, dic0f0h7
 239:				; If we end up here then something has gone horribly wrong.
 240:  914+17	00DA' CD0000  	                call panic          ; System panic
 241:				;
 242:				; If H equals zero then...
 243:				; If G greater than three then let DIS equal JR c(G-4),V.
 244:  931+13	00DD' 3A0C00  	dic0f0h0        ld a, (inst_g)
 245:  944+7	00E0' D604    	                sub 4
 246:  951+7+5	00E2' 3811    	                jr c, dic0f0h0_njrcc
 247:  958+11	00E4' F5      	                push af
 248:  969+10	00E5' 214307  	                ld hl, jr_msg
 249:  979+17	00E8' CD6505  	                call di_outmsgspc   ; Output instruction
 250:  996+10	00EB' F1      	                pop af
 251: 1006+17	00EC' CD2705  	                call di_out_c
 252: 1023+17	00EF' CD3005  	                call di_comma
 253: 1040+10	00F2' C39E04  	                jp di_rel_jmp       ; Write space then destination
 254:				;
 255:				; If G less than four choose the Gth item in this list:
 256:				; NOP/EX AF,AF'/DJNZ V/JR V
 257: 1050+10	00F5' 213206  	dic0f0h0_njrcc  ld hl, c0f0h0g_msg
 258: 1060+13	00F8' 3A0C00  	                ld a, (inst_g)
 259: 1073+17	00FB' CD3F05  	                call di_outmsgn     ; Output message <n>
 260: 1090+13	00FE' 3A0C00  	                ld a, (inst_g)
 261: 1103+7	0101' FE02    	                cp 2
 262: 1110+5+6	0103' D8      	                ret c               ; Nothing more for nop & ex af, af'
 263:				; Write jump destination for djnz & jr.
 264: 1115+10	0104' C39E04  	                jp di_rel_jmp       ; Write space then destination
 265:				;
 266:				; If H equals one then...
 267:				; If K is zero then let DIS equal LD s(J),VV
 268: 1125+13	0107' 3A0F00  	dic0f0h1        ld a, (inst_k)
 269: 1138+4	010A' A7      	                and a
 270: 1142+7+5	010B' 2012    	                jr nz, dic0f0h1_add
 271:				; LD s(J),VV
 272: 1149+10	010D' 214607  	                ld hl, ld_msg
 273: 1159+17	0110' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 274: 1176+13	0113' 3A0E00  	                ld a, (inst_j)
 275: 1189+17	0116' CD0E05  	                call di_out_s       ; Output "s" (bc, de, [HL, IX or IY] or sp)
 276: 1206+17	0119' CD3505  	                call di_comma_spc
 277: 1223+10	011C' C36704  	                jp di_out_vv        ; Output 16-bit value
 278:				;
 279:				; If K is one then let DIS equal ADD Y,s(J)
 280: 1233+10	011F' 214907  	dic0f0h1_add    ld hl, add_msg
 281: 1243+17	0122' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 282: 1260+17	0125' CD1B05  	                call di_out_y       ; Output "Y" (HL, IX or IY)
 283: 1277+17	0128' CD3505  	                call di_comma_spc
 284: 1294+13	012B' 3A0E00  	                ld a, (inst_j)
 285: 1307+10	012E' C30E05  	                jp di_out_s         ; Output "s" (bc, de, [HL, IX or IY] or sp)
 286:				;
 287:				; If H equals two then...
 288:				; Let DIS equal LD plus the Gth item in this list:
 289:				; (BC),A/A,(BC)/(DE),A/A,(DE)/(VV),Y/Y,(VV)/(VV),A/A,(VV).
 290: 1317+10	0131' 214607  	dic0f0h2        ld hl, ld_msg
 291: 1327+17	0134' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 292: 1344+13	0137' 3A0C00  	                ld a, (inst_g)
 293: 1357+7	013A' FE04    	                cp 4
 294: 1364+7+5	013C' 3006    	                jr nc, dic0f0h2_vv
 295:				; Registers only [ (BC),A/A,(BC)/(DE),A/A,(DE) ].
 296: 1371+10	013E' 21A407  	                ld hl, ld_ptr_msg
 297: 1381+10	0141' C33F05  	                jp di_outmsgn       ; Output message <n>
 298:				;
 299:				; Deal with (VV),Y/Y,(VV)/(VV),A/A,(VV).
 300: 1391+7	0144' D604    	dic0f0h2_vv     sub 4
 301: 1398+7+5	0146' 280C    	                jr z, dic0f0h2gg4
 302: 1405+4	0148' 3D      	                dec a
 303: 1409+7+5	0149' 2812    	                jr z, dic0f0h2gg5
 304: 1416+4	014B' 3D      	                dec a
 305: 1420+7+5	014C' 2818    	                jr z, dic0f0h2gg6
 306: 1427+4	014E' 3D      	                dec a
 307: 1431+7+5	014F' 2820    	                jr z, dic0f0h2gg7
 308:				; If we end up here then something has gone horribly wrong.
 309: 1438+17	0151' CD0000  	                call panic          ; System panic
 310:				; (VV),Y
 311: 1455+17	0154' CD4F04  	dic0f0h2gg4     call di_out_pvv     ; Output 16-bit pointer (VV)
 312: 1472+17	0157' CD3505  	                call di_comma_spc
 313: 1489+10	015A' C31B05  	                jp di_out_y         ; Output "Y" (HL, IX or IY)
 314:				; Y,(VV)
 315: 1499+17	015D' CD1B05  	dic0f0h2gg5     call di_out_y       ; Output "Y" (HL, IX or IY)
 316: 1516+17	0160' CD3505  	                call di_comma_spc
 317: 1533+10	0163' C34F04  	                jp di_out_pvv       ; Output 16-bit pointer (VV)
 318:				; (VV),A
 319: 1543+17	0166' CD4F04  	dic0f0h2gg6     call di_out_pvv     ; Output 16-bit pointer (VV)
 320: 1560+17	0169' CD3505  	                call di_comma_spc
 321: 1577+7	016C' 3E61    	                ld a, 'a'
 322: 1584+10	016E' C37405  	                jp di_outchar
 323:				; A,(VV)
 324: 1594+7	0171' 3E61    	dic0f0h2gg7     ld a, 'a'
 325: 1601+17	0173' CD7405  	                call di_outchar
 326: 1618+17	0176' CD3505  	                call di_comma_spc
 327: 1635+10	0179' C34F04  	                jp di_out_pvv       ; Output 16-bit pointer (VV)
 328:				;
 329:				; If H equals three then...
 330: 1645+13	017C' 3A0F00  	dic0f0h3        ld a, (inst_k)
 331: 1658+4	017F' A7      	                and a
 332: 1662+7+5	0180' 200C    	                jr nz, dic0f0h3_dec
 333:				; If K is zero then let DIS equal INC s(J)
 334: 1669+10	0182' 214D07  	                ld hl, inc_msg
 335: 1679+17	0185' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 336: 1696+13	0188' 3A0E00  	                ld a, (inst_j)
 337: 1709+10	018B' C30E05  	                jp di_out_s         ; Output "s" (bc, de, [HL, IX or IY] or sp)
 338:				;
 339:				; If K is one then let DIS equal DEC s(J)
 340: 1719+10	018E' 215107  	dic0f0h3_dec    ld hl, dec_msg
 341: 1729+17	0191' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 342: 1746+13	0194' 3A0E00  	                ld a, (inst_j)
 343: 1759+10	0197' C30E05  	                jp di_out_s         ; Output "s" (bc, de, [HL, IX or IY] or sp)
 344:				;
 345:				; If H equals four then let DIS equal INC r(G)
 346: 1769+10	019A' 214D07  	dic0f0h4        ld hl, inc_msg
 347: 1779+17	019D' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 348: 1796+13	01A0' 3A0C00  	                ld a, (inst_g)
 349: 1809+10	01A3' C3C704  	                jp di_out_r         ; Output "r" (b, c, d, e, h, l, X or a)
 350:				;
 351:				; If H equals five then let DIS equal DEC r(G)
 352: 1819+10	01A6' 215107  	dic0f0h5        ld hl, dec_msg
 353: 1829+17	01A9' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 354: 1846+13	01AC' 3A0C00  	                ld a, (inst_g)
 355: 1859+10	01AF' C3C704  	                jp di_out_r         ; Output "r" (b, c, d, e, h, l, X or a)
 356:				;
 357:				; If H equals six then let DIS equal LD r(G),V
 358: 1869+10	01B2' 214607  	dic0f0h6        ld hl, ld_msg
 359: 1879+17	01B5' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 360: 1896+13	01B8' 3A0C00  	                ld a, (inst_g)
 361: 1909+17	01BB' CDC704  	                call di_out_r       ; Output "r" (b, c, d, e, h, l, X or a)
 362: 1926+17	01BE' CD3505  	                call di_comma_spc
 363: 1943+10	01C1' C35C04  	                jp di_out_v         ; Output 8-bit value from instruction stream
 364:				;
 365:				; If H equals seven then choose the Gth item from this list:
 366:				; RLCA/RRCA/RLA/RRA/DAA/CPL/SCF/CCF.
 367: 1953+10	01C4' 214906  	dic0f0h7        ld hl, dic0f0h7_msg
 368: 1963+13	01C7' 3A0C00  	                ld a, (inst_g)
 369: 1976+10	01CA' C33F05  	                jp di_outmsgn       ; Output message <n>
 370:				;
 371:				; Class 0: If F equals one then...
 372: 1986+4	01CD' 79      	dic0f1          ld a, c
 373: 1990+7	01CE' FE76    	                cp 0x76
 374: 1997+7+5	01D0' 2006    	                jr nz, dic0f1_not_halt
 375:				; If the byte = 76 then let DIS = HALT.
 376: 2004+10	01D2' 213E07  	                ld hl, halt_msg
 377: 2014+10	01D5' C36B05  	                jp di_outmsg        ; Output instruction
 378:				;
 379:				; If the byte <> 76 then let DIS equal LD r(G),r(H).
 380: 2024+10	01D8' 214607  	dic0f1_not_halt ld hl, ld_msg
 381: 2034+17	01DB' CD6505  	                call di_outmsgspc   ; Output instruction followed by a space
 382: 2051+13	01DE' 3A0C00  	                ld a, (inst_g)
 383: 2064+17	01E1' CDC704  	                call di_out_r       ; Output "r" (b, c, d, e, h, l, X or a)
 384: 2081+17	01E4' CD3505  	                call di_comma_spc
 385: 2098+13	01E7' 3A0D00  	                ld a, (inst_h)
 386: 2111+10	01EA' C3C704  	                jp di_out_r         ; Output "r" (b, c, d, e, h, l, X or a)
 387:				;
 388:				; Class 0: If F equals two then...
 389:				; If F equals two then let DIS equal x(G) r(H)
 390: 2121+13	01ED' 3A0C00  	dic0f2          ld a, (inst_g)
 391: 2134+17	01F0' CDBE04  	                call di_out_xinst   ; Output "ADD A," ... "CP"
 392: 2151+17	01F3' CD3A05  	                call di_spc         ; Write a space
 393: 2168+13	01F6' 3A0D00  	                ld a, (inst_h)
 394: 2181+10	01F9' C3C704  	                jp di_out_r         ; Output "r" (b, c, d, e, h, l, X or a)
 395:				;
 396:				; Class 0: If F equals three then...
 397:				; What we do next depends on H.
 398: 2191+13	01FC' 3A0D00  	dic0f3          ld a, (inst_h)
 399: 2204+4	01FF' A7      	                and a
 400: 2208+7+5	0200' 281D    	                jr z, dic0f3h0
 401: 2215+4	0202' 3D      	                dec a
 402: 2219+7+5	0203' 2826    	                jr z, dic0f3h1
 403: 2226+4	0205' 3D      	                dec a
 404: 2230+7+5	0206' 2860    	                jr z, dic0f3h2
 405: 2237+4	0208' 3D      	                dec a
 406: 2241+10	0209' CA7A02  	                jp z, dic0f3h3
 407: 2251+4	020C' 3D      	                dec a
 408: 2255+10	020D' CAAD02  	                jp z, dic0f3h4
 409: 2265+4	0210' 3D      	                dec a
 410: 2269+10	0211' CABF02  	                jp z, dic0f3h5
 411: 2279+4	0214' 3D      	                dec a
 412: 2283+10	0215' CADA02  	                jp z, dic0f3h6
 413: 2293+4	0218' 3D      	                dec a
 414: 2297+10	0219' CAE602  	                jp z, dic0f3h7
 415:				; If we end up here then something has gone horribly wrong.
 416: 2307+17	021C' CD0000  	                call panic          ; System panic
 417:				;
 418:				; If H equals 0 then let DIS equal RET c(G)
 419: 2324+10	021F' 215907  	dic0f3h0        ld hl, ret_msg
 420: 2334+17	0222' CD6505  	                call di_outmsgspc   ; Output instruction
 421: 2351+13	0225' 3A0C00  	                ld a, (inst_g)
 422: 2364+10	0228' C32705  	                jp di_out_c
 423:				;
 424:				; If H equals one then...
 425: 2374+13	022B' 3A0F00  	dic0f3h1        ld a, (inst_k)
 426: 2387+4	022E' A7      	                and a
 427: 2391+7+5	022F' 200C    	                jr nz, dic0f3h1k1
 428:				; If K is zero then let DIS equal POP q(J)
 429: 2398+10	0231' 215507  	                ld hl, pop_msg
 430: 2408+17	0234' CD6505  	                call di_outmsgspc   ; Output instruction
 431: 2425+13	0237' 3A0E00  	                ld a, (inst_j)
 432: 2438+10	023A' C30105  	                jp di_out_q         ; Output "s" (bc, de, [HL, IX or IY] or af)
 433:				;
 434:				; If K is one then choose the Jth item from this list:
 435:				; RET/EXX/JP (Y)/LD SP,Y.
 436: 2448+10	023D' 216B06  	dic0f3h1k1      ld hl, dic0f3h1k1_msg
 437: 2458+13	0240' 3A0E00  	                ld a, (inst_j)
 438: 2471+17	0243' CD3F05  	                call di_outmsgn     ; Output message <n>
 439: 2488+13	0246' 3A0E00  	                ld a, (inst_j)
 440: 2501+7	0249' FE02    	                cp 2
 441: 2508+7+5	024B' 2805    	                jr z, dic0f3h1k1j2
 442: 2515+7	024D' FE03    	                cp 3
 443: 2522+7+5	024F' 280E    	                jr z, dic0f3h1k1j3
 444: 2529+10	0251' C9      	                ret
 445:				;JP (Y)
 446: 2539+7	0252' 3E28    	dic0f3h1k1j2    ld a, '('
 447: 2546+17	0254' CD7405  	                call di_outchar
 448: 2563+17	0257' CD1B05  	                call di_out_y       ; Output "Y" (HL, IX or IY)
 449: 2580+7	025A' 3E29    	                ld a, ')'
 450: 2587+10	025C' C37405  	                jp di_outchar
 451:				;LD SP,Y
 452: 2597+10	025F' 216007  	dic0f3h1k1j3    ld hl, sp_msg
 453: 2607+17	0262' CD6505  	                call di_outmsgspc   ; Output instruction
 454: 2624+10	0265' C31B05  	                jp di_out_y         ; Output "Y" (HL, IX or IY)
 455:				;
 456:				; If H equals two then let DIS equal JP c(G),VV
 457: 2634+10	0268' 215D07  	dic0f3h2        ld hl, jp_msg
 458: 2644+17	026B' CD6505  	                call di_outmsgspc   ; Output instruction
 459: 2661+13	026E' 3A0C00  	                ld a, (inst_g)
 460: 2674+17	0271' CD2705  	                call di_out_c
 461: 2691+17	0274' CD3505  	                call di_comma_spc
 462: 2708+10	0277' C36704  	                jp di_out_vv        ; Output 16-bit value
 463:				;
 464:				; If H equals three then choose the Gth item from this list:
 465:				; JP VV/-/OUT (V),A/IN A,(V)/EX (SP),Y/EX DE,HL/DI/EI.
 466: 2718+10	027A' 217B06  	dic0f3h3        ld hl, dic0f3h3_msg
 467: 2728+13	027D' 3A0C00  	                ld a, (inst_g)
 468: 2741+17	0280' CD3F05  	                call di_outmsgn     ; Output message <n>
 469:				; Deal with operands where necessary.
 470: 2758+13	0283' 3A0C00  	                ld a, (inst_g)
 471: 2771+4	0286' A7      	                and a
 472: 2775+7+5	0287' 280D    	                jr z, dic0f3h3g0    ; JP VV
 473: 2782+7	0289' FE02    	                cp 2
 474: 2789+7+5	028B' 280C    	                jr z, dic0f3h3g2    ; OUT (V),A
 475: 2796+7	028D' FE03    	                cp 3
 476: 2803+7+5	028F' 2811    	                jr z, dic0f3h3g3    ; IN A,(V)
 477: 2810+7	0291' FE04    	                cp 4
 478: 2817+7+5	0293' 2815    	                jr z, dic0f3h3g4    ; EX (SP),Y
 479: 2824+10	0295' C9      	                ret
 480:				; JP VV
 481: 2834+10	0296' C36704  	dic0f3h3g0      jp di_out_vv        ; Output 16-bit value
 482:				;
 483:				; OUT (V),A
 484: 2844+17	0299' CD5C04  	dic0f3h3g2      call di_out_v       ; Output 8-bit value from instruction stream
 485: 2861+10	029C' 211408  	                ld hl, cpcomma_a_msg    ; "), a"
 486: 2871+10	029F' C36B05  	                jp di_outmsg        ; Output instruction
 487:				; IN A,(V)
 488: 2881+17	02A2' CD5C04  	dic0f3h3g3      call di_out_v       ; Output 8-bit value from instruction stream
 489: 2898+7	02A5' 3E29    	                ld a, ')'
 490: 2905+10	02A7' C37405  	                jp di_outchar
 491:				; EX (SP),Y
 492: 2915+10	02AA' C31B05  	dic0f3h3g4      jp di_out_y         ; Output "Y" (HL, IX or IY)
 493:				;
 494:				; If H equals four then let DIS equal CALL c(G),VV
 495: 2925+10	02AD' 216407  	dic0f3h4        ld hl, call_msg
 496: 2935+17	02B0' CD6505  	                call di_outmsgspc   ; Output instruction
 497: 2952+13	02B3' 3A0C00  	                ld a, (inst_g)
 498: 2965+17	02B6' CD2705  	                call di_out_c
 499: 2982+17	02B9' CD3505  	                call di_comma_spc
 500: 2999+10	02BC' C36704  	                jp di_out_vv        ; Output 16-bit value
 501:				;
 502:				; If H equals five then...
 503: 3009+13	02BF' 3A0F00  	dic0f3h5        ld a, (inst_k)
 504: 3022+4	02C2' A7      	                and a
 505: 3026+7+5	02C3' 200C    	                jr nz, dic0f3h5k1
 506:				; If K is zero then let DIS equal PUSH q(J).
 507: 3033+10	02C5' 216907  	                ld hl, push_msg
 508: 3043+17	02C8' CD6505  	                call di_outmsgspc   ; Output instruction
 509: 3060+13	02CB' 3A0E00  	                ld a, (inst_j)
 510: 3073+10	02CE' C30105  	                jp di_out_q         ; Output "s" (bc, de, [HL, IX or IY] or af)
 511:				;
 512:				; If K is one then let DIS equal CALL VV.
 513: 3083+10	02D1' 216407  	dic0f3h5k1      ld hl, call_msg
 514: 3093+17	02D4' CD6505  	                call di_outmsgspc   ; Output instruction
 515: 3110+10	02D7' C36704  	                jp di_out_vv        ; Output 16-bit value
 516:				;
 517:				; If H equals six then let DIS equal x(G) V.
 518: 3120+13	02DA' 3A0C00  	dic0f3h6        ld a, (inst_g)
 519: 3133+17	02DD' CDBE04  	                call di_out_xinst   ; Output "ADD A," ... "CP"
 520: 3150+17	02E0' CD3A05  	                call di_spc         ; Write a space
 521: 3167+10	02E3' C35C04  	                jp di_out_v         ; Output 8-bit value from instruction stream
 522:				;
 523:				; If H equals seven then let DIS equal RST plus the Gth item
 524:				; in this list: 00/08/10/18/20/28/30/38.
 525: 3177+13	02E6' 3A0C00  	dic0f3h7        ld a, (inst_g)
 526: 3190+10	02E9' 216E07  	                ld hl, rst_msg
 527: 3200+17	02EC' CD6505  	                call di_outmsgspc   ; Output instruction
 528: 3217+7	02EF' 3E56    	                ld a, 'V'           ; Flag 8-bit value follows
 529: 3224+17	02F1' CD7405  	                call di_outchar
 530: 3241+13	02F4' 3A0C00  	                ld a, (inst_g)
 531: 3254+4	02F7' 87      	                add a               ; Multiply by 8
 532: 3258+4	02F8' 87      	                add a
 533: 3262+4	02F9' 87      	                add a
 534: 3266+10	02FA' C37405  	                jp di_outchar
 535:				;
 536:				; Class is 1.
 537:				; What we do next depends on F.
 538: 3276+13	02FD' 3A0B00  	di_class_one    ld a, (inst_f)
 539: 3289+4	0300' A7      	                and a
 540: 3293+7+5	0301' 280F    	                jr z, dic1f0
 541: 3300+4	0303' 3D      	                dec a
 542: 3304+10	0304' CA2403  	                jp z, dic1f1
 543: 3314+4	0307' 3D      	                dec a
 544: 3318+10	0308' CA3B03  	                jp z, dic1f2
 545: 3328+4	030B' 3D      	                dec a
 546: 3332+10	030C' CA4003  	                jp z, dic1f3
 547:				; If we end up here then something has gone horribly wrong.
 548: 3342+17	030F' CD0000  	                call panic          ; System panic
 549:				;
 550:				; If F equals zero then choose the Gth item from this list:
 551:				; RLC/RRC/RL/RR/SLA/SRA/-/SRL and then add r(H).
 552: 3359+10	0312' 21A906  	dic1f0          ld hl, dic1f0_msg
 553: 3369+13	0315' 3A0C00  	                ld a, (inst_g)
 554: 3382+17	0318' CD3F05  	                call di_outmsgn     ; Output message <n>
 555: 3399+17	031B' CD3A05  	                call di_spc         ; Write a space
 556: 3416+13	031E' 3A0D00  	                ld a, (inst_h)
 557: 3429+10	0321' C3C704  	                jp di_out_r         ; Output "r" (b, c, d, e, h, l, X or a)
 558:				;
 559:				; If F equals one then let DIS equal BIT n(G),r(H).
 560: 3439+10	0324' 217207  	dic1f1          ld hl, bit_msg
 561:				; Go here for bit, res and set instructions.
 562: 3449+17	0327' CD6505  	dic1_brs        call di_outmsgspc   ; Output instruction
 563: 3466+13	032A' 3A0C00  	                ld a, (inst_g)
 564: 3479+7	032D' C630    	                add "0"             ; Make bit number ASCII
 565: 3486+17	032F' CD7405  	                call di_outchar
 566: 3503+17	0332' CD3505  	                call di_comma_spc
 567: 3520+13	0335' 3A0D00  	                ld a, (inst_h)
 568: 3533+10	0338' C3C704  	                jp di_out_r         ; Output "r" (b, c, d, e, h, l, X or a)
 569:				;
 570:				; If F equals two then let DIS equal RES n(G),r(H).
 571: 3543+10	033B' 217607  	dic1f2          ld hl, res_msg
 572: 3553+12	033E' 18E7    	                jr dic1_brs
 573:				;
 574:				; If F equals three then let DIS equal SET n(G),r(H).
 575: 3565+10	0340' 217A07  	dic1f3          ld hl, set_msg
 576: 3575+12	0343' 18E2    	                jr dic1_brs
 577:				;
 578:				; Class is 2.
 579:				; What we do next depends on F.
 580: 3587+13	0345' 3A0B00  	di_class_two    ld a, (inst_f)
 581: 3600+4	0348' 3D      	                dec a
 582: 3604+10	0349' CA5503  	                jp z, dic2f1
 583: 3614+4	034C' 3D      	                dec a
 584: 3618+10	034D' CA3704  	                jp z, dic2f2
 585:				; Illegal instruction if F = 0 or 3.
 586: 3628+7	0350' 3E2A    	di_illegal      ld a, '*'
 587: 3635+10	0352' C37405  	                jp di_outchar       ; Write "illegal" token
 588:				;
 589:				; If F equals one then....
 590:				; What we do next depends on H.
 591: 3645+13	0355' 3A0D00  	dic2f1          ld a, (inst_h)
 592: 3658+4	0358' A7      	                and a
 593: 3662+7+5	0359' 281D    	                jr z, dic2f1h0
 594: 3669+4	035B' 3D      	                dec a
 595: 3673+7+5	035C' 282F    	                jr z, dic2f1h1
 596: 3680+4	035E' 3D      	                dec a
 597: 3684+7+5	035F' 2841    	                jr z, dic2f1h2
 598: 3691+4	0361' 3D      	                dec a
 599: 3695+10	0362' CAC503  	                jp z, dic2f1h3
 600: 3705+4	0365' 3D      	                dec a
 601: 3709+10	0366' CAEF03  	                jp z, dic2f1h4
 602: 3719+4	0369' 3D      	                dec a
 603: 3723+10	036A' CAF503  	                jp z, dic2f1h5
 604: 3733+4	036D' 3D      	                dec a
 605: 3737+10	036E' CA1104  	                jp z, dic2f1h6
 606: 3747+4	0371' 3D      	                dec a
 607: 3751+10	0372' CA2E04  	                jp z, dic2f1h7
 608:				; If we end up here then something has gone horribly wrong.
 609: 3761+17	0375' CD0000  	                call panic          ; System panic
 610:				;
 611:				; If H equals zero then let DIS equal IN r(G),(C).
 612: 3778+10	0378' 217E07  	dic2f1h0        ld hl, in_msg
 613: 3788+17	037B' CD6505  	                call di_outmsgspc   ; Output instruction
 614: 3805+13	037E' 3A0C00  	                ld a, (inst_g)
 615: 3818+17	0381' CDC704  	                call di_out_r       ; Output "r" (b, c, d, e, h, l, X or a)
 616: 3835+17	0384' CD3505  	                call di_comma_spc
 617: 3852+10	0387' 219C07  	                ld hl, iocp_msg
 618: 3862+10	038A' C36B05  	                jp di_outmsg        ; Output (c)
 619:				;
 620:				;If H equals one then let DIS equal OUT (C),r(G).
 621: 3872+10	038D' 218107  	dic2f1h1        ld hl, out_msg
 622: 3882+17	0390' CD6505  	                call di_outmsgspc   ; Output instruction
 623: 3899+10	0393' 219C07  	                ld hl, iocp_msg
 624: 3909+17	0396' CD6B05  	                call di_outmsg      ; Output (c)
 625: 3926+17	0399' CD3505  	                call di_comma_spc
 626: 3943+13	039C' 3A0C00  	                ld a, (inst_g)
 627: 3956+10	039F' C3C704  	                jp di_out_r         ; Output "r" (b, c, d, e, h, l, X or a)
 628:				;
 629:				; If H equals two then...
 630: 3966+13	03A2' 3A0F00  	dic2f1h2        ld a, (inst_k)
 631: 3979+4	03A5' A7      	                and a
 632: 3983+7+5	03A6' 2806    	                jr z, dic2f1h2k0
 633: 3990+4	03A8' 3D      	                dec a
 634: 3994+7+5	03A9' 2815    	                jr z, dic2f1h2k1
 635:				; If we end up here then something has gone horribly wrong.
 636: 4001+17	03AB' CD0000  	                call panic          ; System panic
 637:				;
 638:				; If K equals zero then let DIS equal SBC HL,s(J).
 639: 4018+10	03AE' 218507  	dic2f1h2k0      ld hl, sbc_msg
 640:				; Go here for sbc and adc instructions.
 641: 4028+17	03B1' CD6505  	dic2f1h2_sa     call di_outmsgspc   ; Output instruction
 642: 4045+10	03B4' 21A007  	                ld hl, hlc_msg
 643: 4055+17	03B7' CD6505  	                call di_outmsgspc   ; Output "hl, "
 644: 4072+13	03BA' 3A0E00  	                ld a, (inst_j)
 645: 4085+10	03BD' C30E05  	                jp di_out_s         ; Output "s" (bc, de, [HL, IX or IY] or sp)
 646:				;
 647:				; If K equals one then let DIS equal ADC HL,s(J).
 648: 4095+10	03C0' 218D07  	dic2f1h2k1      ld hl, adc_msg
 649: 4105+12	03C3' 18EC    	                jr dic2f1h2_sa
 650:				;
 651:				; If H equals three then...
 652:				; 16-bit indirect load instructions.
 653: 4117+10	03C5' 214607  	dic2f1h3        ld hl, ld_msg
 654: 4127+17	03C8' CD6505  	                call di_outmsgspc   ; Output instruction
 655: 4144+13	03CB' 3A0F00  	                ld a, (inst_k)
 656: 4157+4	03CE' A7      	                and a
 657: 4161+7+5	03CF' 2806    	                jr z, dic2f1h3k0
 658: 4168+4	03D1' 3D      	                dec a
 659: 4172+7+5	03D2' 280F    	                jr z, dic2f1h3k1
 660:				; If we end up here then something has gone horribly wrong.
 661: 4179+17	03D4' CD0000  	                call panic          ; System panic
 662:				;
 663:				; If K equals zero then let DIS equal LD (VV),s(J).
 664: 4196+17	03D7' CD4F04  	dic2f1h3k0      call di_out_pvv     ; Output 16-bit pointer (VV)
 665: 4213+17	03DA' CD3505  	                call di_comma_spc
 666: 4230+13	03DD' 3A0E00  	                ld a, (inst_j)
 667: 4243+10	03E0' C30E05  	                jp di_out_s         ; Output "s" (bc, de, [HL, IX or IY] or sp)
 668:				;
 669:				; If K equals one then let DIS equal LD s(J),(VV).
 670: 4253+13	03E3' 3A0E00  	dic2f1h3k1      ld a, (inst_j)
 671: 4266+17	03E6' CD0E05  	                call di_out_s       ; Output "s" (bc, de, [HL, IX or IY] or sp)
 672: 4283+17	03E9' CD3505  	                call di_comma_spc
 673: 4300+10	03EC' C34F04  	                jp di_out_pvv       ; Output 16-bit pointer (VV)
 674:				;
 675:				; If H equals four then let DIS equal NEG.
 676: 4310+10	03EF' 218907  	dic2f1h4        ld hl, neg_msg
 677: 4320+10	03F2' C36B05  	                jp di_outmsg        ; Output instruction
 678:				;
 679:				; If H equals five then...
 680: 4330+10	03F5' 215907  	dic2f1h5        ld hl, ret_msg
 681: 4340+17	03F8' CD6B05  	                call di_outmsg      ; Output instruction
 682: 4357+13	03FB' 3A0F00  	                ld a, (inst_k)
 683: 4370+4	03FE' A7      	                and a
 684: 4374+7+5	03FF' 2806    	                jr z, dic2f1h5k0
 685: 4381+4	0401' 3D      	                dec a
 686: 4385+7+5	0402' 2808    	                jr z, dic2f1h5k1
 687:				; If we end up here then something has gone horribly wrong.
 688: 4392+17	0404' CD0000  	                call panic          ; System panic
 689:				;
 690:				; If K equals zero then let DIS equal RETN.
 691: 4409+7	0407' 3E6E    	dic2f1h5k0      ld a, 'n'
 692: 4416+10	0409' C37405  	                jp di_outchar
 693:				;
 694:				; If K equals one then let DIS equal RETI.
 695: 4426+7	040C' 3E69    	dic2f1h5k1      ld a, 'i'
 696: 4433+10	040E' C37405  	                jp di_outchar
 697:				;
 698:				; If H equals six then choose the Gth item from this list:
 699:				; IM 0/-/IM 1/IM 2/-/-/-/-.
 700: 4443+10	0411' 219107  	dic2f1h6        ld hl, im_msg
 701: 4453+17	0414' CD6505  	                call di_outmsgspc   ; Output instruction
 702: 4470+13	0417' 3A0C00  	                ld a, (inst_g)
 703: 4483+4	041A' A7      	                and a
 704: 4487+7+5	041B' 280B    	                jr z, dic2f1h6_im0
 705: 4494+7	041D' FE02    	                cp 2
 706: 4501+7+5	041F' 2808    	                jr z, dic2f1h6_im12
 707: 4508+7	0421' FE03    	                cp 3
 708: 4515+7+5	0423' 2804    	                jr z, dic2f1h6_im12
 709: 4522+10	0425' C35003  	                jp di_illegal       ; All other combinations are illegal
 710:				; Go here with valid interrupt modes.
 711: 4532+4	0428' 3C      	dic2f1h6_im0    inc a
 712:				; In all cases, A is the interrupt mode + 1
 713: 4536+7	0429' C62F    	dic2f1h6_im12   add '0' - 1         ; Convert to ASCII '0' to '2'
 714: 4543+10	042B' C37405  	                jp di_outchar
 715:				;
 716:				; If H equals seven then choose the Gth item from this list:
 717:				; LD I,A/LD R,A/LD A,I/LD A,R/RRD/RLD/-/-.
 718: 4553+10	042E' 21C506  	dic2f1h7        ld hl, dic2f1h7_msg
 719: 4563+13	0431' 3A0C00  	                ld a, (inst_g)
 720: 4576+10	0434' C33F05  	                jp di_outmsgn       ; Output message <n>
 721:				;
 722:				; If F equals two then choose the Hth item from this list:
 723:				; LD/CP/IN/OT/-/-/-/- and then add the Gth item from this list:
 724:				; -/-/-/-/I/D/IR/DR.
 725: 4586+10	0437' 21F106  	dic2f2          ld hl, dic2f2_1_msg
 726: 4596+13	043A' 3A0D00  	                ld a, (inst_h)
 727: 4609+17	043D' CD3F05  	                call di_outmsgn     ; Output message <n>
 728: 4626+10	0440' 210507  	                ld hl, dic2f2_2_msg
 729: 4636+13	0443' 3A0C00  	                ld a, (inst_g)
 730: 4649+10	0446' C33F05  	                jp di_outmsgn       ; Output message <n>
 731:				;
 732:				; F cannot possibly be three.
 733:				;
 734:				; Instruction complete. We normally get here by returning from one of the stub
 735:				; routines above.
 736: 4659+10	0449' D1      	dip_done        pop de
 737: 4669+10	044A' C1      	                pop bc
 738: 4679+16	044B' 2A0000  	                ld hl, (pc)
 739: 4695+10	044E' C9      	                ret
 740:				;
 741:				;
 742:				; Output 16-bit pointer (VV) from instruction stream.
 743: 4705+7	044F' 3E28    	di_out_pvv      ld a, '('
 744: 4712+17	0451' CD7405  	                call di_outchar
 745: 4729+17	0454' CD6704  	                call di_out_vv      ; Output 16-bit value
 746: 4746+7	0457' 3E29    	                ld a, ')'
 747: 4753+10	0459' C37405  	                jp di_outchar
 748:				;
 749:				;
 750:				; Output 8-bit value from instruction stream.
 751: 4763+7	045C' 3E56    	di_out_v        ld a, 'V'           ; Flag 8-bit value follows
 752: 4770+17	045E' CD7405  	                call di_outchar
 753: 4787+17	0461' CD7804  	                call di_fetch       ; Fetch immediate value
 754: 4804+10	0464' C37405  	                jp di_outchar
 755:				;
 756:				;
 757:				; Output 16-bit value from instruction stream.
 758: 4814+7	0467' 3E57    	di_out_vv       ld a, 'W'           ; Flag 16-bit value follows
 759: 4821+17	0469' CD7405  	                call di_outchar
 760: 4838+17	046C' CD7804  	                call di_fetch       ; Fetch LSB of immediate value
 761: 4855+17	046F' CD7405  	                call di_outchar
 762: 4872+17	0472' CD7804  	                call di_fetch       ; Fetch MSB of immediate value
 763: 4889+10	0475' C37405  	                jp di_outchar
 764:				;
 765:				;
 766:				; Fetch a byte from the instruction steam.
 767:				; Returns with:
 768:				; A - instruction byte
 769: 4899+11	0478' C5      	di_fetch        push bc
 770: 4910+11	0479' D5      	                push de
 771: 4921+11	047A' E5      	                push hl
 772: 4932+16	047B' 2A0000  	                ld hl, (pc)
 773: 4948+17	047E' CD0000  	                call rusby
 774: 4965+4	0481' 4F      	                ld c, a             ; Save it for later
 775: 4969+6	0482' 23      	                inc hl
 776: 4975+16	0483' 220000  	                ld (pc), hl
 777:				; Store the fetched bytes in a buffer for later display.
 778: 4991+10	0486' 210400  	                ld hl, instr_buf
 779: 5001+13	0489' 3A0800  	                ld a, (instr_len)
 780: 5014+7	048C' FE04    	                cp DIS_MAX_INSTLEN
 781: 5021+7+5	048E' 3009    	                jr nc, dif_toolong  ; Jump if buffer is already full
 782:				; There is space, so find the address in the buffer
 783: 5028+7	0490' 1600    	                ld d, 0
 784: 5035+4	0492' 5F      	                ld e, a
 785: 5039+11	0493' 19      	                add hl, de
 786: 5050+7	0494' 71      	                ld (hl), c          ; Store byte
 787: 5057+10	0495' 210800  	                ld hl, instr_len
 788: 5067+11	0498' 34      	                inc (hl)
 789: 5078+4	0499' 79      	dif_toolong     ld a, c             ; Restore fetched byte
 790: 5082+10	049A' E1      	                pop hl
 791: 5092+10	049B' D1      	                pop de
 792: 5102+10	049C' C1      	                pop bc
 793: 5112+10	049D' C9      	                ret
 794:				;
 795:				; The next byte in the instruction stream is a relative jump. Output this as a
 796:				; 16-bit address.
 797: 5122+17	049E' CD3A05  	di_rel_jmp      call di_spc         ; Write a space
 798: 5139+17	04A1' CD7804  	                call di_fetch       ; Fetch offset
 799:				; Sign extended A into BC.
 800: 5156+7	04A4' 0600    	                ld b, 0
 801: 5163+4	04A6' A7      	                and a
 802: 5167+10	04A7' F2AC04  	                jp p, rj_sexdn
 803: 5177+7	04AA' 06FF    	                ld b, 0xff
 804: 5184+4	04AC' 4F      	rj_sexdn        ld c, a
 805: 5188+16	04AD' 2A0000  	                ld hl, (pc)
 806: 5204+11	04B0' 09      	                add hl, bc          ; Find jump destination
 807: 5215+7	04B1' 3E57    	                ld a, 'W'           ; Flag 16-bit value follows
 808: 5222+17	04B3' CD7405  	                call di_outchar
 809: 5239+4	04B6' 7D      	                ld a, l
 810: 5243+17	04B7' CD7405  	                call di_outchar
 811: 5260+4	04BA' 7C      	                ld a, h
 812: 5264+10	04BB' C37405  	                jp di_outchar
 813:				;
 814:				;
 815:				
 816:				; Output "x" ("ADD A,", "ADC A,", "SUB", "SBC A,", "AND", "XOR", "OR", "CP")
 817:				; to dis_buf.
 818:				; Call with:
 819:				; A - index
 820: 5274+11	04BE' E5      	di_out_xinst    push hl
 821:				; Write instruction name.
 822: 5285+10	04BF' 211707  	                ld hl, xinst_codes_msg
 823: 5295+17	04C2' CD3F05  	                call di_outmsgn     ; Output message <n>
 824: 5312+10	04C5' E1      	                pop hl
 825: 5322+10	04C6' C9      	                ret
 826:				;
 827:				;
 828:				; Output "r" (b, c, d, e, h, l, X [(HL), (IX+d) or (IY+d)] or a) to dis_buf.
 829:				; Call with:
 830:				; A - index
 831: 5332+7	04C7' FE06    	di_out_r        cp 6
 832: 5339+7+5	04C9' 2809    	                jr z, di_out_x
 833: 5346+11	04CB' E5      	                push hl
 834:				; Write register name.
 835: 5357+10	04CC' 21C407  	                ld hl, r_codes_msg
 836: 5367+17	04CF' CD3F05  	                call di_outmsgn     ; Output message <n>
 837: 5384+10	04D2' E1      	                pop hl
 838: 5394+10	04D3' C9      	                ret
 839:				;
 840:				;
 841:				; Write "X" [(HL), (IX+d) or (IY+d) according to index] to dis_buf.
 842: 5404+11	04D4' E5      	di_out_x        push hl
 843: 5415+13	04D5' 3A0A00  	                ld a, (index)
 844: 5428+10	04D8' 210508  	                ld hl, phlixiy_msg
 845: 5438+17	04DB' CD3F05  	                call di_outmsgn     ; Output message <n>
 846: 5455+10	04DE' E1      	                pop hl
 847: 5465+13	04DF' 3A0A00  	                ld a, (index)
 848: 5478+4	04E2' A7      	                and a
 849: 5482+5+6	04E3' C8      	                ret z               ; If index is zero (hl), exit
 850: 5487+7	04E4' 3E4F    	                ld a, 'O'           ; 8-bit signed offset follows
 851: 5494+17	04E6' CD7405  	                call di_outchar
 852:				; If class is one (DDCBddxx or FDCBddxx), we will have already fetched the
 853:				; offset.
 854: 5511+13	04E9' 3A1000  	                ld a, (idx_offset)  ; Fetch offset (may be overwritten)
 855: 5524+4	04EC' 4F      	                ld c, a
 856: 5528+13	04ED' 3A0900  	                ld a, (class)
 857: 5541+7	04F0' FE01    	                cp 1
 858: 5548+7+5	04F2' 2804    	                jr z, diox_have_off
 859:				;
 860:				; Class 0 or 2. Fetch the offset.
 861: 5555+17	04F4' CD7804  	                call di_fetch       ; Fetch immediate value
 862: 5572+4	04F7' 4F      	                ld c, a
 863:				;
 864: 5576+4	04F8' 79      	diox_have_off   ld a, c
 865: 5580+17	04F9' CD7405  	                call di_outchar
 866: 5597+7	04FC' 3E29    	                ld a, ')'
 867: 5604+10	04FE' C37405  	                jp di_outchar
 868:				;
 869:				;
 870:				; Write "q" (bc, de, Y [HL, IX or IY] or af) to dis_buf.
 871:				; Call with:
 872:				; A - index
 873: 5614+7	0501' FE02    	di_out_q        cp 2
 874: 5621+7+5	0503' 2816    	                jr z, di_out_y
 875: 5628+11	0505' E5      	                push hl
 876:				; Write register name.
 877: 5639+10	0506' 21F207  	                ld hl, q_codes_msg
 878: 5649+17	0509' CD3F05  	                call di_outmsgn     ; Output message <n>
 879: 5666+10	050C' E1      	                pop hl
 880: 5676+10	050D' C9      	                ret
 881:				;
 882:				;
 883:				; Write "s" (bc, de, Y [HL, IX or IY] or sp) to dis_buf.
 884:				; Call with:
 885:				; A - index
 886: 5686+7	050E' FE02    	di_out_s        cp 2
 887: 5693+7+5	0510' 2809    	                jr z, di_out_y
 888: 5700+11	0512' E5      	                push hl
 889:				; Write register name.
 890: 5711+10	0513' 21E807  	                ld hl, s_codes_msg
 891: 5721+17	0516' CD3F05  	                call di_outmsgn     ; Output message <n>
 892: 5738+10	0519' E1      	                pop hl
 893: 5748+10	051A' C9      	                ret
 894:				;
 895:				;
 896:				; Write "Y" (HL, IX or IY according to index) to dis_buf.
 897: 5758+11	051B' E5      	di_out_y        push hl
 898: 5769+13	051C' 3A0A00  	                ld a, (index)
 899: 5782+10	051F' 21FC07  	                ld hl, hlixiy_msg
 900: 5792+17	0522' CD3F05  	                call di_outmsgn     ; Output message <n>
 901: 5809+10	0525' E1      	                pop hl
 902: 5819+10	0526' C9      	                ret
 903:				;
 904:				;
 905:				; Write condition code to dis_buf.
 906:				; Call with:
 907:				; A - condition code
 908: 5829+11	0527' E5      	di_out_c        push hl
 909: 5840+10	0528' 21D407  	                ld hl, con_codes_msg
 910: 5850+17	052B' CD3F05  	                call di_outmsgn     ; Output message <n>
 911: 5867+10	052E' E1      	                pop hl
 912: 5877+10	052F' C9      	                ret
 913:				;
 914:				;
 915:				; Write "," to dis_buf.
 916: 5887+7	0530' 3E2C    	di_comma        ld a, ','
 917: 5894+10	0532' C37405  	                jp di_outchar
 918:				;
 919:				;
 920:				; Write ", " or just a space to dis_buf.
 921: 5904+7	0535' 3E2C    	di_comma_spc    ld a, ','
 922: 5911+17	0537' CD7405  	                call di_outchar
 923: 5928+7	053A' 3E20    	di_spc          ld a, ' '
 924: 5935+10	053C' C37405  	                jp di_outchar
 925:				;
 926:				;
 927:				; Write message <n> in a null terminated list to dis_buf. Nothing is printed if the
 928:				; terminator is encountered before message <n> is found. The message separator is "|".
 929:				; Call with:
 930:				; A - number of message to print (first is zero)
 931:				; HL - pointer to start of message
 932:				; Returns with:
 933:				; HL - points to the separator at the end of the message printed, or the
 934:				; terminator.
 935:				; Carry flag is set if the message was not found (terminator encountered).
 936: 5945+11	053F' C5      	di_outmsgn      push bc
 937: 5956+4	0540' 47      	                ld b, a             ; Message number
 938: 5960+4	0541' 78      	omn_msg_lp      ld a, b
 939: 5964+4	0542' A7      	                and a
 940: 5968+7+5	0543' 280C    	                jr z, omn_found     ; Jump if this is the one
 941:				; Skip to next message.
 942: 5975+7	0545' 7E      	omn_sk_lp       ld a, (hl)
 943: 5982+4	0546' A7      	                and a
 944: 5986+7+5	0547' 2819    	                jr z, omn_error     ; Error if terminator
 945: 5993+6	0549' 23      	                inc hl
 946: 5999+7	054A' FE7C    	                cp '|'
 947: 6006+7+5	054C' 20F7    	                jr nz, omn_sk_lp    ; Keep going if not separator or terminator
 948:				; Separator found
 949: 6013+4	054E' 05      	                dec b
 950: 6017+12	054F' 18F0    	                jr omn_msg_lp
 951:				; HL now points to the requied message. Print it until the separator or
 952:				; terminator is encountered.
 953: 6029+7	0551' 7E      	omn_found       ld a, (hl)
 954: 6036+4	0552' A7      	                and a
 955: 6040+7+5	0553' 280A    	                jr z, omn_done      ; Exit if terminator found
 956: 6047+7	0555' FE7C    	                cp '|'
 957: 6054+7+5	0557' 2806    	                jr z, omn_done      ; Exit if separator found
 958: 6061+17	0559' CD7405  	                call di_outchar     ; Output character
 959: 6078+6	055C' 23      	                inc hl              ; Increment character pointer
 960: 6084+12	055D' 18F2    	                jr omn_found        ; Transmit next character
 961:				; Successful completion.
 962: 6096+10	055F' C1      	omn_done        pop bc
 963: 6106+4	0560' A7      	                and a
 964: 6110+10	0561' C9      	                ret                 ; Return with carry reset (no error)
 965:				; Terminator encountered before the message was found
 966: 6120+10	0562' C1      	omn_error       pop bc              ; Restore registers
 967: 6130+4	0563' 37      	                scf
 968: 6134+10	0564' C9      	                ret                 ; Return with carry set (error)
 969:				;
 970:				;
 971:				; As di_outmsg, but follows with a space. This is mainly useful for instructions.
 972:				; Call with:
 973:				; HL - pointer to string
 974: 6144+17	0565' CD6B05  	di_outmsgspc    call di_outmsg
 975: 6161+10	0568' C33A05  	                jp di_spc           ; Write a space
 976:				;
 977:				;
 978:				; Write a null-terminated string to dis_buf.
 979:				; Call with:
 980:				; HL - pointer to string
 981: 6171+7	056B' 7E      	di_outmsg       ld a, (hl)
 982: 6178+4	056C' A7      	                and a
 983: 6182+5+6	056D' C8      	                ret z               ; Return if terminator found
 984: 6187+17	056E' CD7405  	                call di_outchar
 985: 6204+6	0571' 23      	                inc hl
 986: 6210+12	0572' 18F7    	                jr di_outmsg
 987:				;
 988:				;
 989:				; Write character to dis_buf.
 990:				; Call with:
 991:				; A - character
 992: 6222+11	0574' E5      	di_outchar      push hl
 993: 6233+11	0575' F5      	                push af
 994: 6244+13	0576' 3A2100  	                ld a, (db_count)
 995: 6257+7	0579' FE10    	                cp DIS_BUF_SIZE
 996: 6264+7+5	057B' 3011    	                jr nc, oc_overflow
 997: 6271+10	057D' 211100  	                ld hl, dis_buf      ; Point to output buffer
 998:				; Add offset
 999: 6281+4	0580' 85      	                add a, l
1000: 6285+4	0581' 6F      	                ld l, a
1001: 6289+4	0582' 7C      	                ld a, h
1002: 6293+7	0583' CE00    	                adc 0
1003: 6300+4	0585' 67      	                ld h, a
1004: 6304+10	0586' F1      	                pop af
1005: 6314+7	0587' 77      	                ld (hl), a          ; Store character
1006: 6321+10	0588' 212100  	                ld hl, db_count
1007: 6331+11	058B' 34      	                inc (hl)
1008: 6342+10	058C' E1      	                pop hl
1009: 6352+10	058D' C9      	                ret
1010:				;
1011:				; Output buffer is full. Silently discard the new character. This should never
1012:				; occur, but butter this than overwrite innocent memory.
1013: 6362+10	058E' F1      	oc_overflow     pop af
1014: 6372+10	058F' E1      	                pop hl
1015: 6382+10	0590' C9      	                ret
1016:				;
1017:				;
1018:				; Print the instruction in the intermediate buffer to the console, performing
1019:				; translations as required. There are no operands or return values.
1020: 6392+11	0591' C5      	diprnt          push bc
1021: 6403+11	0592' D5      	                push de
1022: 6414+11	0593' E5      	                push hl
1023: 6425+16	0594' 2A0200  	                ld hl, (start_pc)   ; Fetch start address
1024: 6441+17	0597' CD0000  	                call cwphwd         ; Print HL in hexadecimal
1025: 6458+17	059A' CD0000  	                call cwpspc         ; Print a space
1026: 6475+17	059D' CD0000  	                call cwpspc
1027:				; Print instruction in hex (up to 4 bytes).
1028: 6492+10	05A0' 210400  	                ld hl, instr_buf    ; Point to buffer
1029: 6502+7	05A3' 0601    	                ld b, 1             ; Byte counter (1 to DIS_MAX_INSTLEN)
1030:				; Loop for maximum (valid) instruction length.
1031: 6509+13	05A5' 3A0800  	dip_by_loop     ld a, (instr_len)
1032: 6522+4	05A8' B8      	                cp b
1033: 6526+7+5	05A9' 3806    	                jr c, dip_by_skip
1034:				; Print the byte
1035: 6533+7	05AB' 7E      	                ld a, (hl)
1036: 6540+17	05AC' CD0000  	                call cwphby         ; Print A in hexadecimal
1037: 6557+12	05AF' 1806    	                jr dip_by_done
1038:				; Write spaces to maintain alignment.
1039: 6569+17	05B1' CD0000  	dip_by_skip     call cwpspc         ; Print a space
1040: 6586+17	05B4' CD0000  	                call cwpspc
1041:				; Byte complete.
1042: 6603+17	05B7' CD0000  	dip_by_done     call cwpspc
1043: 6620+6	05BA' 23      	                inc hl
1044: 6626+4	05BB' 04      	                inc b
1045: 6630+7	05BC' 3E04    	                ld a, DIS_MAX_INSTLEN
1046: 6637+4	05BE' B8      	                cp b
1047: 6641+7+5	05BF' 30E4    	                jr nc, dip_by_loop
1048: 6648+17	05C1' CD0000  	                call cwpspc   ; Print a space
1049:				; Hex complete. Now write the disassembled instruction string, making substitutions
1050:				; as required.
1051: 6665+10	05C4' 211100  	                ld hl, dis_buf      ; Point to output buffer
1052: 6675+13	05C7' 3A2100  	                ld a, (db_count)
1053: 6688+4	05CA' A7      	                and a
1054: 6692+7+5	05CB' 2818    	                jr z, dipr_done     ; Exit if string is null
1055: 6699+4	05CD' 47      	                ld b, a             ; Length of string
1056: 6703+7	05CE' 7E      	dipr_loop       ld a, (hl)
1057: 6710+6	05CF' 23      	                inc hl
1058: 6716+7	05D0' FE56    	                cp 'V'
1059: 6723+7+5	05D2' 2815    	                jr z, dipr_hex8
1060: 6730+7	05D4' FE57    	                cp 'W'
1061: 6737+7+5	05D6' 281C    	                jr z, dipr_hex16
1062: 6744+7	05D8' FE4F    	                cp 'O'
1063: 6751+7+5	05DA' 2828    	                jr z, dipr_offset
1064: 6758+7	05DC' FE2A    	                cp '*'
1065: 6765+7+5	05DE' 283F    	                jr z, dipr_illegal
1066: 6772+17	05E0' CD0000  	                call cwvich   ; Print only visible 7-bit characters
1067: 6789+8+5	05E3' 10E9    	dipr_cont       djnz dipr_loop
1068: 6797+10	05E5' E1      	dipr_done       pop hl
1069: 6807+10	05E6' D1      	                pop de
1070: 6817+10	05E7' C1      	                pop bc
1071: 6827+10	05E8' C9      	                ret
1072:				;
1073:				; "V" is replaced by the following 8-bit value in hex.
1074: 6837+17	05E9' CD2706  	dipr_hex8       call hex_pref
1075: 6854+7	05EC' 7E      	                ld a, (hl)          ; Fetch value
1076: 6861+6	05ED' 23      	                inc hl
1077: 6867+4	05EE' 05      	                dec b
1078: 6871+17	05EF' CD0000  	                call cwphby         ; Print A in hexadecimal
1079: 6888+12	05F2' 18EF    	                jr dipr_cont
1080:				;
1081:				; "W" is replaced by the following 16-bit value in hex.
1082: 6900+17	05F4' CD2706  	dipr_hex16      call hex_pref
1083: 6917+7	05F7' 5E      	                ld e, (hl)          ; Fetch LSB
1084: 6924+6	05F8' 23      	                inc hl
1085: 6930+4	05F9' 05      	                dec b
1086: 6934+7	05FA' 56      	                ld d, (hl)          ; Fetch MSB
1087: 6941+6	05FB' 23      	                inc hl
1088: 6947+4	05FC' 05      	                dec b
1089: 6951+4	05FD' EB      	                ex de, hl
1090: 6955+17	05FE' CD0000  	                call cwphwd         ; Print HL in hexadecimal
1091: 6972+4	0601' EB      	                ex de, hl
1092: 6976+12	0602' 18DF    	                jr dipr_cont
1093:				;
1094:				; "O" is replaced by the following 8-bit signed offset in decimal [e.g. (IX + 10)]
1095: 6988+7	0604' 7E      	dipr_offset     ld a, (hl)          ; Fetch value
1096: 6995+6	0605' 23      	                inc hl
1097: 7001+4	0606' 05      	                dec b
1098: 7005+7	0607' 0E2B    	                ld c, '+'           ; Assume a positive value initially
1099: 7012+4	0609' A7      	                and a
1100: 7016+10	060A' F21106  	                jp p, dipro_sign
1101:				; Handle negative values.
1102: 7026+7	060D' 0E2D    	                ld c, '-'           ; Correct sign
1103: 7033+8	060F' ED44    	                neg                 ; Make value positive
1104: 7041+11	0611' F5      	dipro_sign      push af             ; Save value
1105: 7052+4	0612' 79      	                ld a, c
1106: 7056+17	0613' CD0000  	                call conwch         ; Write sign to the console
1107: 7073+17	0616' CD0000  	                call cwpspc         ; Print a space
1108: 7090+10	0619' F1      	                pop af
1109: 7100+17	061A' CD0000  	                call cwpdby         ; Print A in decimal. Leading zeros are suppressed.
1110: 7117+12	061D' 18C4    	                jr dipr_cont
1111:				;
1112:				; "*" is replaced by the word "illegal", to indicate an illegal instruction.
1113: 7129+10	061F' 219407  	dipr_illegal    ld hl, illegal_msg
1114: 7139+17	0622' CD6B05  	                call di_outmsg      ; Output instruction
1115: 7156+12	0625' 18BC    	                jr dipr_cont
1116:				;
1117:				; Print hexadecimal prefix ("0x").
1118: 7168+7	0627' 3E30    	hex_pref        ld a, '0'
1119: 7175+17	0629' CD0000  	                call conwch         ; Write character in A to the console
1120: 7192+7	062C' 3E78    	                ld a, 'x'
1121: 7199+17	062E' CD0000  	                call conwch         ; Write character in A to the console
1122: 7216+10	0631' C9      	                ret
1123:				;
1124:				;
1125:				;
1126:				; *************
1127:				; * Constants *
1128:				; *************
1129:				;
1130:				;
1131:     -	0632' 6E6F707C	c0f0h0g_msg     byte "nop|ex af, af'|djnz|jr", 0
	              65782061
	              662C2061
	              66277C64
	              6A6E7A7C
	              6A7200
1132:     -	0649' 726C6361	dic0f0h7_msg    byte "rlca|rrca|rla|rra|daa|cpl|scf|ccf", 0
	              7C727263
	              617C726C
	              617C7272
	              617C6461
	              617C6370
	              6C7C7363
	              667C6363
	              6600
1133:     -	066B' 7265747C	dic0f3h1k1_msg  byte "ret|exx|jp |ld ", 0
	              6578787C
	              6A70207C
	              6C642000
1134:     -	067B' 6A70207C	dic0f3h3_msg    byte "jp |*|out (|in a, (|ex (sp), |ex de, hl|di|ei", 0
	              2A7C6F75
	              7420287C
	              696E2061
	              2C20287C
	              65782028
	              7370292C
	              207C6578
	              2064652C
	              20686C7C
	              64697C65
	              6900
1135:     -	06A9' 726C637C	dic1f0_msg      byte "rlc|rrc|rl|rr|sla|sra|*|srl", 0
	              7272637C
	              726C7C72
	              727C736C
	              617C7372
	              617C2A7C
	              73726C00
1136:     -	06C5' 6C642069	dic2f1h7_msg    byte "ld i, a|ld r, a|ld a, i|ld a, r|rrd|rld|*|*", 0
	              2C20617C
	              6C642072
	              2C20617C
	              6C642061
	              2C20697C
	              6C642061
	              2C20727C
	              7272647C
	              726C647C
	              2A7C2A00
1137:     -	06F1' 6C647C63	dic2f2_1_msg    byte "ld|cp|in|ot|*|*|*|*", 0
	              707C696E
	              7C6F747C
	              2A7C2A7C
	              2A7C2A00
1138:     -	0705' 2A7C2A7C	dic2f2_2_msg    byte "*|*|*|*|i|d|ir|dr", 0
	              2A7C2A7C
	              697C647C
	              69727C64
	              7200
1139:     -	0717' 61646420	xinst_codes_msg byte "add a,|adc a,|sub|sbc a,|and|xor|or|cp", 0
	              612C7C61
	              64632061
	              2C7C7375
	              627C7362
	              6320612C
	              7C616E64
	              7C786F72
	              7C6F727C
	              637000
1140:     -	073E' 68616C74	halt_msg        byte "halt", 0
	              00
1141:     -	0743' 6A7200  	jr_msg          byte "jr", 0
1142:     -	0746' 6C6400  	ld_msg          byte "ld", 0
1143:     -	0749' 61646400	add_msg         byte "add", 0
1144:     -	074D' 696E6300	inc_msg         byte "inc", 0
1145:     -	0751' 64656300	dec_msg         byte "dec", 0
1146:     -	0755' 706F7000	pop_msg         byte "pop", 0
1147:     -	0759' 72657400	ret_msg         byte "ret", 0
1148:     -	075D' 6A7000  	jp_msg          byte "jp", 0
1149:     -	0760' 73702C00	sp_msg          byte "sp,", 0
1150:     -	0764' 63616C6C	call_msg        byte "call", 0
	              00
1151:     -	0769' 70757368	push_msg        byte "push", 0
	              00
1152:     -	076E' 72737400	rst_msg         byte "rst", 0
1153:     -	0772' 62697400	bit_msg         byte "bit", 0
1154:     -	0776' 72657300	res_msg         byte "res", 0
1155:     -	077A' 73657400	set_msg         byte "set", 0
1156:     -	077E' 696E00  	in_msg          byte "in", 0
1157:     -	0781' 6F757400	out_msg         byte "out", 0
1158:     -	0785' 73626300	sbc_msg         byte "sbc", 0
1159:     -	0789' 6E656700	neg_msg         byte "neg", 0
1160:     -	078D' 61646300	adc_msg         byte "adc", 0
1161:     -	0791' 696D00  	im_msg          byte "im", 0
1162:     -	0794' 696C6C65	illegal_msg     byte "illegal", 0
	              67616C00
1163:     -	079C' 28632900	iocp_msg        byte "(c)", 0
1164:     -	07A0' 686C2C00	hlc_msg         byte "hl,", 0
1165:     -	07A4' 28626329	ld_ptr_msg      byte "(bc), a|a, (bc)|(de), a|a, (de)", 0
	              2C20617C
	              612C2028
	              6263297C
	              28646529
	              2C20617C
	              612C2028
	              64652900
1166:     -	07C4' 627C637C	r_codes_msg     byte "b|c|d|e|h|l|x|a", 0       ; Note no. 6 is (HL), (IX+d) or (IY+d)
	              647C657C
	              687C6C7C
	              787C6100
1167:     -	07D4' 6E7A7C7A	con_codes_msg   byte "nz|z|nc|c|po|pe|p|m", 0            
	              7C6E637C
	              637C706F
	              7C70657C
	              707C6D00
1168:     -	07E8' 62637C64	s_codes_msg     byte "bc|de||sp", 0             ; Note no. 2 is HL, IX or IY
	              657C7C73
	              7000
1169:     -	07F2' 62637C64	q_codes_msg     byte "bc|de||af", 0             ; Note no. 2 is HL, IX or IY
	              657C7C61
	              6600
1170:     -	07FC' 686C7C69	hlixiy_msg      byte "hl|ix|iy", 0
	              787C6979
	              00
1171:     -	0805' 28686C29	phlixiy_msg     byte "(hl)|(ix |(iy ", 0
	              7C286978
	              207C2869
	              792000
1172:     -	0814' 292C2061	cpcomma_a_msg   byte "), a", 0
	              00
1173:				;
1174:				;
1175:				;
1176:				; *************
1177:				; * Variables *
1178:				; *************
1179:				;
1180:				;
1181:				; Note: linker "-c" option is used, so no data is initialised here.
1182:				                dseg                ; Data segment
1183:     -	0000"         	pc              defs 2              ; Programme counter
1184:     -	0002"         	start_pc        defs 2              ; Instruction start
1185:     -	0004"         	instr_buf       defs DIS_MAX_INSTLEN    ; The disassembled instruction
1186:     -	0008"         	instr_len       defs 1              ; Length
1187:     -	0009"         	class           defs 1              ; Instruction class
1188:     -	000A"         	index           defs 1              ; Index type
1189:     -	000B"         	inst_f          defs 1              ; Instruction fields
1190:     -	000C"         	inst_g          defs 1
1191:     -	000D"         	inst_h          defs 1
1192:     -	000E"         	inst_j          defs 1
1193:     -	000F"         	inst_k          defs 1
1194:     -	0010"         	idx_offset      defs 1              ; Offset for indexed instructions
1195:     -	0011"         	dis_buf         defs DIS_BUF_SIZE   ; Intermediate disassembly buffer
1196:     -	0021"         	db_count        defs 1              ; Number of characters in dis_buf
1197:				;
1198:     -	0022"         	                end



Statistics:

     4	passes
     0	jr promotions
   410	symbols
  2073	bytes

   117	macro calls
  1320	macro bytes
     0	invented symbols



Symbol Table:

DIS_BUF_SIZE   =10        16
DIS_MAX_INSTLEN=04        4
I2C_CSR_ACKN_BIT=00        0
I2C_CSR_ACKN_MASK=01        1
I2C_CSR_BUSY_BIT=07        7
I2C_CSR_BUSY_MASK=80        128
I2C_CSR_START_BIT=01        1
I2C_CSR_START_MASK=02        2
I2C_CSR_STOP_BIT=02        2
I2C_CSR_STOP_MASK=04        4
INTS_NUM       =08        8
INT_SER1_RX_BIT=01        1
INT_SER1_RX_MASK=02        2
INT_SER1_RX_VEC=01        1
INT_SER1_TX_BIT=00        0
INT_SER1_TX_MASK=01        1
INT_SER1_TX_VEC=00        0
INT_SER2_RX_BIT=03        3
INT_SER2_RX_MASK=08        8
INT_SER2_RX_VEC=03        3
INT_SER2_TX_BIT=02        2
INT_SER2_TX_MASK=04        4
INT_SER2_TX_VEC=02        2
INT_TICK_BIT   =04        4
INT_TICK_MASK  =10        16
INT_TICK_VEC   =04        4
IOA_CONTROL    =02        2
IOA_CRC_0      =24        36
IOA_CRC_1      =25        37
IOA_CRC_DATA   =26        38
IOA_FPGA_MAJREV=00        0
IOA_FPGA_MINREV=01        1
IOA_FP_SW      =03        3
IOA_I2C_CSR    =18        24
IOA_I2C_DATA   =19        25
IOA_INT_EN     =08        8
IOA_INT_PEND   =0A        10
IOA_MMAP_0     =04        4
IOA_MMAP_1     =05        5
IOA_MMAP_2     =06        6
IOA_MMAP_3     =07        7
IOA_NMI_REASONS=0C        12
IOA_SER1_CSR   =10        16
IOA_SER1_DATA  =11        17
IOA_SER2_CSR   =12        18
IOA_SER2_DATA  =13        19
IOA_SPI_CSR    =20        32
IOA_SPI_DATA   =21        33
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MMAP_PAGE_MASK =3F        63
MMAP_PROT_BIT  =07        7
MMAP_PROT_MASK =80        128
MMAP_SUPER_BIT =06        6
MMAP_SUPER_MASK=40        64
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MS_PER_TICK    =64        100
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NMI_PROT_VIOL_BIT=01        1
NMI_PROT_VIOL_MASK=02        2
NMI_REASONS_ALL=0F        15
NMI_REASONS_NUM=04        4
NMI_SUPER_VIOL_BIT=02        2
NMI_SUPER_VIOL_MASK=04        4
NMI_SWITCH_BIT =00        0
NMI_SWITCH_MASK=01        1
NMI_TRACE_BIT  =03        3
NMI_TRACE_MASK =08        8
PORT_SER1      =00        0
PORT_SER2      =01        1
PORT_STATES    =02        2
SER_CSR_FRAME_ERR_BIT=03        3
SER_CSR_FRAME_ERR_MASK=08        8
SER_CSR_RX_ALHALF_BIT=01        1
SER_CSR_RX_ALHALF_MASK=02        2
SER_CSR_RX_EMPTY_BIT=00        0
SER_CSR_RX_EMPTY_MASK=01        1
SER_CSR_RX_FULL_BIT=02        2
SER_CSR_RX_FULL_MASK=04        4
SER_CSR_TX_ALHALF_BIT=05        5
SER_CSR_TX_ALHALF_MASK=20        32
SER_CSR_TX_EMPTY_BIT=04        4
SER_CSR_TX_EMPTY_MASK=10        16
SER_CSR_TX_FULL_BIT=06        6
SER_CSR_TX_FULL_MASK=40        64
SPI_CSR_BUSY_BIT=07        7
SPI_CSR_BUSY_MASK=80        128
SPI_CSR_FAST_BIT=00        0
SPI_CSR_FAST_MASK=01        1
SPI_CSR_MC_SS_BIT=01        1
SPI_CSR_MC_SS_MASK=02        2
SYSCTRL_MAPARM_BIT=03        3
SYSCTRL_MAPARM_MASK=08        8
SYSCTRL_MMAPN_BIT=04        4
SYSCTRL_MMAPN_MASK=10        16
SYSCTRL_MMAP_BIT=01        1
SYSCTRL_MMAP_MASK=02        2
SYSCTRL_NMCLR_BIT=02        2
SYSCTRL_NMCLR_MASK=04        4
SYSCTRL_RESERVED_BIT=07        7
SYSCTRL_RESERVED_MASK=80        128
SYSCTRL_TRARM_BIT=00        0
SYSCTRL_TRARM_MASK=01        1
SYSCTRL_TRPRE0_BIT=05        5
SYSCTRL_TRPRE0_MASK=20        32
SYSCTRL_TRPRE1_BIT=06        6
SYSCTRL_TRPRE1_MASK=40        64
TICK_FREQ      =0A        10
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
adc_msg          78D'     1933
add_msg          749'     1865
bit_msg          772'     1906
c0f0h0g_msg      632'     1586
call_msg         764'     1892
class           09"       9
con_codes_msg    7D4'     2004
conrch          00        0 (extern)
consta          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
coport          00        0 (extern)
cpcomma_a_msg    814'     2068
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
db_count        21"       33
dec_msg          751'     1873
di_class_one     2FD'     765
di_class_two     345'     837
di_class_zero   5B'       91
di_comma         530'     1328
di_comma_spc     535'     1333
di_fetch         478'     1144
di_illegal       350'     848
di_out_c         527'     1319
di_out_pvv       44F'     1103
di_out_q         501'     1281
di_out_r         4C7'     1223
di_out_s         50E'     1294
di_out_v         45C'     1116
di_out_vv        467'     1127
di_out_x         4D4'     1236
di_out_xinst     4BE'     1214
di_out_y         51B'     1307
di_outchar       574'     1396
di_outmsg        56B'     1387
di_outmsgn       53F'     1343
di_outmsgspc     565'     1381
di_rel_jmp       49E'     1182
di_spc           53A'     1338
dic0_idx_skip   6C'       108
dic0_not_cb     75'       117
dic0_not_dd     97'       151
dic0_not_ed     89'       137
dic0_pref_dn    A5'       165
dic0f0          BA'       186
dic0f0h0        DD'       221
dic0f0h0_njrcc  F5'       245
dic0f0h1         107'     263
dic0f0h1_add     11F'     287
dic0f0h2         131'     305
dic0f0h2_vv      144'     324
dic0f0h2gg4      154'     340
dic0f0h2gg5      15D'     349
dic0f0h2gg6      166'     358
dic0f0h2gg7      171'     369
dic0f0h3         17C'     380
dic0f0h3_dec     18E'     398
dic0f0h4         19A'     410
dic0f0h5         1A6'     422
dic0f0h6         1B2'     434
dic0f0h7         1C4'     452
dic0f0h7_msg     649'     1609
dic0f1           1CD'     461
dic0f1_not_halt  1D8'     472
dic0f2           1ED'     493
dic0f3           1FC'     508
dic0f3h0         21F'     543
dic0f3h1         22B'     555
dic0f3h1k1       23D'     573
dic0f3h1k1_msg   66B'     1643
dic0f3h1k1j2     252'     594
dic0f3h1k1j3     25F'     607
dic0f3h2         268'     616
dic0f3h3         27A'     634
dic0f3h3_msg     67B'     1659
dic0f3h3g0       296'     662
dic0f3h3g2       299'     665
dic0f3h3g3       2A2'     674
dic0f3h3g4       2AA'     682
dic0f3h4         2AD'     685
dic0f3h5         2BF'     703
dic0f3h5k1       2D1'     721
dic0f3h6         2DA'     730
dic0f3h7         2E6'     742
dic1_brs         327'     807
dic1f0           312'     786
dic1f0_msg       6A9'     1705
dic1f1           324'     804
dic1f2           33B'     827
dic1f3           340'     832
dic2f1           355'     853
dic2f1h0         378'     888
dic2f1h1         38D'     909
dic2f1h2         3A2'     930
dic2f1h2_sa      3B1'     945
dic2f1h2k0       3AE'     942
dic2f1h2k1       3C0'     960
dic2f1h3         3C5'     965
dic2f1h3k0       3D7'     983
dic2f1h3k1       3E3'     995
dic2f1h4         3EF'     1007
dic2f1h5         3F5'     1013
dic2f1h5k0       407'     1031
dic2f1h5k1       40C'     1036
dic2f1h6         411'     1041
dic2f1h6_im0     428'     1064
dic2f1h6_im12    429'     1065
dic2f1h7         42E'     1070
dic2f1h7_msg     6C5'     1733
dic2f2           437'     1079
dic2f2_1_msg     6F1'     1777
dic2f2_2_msg     705'     1797
dif_toolong      499'     1177
diox_have_off    4F8'     1272
dip_by_done      5B7'     1463
dip_by_loop      5A5'     1445
dip_by_skip      5B1'     1457
dip_done         449'     1097
dip_inst        15'       21
dipr_cont        5E3'     1507
dipr_done        5E5'     1509
dipr_hex16       5F4'     1524
dipr_hex8        5E9'     1513
dipr_illegal     61F'     1567
dipr_loop        5CE'     1486
dipr_offset      604'     1540
diprnt           591'     1425 (public)
dipro_sign       611'     1553
diproc          00'       0 (public)
dis_buf         11"       17
disass         =01        1
enum_counter   =02        2
halt_msg         73E'     1854
hex_pref         627'     1575
hlc_msg          7A0'     1952
hlixiy_msg       7FC'     2044
i2crd           00        0 (extern)
i2cwr           00        0 (extern)
idx_offset      10"       16
illegal_msg      794'     1940
im_msg           791'     1937
in_msg           77E'     1918
inc_msg          74D'     1869
index           0A"       10
inst_f          0B"       11
inst_g          0C"       12
inst_h          0D"       13
inst_j          0E"       14
inst_k          0F"       15
instr_buf       04"       4
instr_len       08"       8
iocp_msg         79C'     1948
jp_msg           75D'     1885
jptbl_addr     =F6        246
jr_msg           743'     1859
ld_msg           746'     1862
ld_ptr_msg       7A4'     1956
monitor        =01        1
mtwdli          00        0 (extern)
neg_msg          789'     1929
oc_overflow      58E'     1422
omn_done         55F'     1375
omn_error        562'     1378
omn_found        551'     1361
omn_msg_lp       541'     1345
omn_sk_lp        545'     1349
out_msg          781'     1921
panic           00        0 (extern)
pc              00"       0
phlixiy_msg      805'     2053
pop_msg          755'     1877
push_msg         769'     1897
q_codes_msg      7F2'     2034
r_codes_msg      7C4'     1988
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
res_msg          776'     1910
ret_msg          759'     1881
rj_sexdn         4AC'     1196
rst_msg          76E'     1902
rusby           00        0 (extern)
ruswd           00        0 (extern)
s1rch           00        0 (extern)
s1sta           00        0 (extern)
s1wch           00        0 (extern)
s2rch           00        0 (extern)
s2sta           00        0 (extern)
s2wch           00        0 (extern)
s_codes_msg      7E8'     2024
sbc_msg          785'     1925
set_msg          77A'     1914
skpspc          00        0 (extern)
sp_msg           760'     1888
spiini          00        0 (extern)
spiss           00        0 (extern)
spitr           00        0 (extern)
start_pc        02"       2
str_offset     =20        32
tikcnt          00        0 (extern)
toloca          00        0 (extern)
toupca          00        0 (extern)
trarch          00        0 (extern)
trawch          00        0 (extern)
trport          00        0 (extern)
wusby           00        0 (extern)
wuswd           00        0 (extern)
xinst_codes_msg  717'     1815
