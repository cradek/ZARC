   1:				; *******************************************************
   2:				; * Monitor for ZARC Z80 Computer                       *
   3:				; * (Serial boot version).                              *
   4:				; * Version: V0.0                                       *
   5:				; * Merlin Skinner, 14/5/2020                           *
   6:				; *******************************************************
   7:				;
   8:				; This code will be loaded from the console serial port by the stage 1 bootloader.
   9:				; This is entered manually from the front panel:
  10:				;
  11:				; 3FE0                          .ORG   0x3fe0   ; Use top of page
  12:				; 3FE0   3E 7F                  LD   a,0x7f     ; Page 0x3f, SUPER=1 and PROT=0
  13:				; 3FE2   D3 04                  OUT   0x04,a    ; Page and prot. 0x0000-0x3fff
  14:				; 3FE4   3E 02                  LD   a,0x02
  15:				; 3FE6   D3 02                  OUT   0x02,a    ; Enable memory mapping
  16:				; 3FE8   0E 11                  LD   c,0x11     ; Select console input port
  17:				; 3FEA   21 00 00               LD   hl,0x0000  ; Start address 
  18:				; 3FED                LOOP:     
  19:				; 3FED   ED A2                  INI
  20:				; 3FEF   18 FC                  JR   loop       ; Load data until reset
  21:				;
  22:				; The above was assembled with the online assembler at:
  23:				; https://www.asm80.com/onepage/asmz80.html
  24:				;
  25:				; This loads raw binary data from the serial port into memory starting at location
  26:				; zero. Press reset to stop the loader and run the newly downloaded code.
  27:				;
  28:				;
  29:				; Memory Map (Monitor Mode)
  30:				; 
  31:				; 0 (0000 - 3FFF): 3f read only, supervisor - monitor program
  32:				; 1 (4000 - 7FFF): 3e writeable - monitor variables, stacks, buffers etc.
  33:				; 2 (8000 - BFFF): (not used)
  34:				; 3 (C000 - FFFF): (mapped as required)
  35:				;
  36:				; This is the default map used by the monitor, and is selected when the monitor is
  37:				; active either for user commands or when its support routines are called. Pages
  38:				; are mapped into banks 2 and 3 as required to support this. Page 0x3f is
  39:				; selected in hardware when memory mapping is not active, so on reset the monitor
  40:				; (page 0x3f at address 0) is entered.
  41:				;
  42:				; A special memory mapping mode is enabled when NMI is serviced. In this mode,
  43:				; the memory mapping system is disabled except for write operations. As a result,
  44:				; handling code in page 0x3f is executed and writes proceed to the previously
  45:				; selected bank.
  46:				;
  47:				; Memory Map (CP/M Mode)
  48:				; 
  49:				; 0 (0000 - 3FFF): 00 writeable
  50:				; 1 (4000 - 7FFF): 01 writeable
  51:				; 2 (8000 - BFFF): 02 writeable
  52:				; 3 (C000 - FFFF): 03 writeable
  53:				;
  54:				; When running CP/M, memory is mapped as shown above.
  55:				;
  56:				;
  57:				                title ZARC Monitor
  58:				;
  59:     -	0001'         	monitor         equ 1                   ; Flag part of monitor build
  60:     -	0001'         	main            equ 1                   ; Flag module for includes
  61:				;
  62:				;
  63:				;
  64:				; ************
  65:				; * Includes *
  66:				; ************
  67:				;
  68:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				
**** monitor.z80 ****
  69:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** monitor.z80 ****
  70:				                include "zarc.i"        ; Hardware definitions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//zarc.i ****
   1:				; ***********************************
   2:				; * ZARC Definitions                *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 26/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the ZARC system.
   8:				;
   9:				;
  10:				; ************
  11:				; * Hardware *
  12:				; ************
  13:				;
  14:				; Interrupt vector numbers in INT_VEC_TABLE.
  15:				; Address is INT_VEC_TABLE + 2 * vector number).
  16:     -	0000'         	INT_SER1_TX_VEC     equ INT_SER1_TX_BIT ; Serial port 1 transmitter buffer is half full or less
  17:     -	0001'         	INT_SER1_RX_VEC     equ INT_SER1_RX_BIT ; Serial port 1 receiver has data
  18:     -	0002'         	INT_SER2_TX_VEC     equ INT_SER2_TX_BIT ; Serial port 2 transmitter buffer is half full or less
  19:     -	0003'         	INT_SER2_RX_VEC     equ INT_SER2_RX_BIT ; Serial port 2 receiver has data
  20:     -	0004'         	INT_TICK_VEC        equ INT_TICK_BIT    ; Regular timekeeping
  21:				;
  22:     -	0064'         	MS_PER_TICK         equ 100             ; ms per tick
  23:     -	000A'         	TICK_FREQ           equ 10              ; Tick rate in Hz
  24:				;
  25:				
**** monitor.z80 ****
  71:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  18:     -	0000'         	                ifndef main         ; Inhibit for this module
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** monitor.z80 ****
  72:				                include "commands.i"    ; Monitor commands
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//commands.i ****
   1:				; ***********************************************
   2:				; * Commands for ZARC Include File              *
   3:				; * Written by: Merlin Skinner                  *
   4:				; * Date Started: 30/4/2021                     *
   5:				; ***********************************************
   6:				;
   7:				; Constants and structures associated with the ZARC monitor command module.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef commands     ; Inhibit for this module
  16:				; Functions
  17:				                extern mcexec       ; Execute a command
  18:				; Variables
  19:				; (None)
  20:				                endif
  21:				            endif
  22:				;
  23:				;
  24:				;MCCA_BUFFERS                equ 16      ; Number of cached sector buffers
  25:				;
  26:				
**** monitor.z80 ****
  73:				                include "io_map.i"      ; I/O addresses mapping
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io_map.i ****
   1:				; ***********************************
   2:				; * ZARC I/O Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 3/9/2019          *
   5:				; ***********************************
   6:				
   7:				; *** I/O register address mapping ***
   8:				
   9:				; This should be kept in sync with the Definitions.vhd package file.
  10:     -	0000'         	IOA_FPGA_MAJREV equ 0x00        ; FPGA major revision
  11:     -	0001'         	IOA_FPGA_MINREV equ 0x01        ; FPGA minor revision
  12:     -	0002'         	IOA_CONTROL     equ 0x02        ; System control register
  13:     -	0003'         	IOA_FP_SW       equ 0x03        ; Front panel data switches
  14:				
  15:				; Paging
  16:     -	0004'         	IOA_MMAP_0      equ 0x04        ; Page, supervisor and protection for bank 0 (0x0000 to 0x3fff)
  17:     -	0005'         	IOA_MMAP_1      equ 0x05        ; Page, supervisor and protection for bank 1 (0x4000 to 0x7fff)
  18:     -	0006'         	IOA_MMAP_2      equ 0x06        ; Page, supervisor and protection for bank 2 (0x8000 to 0xbfff)
  19:     -	0007'         	IOA_MMAP_3      equ 0x07        ; Page, supervisor and protection for bank 3 (0xc000 to 0xffff)
  20:				
  21:				; Interrupts
  22:				; Note: Up to eight interrupts are supported. IM 2 is anticipated, and the
  23:				; fixed vector associated with each interrupt is supplied when the interrupt
  24:				; is serviced. Routine address is “I*256+databus”. Vector supplied is
  25:				; 0xe0 + 2 * interrupt number (0 to 7).
  26:				; Note: addresses 0x09 and 0x0b reserved for use if more than eight interrupt
  27:				; sources are required.
  28:     -	0008'         	IOA_INT_EN      equ 0x08        ; Enables
  29:     -	000A'         	IOA_INT_PEND    equ 0x0a        ; Pending interrupts
  30:				;
  31:				;NMI
  32:     -	000C'         	IOA_NMI_REASONS equ 0x0c        ; NMI reasons flags
  33:				;
  34:				; Serial.
  35:     -	0010'         	IOA_SER1_CSR    equ 0x10        ; Port 1 control / status
  36:     -	0011'         	IOA_SER1_DATA   equ 0x11        ; Port 1 data
  37:     -	0012'         	IOA_SER2_CSR    equ 0x12        ; Port 2 serial control / status
  38:     -	0013'         	IOA_SER2_DATA   equ 0x13        ; Port 2 serial data
  39:				
  40:				; RTC (DS1672)
  41:				; I2C, implemented using a byte interface to the CPU. Writing to the data port
  42:				; shifts out a byte. Input puts are shifted into the “other end” of the same
  43:				; register.
  44:     -	0018'         	IOA_I2C_CSR     equ 0x18        ; Control
  45:     -	0019'         	IOA_I2C_DATA    equ 0x19        ; Data
  46:				;
  47:				; SD Card
  48:				; Uses SPI mode, with a generally similar interface to that of the I2C.
  49:     -	0020'         	IOA_SPI_CSR     equ 0x20        ; Control
  50:     -	0021'         	IOA_SPI_DATA    equ 0x21        ; Data
  51:				
  52:				; CRC16 / XMODEM and MultiMediaCard CRC16
  53:				; Write to the CRC register to set the initial value. Writing to the input
  54:				; data register updates the CRC.
  55:     -	0024'         	IOA_CRC_0       equ 0x24        ; CRC register (low)
  56:     -	0025'         	IOA_CRC_1       equ 0x25        ; CRC register (high)
  57:     -	0026'         	IOA_CRC_DATA    equ 0x26        ; Input data
  58:				
  59:				; *** Proposed features ***
  60:				; Video
  61:				;IOA_VID_CTRL    equ 0x30;       ; Control (cursor on/off ...)
  62:				;IOA_VID_DATA    equ 0x31;       ; Data
  63:				;IOA_VID_CUR_X   equ 0x32;       ; Cursor X (0 to 127)
  64:				;IOA_VID_CUR_Y   equ 0x33;       ; Cursor Y (0 to 63)
  65:				;IOA_VID_START_L equ 0x34        ; Display start address (low byte)
  66:				;IOA_VID_START_H equ 0x35        ; Display start address (high byte)
  67:				
  68:				; Video palette
  69:				; Each entry consists of 6 bits of colour data. Foreground and background
  70:				; colour pairs are selected from the above palette using eight of the 22
  71:				; control codes in the display character set. This leaves codes for
  72:				; double-height, double-width etc.
  73:				;IOA_VID_PALBG0  equ 0x40        ; Background colour 0
  74:				;IOA_VID_PALFG0  equ 0x41        ; Foreground colour 0
  75:				;IOA_VID_PALBG1  equ 0x42        ; Background colour 1
  76:				;IOA_VID_PALFG1  equ 0x43        ; Foreground colour 1
  77:				;IOA_VID_PALBG2  equ 0x44        ; Background colour 2
  78:				;IOA_VID_PALFG2  equ 0x45        ; Foreground colour 2
  79:				;IOA_VID_PALBG3  equ 0x46        ; Background colour 3
  80:				;IOA_VID_PALFG3  equ 0x47        ; Foreground colour 3
  81:				;IOA_VID_PALBG4  equ 0x48        ; Background colour 4
  82:				;IOA_VID_PALFG4  equ 0x49        ; Foreground colour 4
  83:				;IOA_VID_PALBG5  equ 0x4a        ; Background colour 5
  84:				;IOA_VID_PALFG5  equ 0x4b        ; Foreground colour 5
  85:				;IOA_VID_PALBG6  equ 0x4c        ; Background colour 6
  86:				;IOA_VID_PALFG6  equ 0x4d        ; Foreground colour 6
  87:				;IOA_VID_PALBG7  equ 0x4e        ; Background colour 7
  88:				;IOA_VID_PALFG7  equ 0x4f        ; Foreground colour 7
  89:				
  90:				; Arithmetic
  91:				; Multiply, divide … based on 68000 DIV, DIVU, MUL, MULU.
  92:				; Multiply does A[16] * B[16] => C[32].
  93:				; Divide does A[32] / B[16] => C[32] (16-bit remainder [high bits] and
  94:				; 16-bit quotient [low bits]).
  95:				; Status bits include “complete” and “overflow”.
  96:				;IOA_ARITH_A_L   equ 0x50        ; A register (low)
  97:				;IOA_ARITH_A_H   equ 0x51        ; A register (high)
  98:				;IOA_ARITH_B_L   equ 0x54        ; B register (low)
  99:				;IOA_ARITH_B_H   equ 0x57        ; B register (high)
 100:				;IOA_ARITH_C_0   equ 0x58        ; C register (low)
 101:				;IOA_ARITH_C_1   equ 0x59 
 102:				;IOA_ARITH_C_2   equ 0x5a
 103:				;IOA_ARITH_C_3   equ 0x5b        ; C register (high)
 104:				;IOA_ARITH_CSR   equ 0x5c        ; Command / status
 105:				
 106:				
 107:				; *** Register bits allocation ***
 108:				
 109:				; IOA_CONTROL register
 110:     -	        	BITDEF SYSCTRL_TRARM, 0         ; 1 arms the trace interrupt
 111:     -	        	BITDEF SYSCTRL_MMAP, 1          ; 1 enables memory mapping
 112:     -	        	BITDEF SYSCTRL_NMCLR, 2         ; NMI mapping clear
 113:     -	        	BITDEF SYSCTRL_MAPARM, 3        ; NMI out arm
 114:     -	        	BITDEF SYSCTRL_MMAPN, 4         ; State of MMAP when an NMI occurred
 115:     -	        	BITDEF SYSCTRL_TRPRE0, 5        ; Number of prefixes for trace
 116:     -	        	BITDEF SYSCTRL_TRPRE1, 6
 117:     -	        	BITDEF SYSCTRL_RESERVED, 7      ; Unused bit
 118:				;
 119:				; MMAP page registers
 120:     -	        	BITDEF MMAP_PROT, 7             ; Write protection
 121:     -	        	BITDEF MMAP_SUPER, 6            ; I/O enable
 122:     -	003F'         	MMAP_PAGE_MASK  equ 0x3f        ; RAM page number bits
 123:				;
 124:				; IOA_INT_EN and IOA_INT_PEND registers.
 125:     -	0008'         	INTS_NUM        equ 8           ; Number of possible interrupt sources
 126:     -	        	BITDEF INT_SER1_TX, 0           ; Serial port 1 transmitter buffer is half full or less
 127:     -	        	BITDEF INT_SER1_RX, 1           ; Serial port 1 receiver has data
 128:     -	        	BITDEF INT_SER2_TX, 2           ; Serial port 2 transmitter buffer is half full or less
 129:     -	        	BITDEF INT_SER2_RX, 3           ; Serial port 2 receiver has data
 130:     -	        	BITDEF INT_TICK, 4              ; Regular timekeeping
 131:				;
 132:				; IOA_NMI_REASONS register.
 133:     -	0004'         	NMI_REASONS_NUM equ 4           ; Number of reasons for an NMI
 134:     -	        	BITDEF NMI_SWITCH, 0;           ; Front panel switch
 135:     -	        	BITDEF NMI_PROT_VIOL, 1;        ; Write protection violation
 136:     -	        	BITDEF NMI_SUPER_VIOL, 2;       ; Supervisor violation
 137:     -	        	BITDEF NMI_TRACE, 3;            ; Debugger trace (single step)
 138:     -	000F'         	NMI_REASONS_ALL equ NMI_SWITCH_MASK + NMI_PROT_VIOL_MASK + NMI_SUPER_VIOL_MASK + NMI_TRACE_MASK
 139:				;
 140:				; Serial CSRs (IOA_SER1_CSR and IOA_SER2_CSR).
 141:     -	        	BITDEF SER_CSR_RX_EMPTY, 0      ; Receiver buffer is empty
 142:     -	        	BITDEF SER_CSR_RX_ALHALF, 1     ; Receiver buffer is at least half full
 143:     -	        	BITDEF SER_CSR_RX_FULL, 2       ; Receiver buffer is full
 144:     -	        	BITDEF SER_CSR_FRAME_ERR, 3     ; Framing error in last character
 145:     -	        	BITDEF SER_CSR_TX_EMPTY, 4      ; Transmitter buffer is empty
 146:     -	        	BITDEF SER_CSR_TX_ALHALF, 5     ; Transmitter buffer is at least half full
 147:     -	        	BITDEF SER_CSR_TX_FULL, 6       ; Transmitter buffer is full
 148:				; Bit 7 is not used.
 149:				;
 150:				; I2C (Inter-Integrated Circuit) master interface. Used for RTC (DS1672).
 151:				; Bits in IOA_I2C_CSR
 152:     -	        	BITDEF I2C_CSR_ACKN, 0          ; (Read / write) acknowledge from receiving device
 153:     -	        	BITDEF I2C_CSR_START, 1         ; (Write only) trigger start sequence
 154:     -	        	BITDEF I2C_CSR_STOP, 2          ; (Write only) trigger stop sequence
 155:     -	        	BITDEF I2C_CSR_BUSY, 7          ; (Read only) transceiver busy
 156:				;
 157:				; SPI (Serial Peripheral Interface) master interface. Used for memory card.
 158:				; Bits in IOA_SPI_CSR
 159:     -	        	BITDEF SPI_CSR_FAST, 0          ; (Read / write) SPI speed select
 160:     -	        	BITDEF SPI_CSR_MC_SS, 1         ; (Read / write) memory card slave select
 161:     -	        	BITDEF SPI_CSR_BUSY, 7          ; (Read only) transceiver busy
 162:				
**** monitor.z80 ****
  74:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** monitor.z80 ****
  75:				                include "io.i"          ; I/O routines
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io.i ****
   1:				; ***********************************
   2:				; * ZARC Basic I/O Extern Symbols   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and extern statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef io           ; Inhibit for this module
  16:				;
  17:				                ; Variables
  18:				                extern coport   ; Current console port (PRT_xxx)
  19:				                extern trport   ; Current data transfer port (PRT_xxx)
  20:				;
  21:				                ; Routines
  22:				                extern conwch   ; Write character to the console
  23:				                extern conrch   ; Read character from the console
  24:				                extern consta   ; Fetch console port status
  25:				                extern trawch   ; Write character to the data transfer port
  26:				                extern trarch   ; Read character from the data transfer port
  27:				                extern s1wch    ; Write character to serial port 1
  28:				                extern s1rch    ; Read character from serial port 1
  29:				                extern s1sta    ; Fetch serial port 1 status
  30:				                extern s2wch    ; Write character to serial port 2
  31:				                extern s2rch    ; Read character from serial port 2
  32:				                extern s2sta    ; Fetch serial port 2 status
  33:				                extern i2cwr    ; Write to I2C device
  34:				                extern i2crd    ; Read from I2C device
  35:				                extern spiini   ; Initialise SPI interface and set speed
  36:				                extern spiss    ; Set SPI slave select(s)
  37:				                extern spitr    ; Transfer byte to / from SPI device
  38:				;
  39:				                endif
  40:				            endif
  41:				;
  42:				;
  43:				; Port enumeration. Used for console and transfer port selection. Definitions must
  44:				; match names in prt_name_list (monitor.z80).
  45:     -	        	                ENUM_START
  46:     -	        	                ENUM PORT_SER1          ; Serial port 1
  47:     -	        	                ENUM PORT_SER2          ; Serial port 2
  48:     -	        	                ENUM_END PORT_STATES    ; Number of states
  49:				;
  50:				
**** monitor.z80 ****
  76:				                include "utility.i"     ; Utility functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//utility.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Utility Routines   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef utility      ; Inhibit for this module
  16:				;
  17:				                extern cwnwln       ; Write new line characters to console.
  18:				                extern conwms       ; Print null-terminated string to the console
  19:				                extern conwmn       ; Print message <n> in a list
  20:				                extern skpspc       ; Step hl past spaces
  21:				                extern toupca       ; Convert character in A to upper case
  22:				                extern toloca       ; Convert character in A to lower case
  23:				                extern cwvich       ; Print only visible 7-bit characters
  24:				                extern cwpspc       ; Print a space
  25:				                extern mtwdli       ; Match word in a string against list of options
  26:				                extern cwphnb       ; Print least-significant nibble in A in hexadecimal
  27:				                extern cwphby       ; Print A in hexadecimal
  28:				                extern cwphwd       ; Print HL in hexadecimal
  29:				                extern cwpdby       ; Print A in decimal. Leading zeros are suppressed
  30:				                extern cwpdwd       ; Print HL in decimal. Leading zeros are suppressed
  31:				                extern cwpdlo       ; Print DEHL in decimal. Leading zeros are suppressed
  32:				                extern rdhxwd       ; Read a 16-bit hexadecimal number from a string
  33:				                extern rdduwd       ; Read a 16-bit unsigned decimal number from a string
  34:				                extern rddulo       ; Read a 32-bit unsigned decimal number from a string
  35:				;
  36:				                endif
  37:				            endif
  38:				;
  39:				;
  40:				; mtwdli (match word in a string against list of options) option bits. Each bit
  41:				; has the described effect if set.
  42:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  43:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  44:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  45:				
**** monitor.z80 ****
  77:				                include "maths.i"       ; Mathematical functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for ZARC Z80 Computer         *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 29/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef maths        ; Inhibit for this module
  16:				;
  17:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  18:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  19:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  20:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  21:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  22:				                extern crc16x       ; Software CRC-16 (XMODEM)
  23:				;
  24:				                endif
  25:				            endif
  26:				
**** monitor.z80 ****
  78:				                include "time.i"        ; Routines associated with time
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//time.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Time Routines      *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				; The system keeps track of time as a Unix-style 32-bit number. Unlike Unix, this
   8:				; is treated as an unsigned integer and so will not suffer from the Year 2038 problem
   9:				; as it doubles the allowable postive time. It does, however, mean that it is not
  10:				; possible to represent dates before 1970.
  11:				
  12:				; Note that ld80 only considers the first six characters of labels significant.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef time         ; Inhibit for this module
  16:				;
  17:				                extern tird         ; Read current time and date
  18:				                extern tiwr         ; Set time and date
  19:				                extern tiitos       ; Convert integer time to structure
  20:				                extern tistoi       ; Convert structure time to integer
  21:				                extern cwptm        ; Print time structure to console
  22:				;
  23:				                endif
  24:				            endif
  25:				;
  26:				;
  27:     -	0046'         	TIM_EPOCH_YEAR  equ 70              ; Epoch year byte
  28:				;
  29:				; The following structure is used to store dates and times in human units. It is based
  30:				; on the Unix time.h tm structure.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BYTE TM_SECS    ; Seconds [0,59]
  33:     -	        	                STR_BYTE TM_MINS    ; Minutes [0,59]
  34:     -	        	                STR_BYTE TM_HOURS   ; Hours [0,23]
  35:     -	        	                STR_BYTE TM_MDAY    ; Day of month [1,31]
  36:     -	        	                STR_BYTE TM_MON     ; Month of year [1,12]
  37:     -	        	                STR_BYTE TM_YEAR    ; Years since 1900 [70,255]
  38:     -	        	                STR_BYTE TM_WDAY    ; Day of week [0,6] (Sunday = 0)
  39:     -	        	                STR_WORD TM_YDAY    ; Day of year [0,365]
  40:     -	        	                STR_BYTE TM_DST     ; Daylight savings status
  41:     -	        	                STR_END TM_SIZE
  42:				
  43:				; TM_DST can have any of the following values:
  44:     -	        	                ENUM_START
  45:     -	        	                ENUM TMDST_UNKNOWN
  46:     -	        	                ENUM TMDST_GMT      ; The time is GMT
  47:     -	        	                ENUM TMDST_DST      ; The time has DST applied (is one hour advanced)
  48:     -	        	                ENUM_END TMDST_NUM  ; Number of possible values
  49:				
**** monitor.z80 ****
  79:				                include "diags.i"       ; Diagnostics
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//diags.i ****
   1:				; ***************************************
   2:				; * ZARC Monitor Diagostics Routines    *
   3:				; * Written by: Merlin Skinner          *
   4:				; * Date Started: 3/8/2020              *
   5:				; ***************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef diags        ; Inhibit for this module
  16:				;
  17:				                extern cpuspd       ; Measure approximate CPU clock speed
  18:				                extern memtst       ; Test an area of memory with a range of patterns
  19:				                extern memtal       ; Test entire memory
  20:				;
  21:				                endif
  22:				            endif
  23:				
**** monitor.z80 ****
  80:				                include "spi.i"         ; SPI master interface
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//spi.i ****
   1:				; ***********************************
   2:				; * ZARC SPI Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 7/8/2020          *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with the SPI (Inter-Integrated Circuit) master interface.
   8:				; Used for the memory card initially, but it may turn out to have other uses.
   9:				;
  10:				;
  11:				; Memory card command structure
  12:     -	        	                STRUCT
  13:     -	        	                STR_BYTE MMC_CMD    ; Command including start bits
  14:     -	        	                STR_BYTE MMC_ARG1   ; Arguments
  15:     -	        	                STR_BYTE MMC_ARG2   ; Arguments
  16:     -	        	                STR_BYTE MMC_ARG3   ; Arguments
  17:     -	        	                STR_BYTE MMC_ARG4   ; Arguments
  18:     -	        	                STR_BYTE MMC_CRC    ; CRC and stop bit
  19:     -	        	                STR_END MMC_SIZE
  20:				
  21:				; SPI error codes. This should be maintained in sync with err_msgs in mmc_card.z80.
  22:     -	        	                ENUM_START
  23:     -	        	                ENUM SPI_ERR_OK         ; No error
  24:     -	        	                ENUM SPI_ERR_BUSY       ; Master interface stuck busy
  25:				; Memory card error codes.
  26:     -	        	                ENUM SPI_ERR_NORESP     ; No response received from card
  27:     -	        	                ENUM SPI_ERR_BADINIT    ; Initialisation failed
  28:     -	        	                ENUM SPI_ERR_BADCRC     ; CRC error
  29:     -	        	                ENUM SPI_ERR_BADSEC     ; Bad sector size
  30:     -	        	                ENUM SPI_ERR_RANGE      ; Parameter out of range
  31:     -	        	                ENUM SPI_ERR_DATAERR    ; Data error token received
  32:     -	        	                ENUM SPI_ERR_BAD_R1     ; Card reported error in R1 response
  33:     -	        	                ENUM SPI_ERR_BAD_R2     ; Card reported error in R2 response
  34:     -	        	                ENUM SPI_ERR_HEAP       ; Out of heap space
  35:     -	        	                ENUM SPI_ERR_TIMEOUT    ; Busy timeout
  36:     -	        	                ENUM SPI_ERR_WRITE      ; Write error
  37:     -	        	                ENUM SPI_ERR_UNKN       ; Unknown error
  38:     -	        	                ENUM_END SPI_ERR_NUM    ; Number of errors
**** monitor.z80 ****
  81:				                include "mmc.i"         ; Memory card
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//mmc.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Memory Card Include File   *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 7/8/2020                  *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef mmc          ; Inhibit for this module
  17:				; Functions
  18:				                extern mcinit       ; Initialise memory card
  19:				                extern mcprer       ; Print memory card error text
  20:				                extern mcrrs        ; Raw read sector
  21:				                extern mcrws        ; Raw write sector
  22:				; Variables
  23:				                extern mcstat       ; Card state (MC_STAT_xxx)
  24:				;
  25:				                endif
  26:				            endif
  27:				;
  28:				;
  29:     -	0200'         	MMC_SECTOR_SIZE             equ 512     ; Sector size
  30:     -	0009'         	MMC_LOG2_SEC_SIZE           equ 9       ; Save number of shifts for above
  31:     -	0040'         	MMC_CMD_START               equ 0x40    ; Command start bits (01b) shifted for
  32:				                                        ; command byte
  33:     -	0001'         	MMC_CMD_STOP                equ 0x01    ; Stop bit (in CRC byte)
  34:				;
  35:				;
  36:				; Card state (mcstat) states.
  37:     -	        	                ENUM_START
  38:     -	        	                ENUM MMC_STAT_IDLE      ; Not initialised
  39:     -	        	                ENUM MMC_STAT_INIT      ; Initialised (can do raw read / writes)
  40:				
  41:     -	        	                ENUM_END MC_STATES  ; Number of states
  42:				;
  43:				;
  44:				; Memory card command structure
  45:     -	        	                STRUCT
  46:     -	        	                STR_BYTE MMC_CMD    ; Command including start bits
  47:     -	        	                STR_BYTE MMC_ARG1   ; Arguments
  48:     -	        	                STR_BYTE MMC_ARG2   ; Arguments
  49:     -	        	                STR_BYTE MMC_ARG3   ; Arguments
  50:     -	        	                STR_BYTE MMC_ARG4   ; Arguments
  51:     -	        	                STR_BYTE MMC_CRC    ; CRC and stop bit
  52:     -	        	                STR_END MMC_SIZE
  53:				;
  54:				;
  55:				; SPI mode commands (CMDn from MMC-System-Spec-v3.31.pdf chapter 4.9).
  56:     -	0000'         	MMC_CMD_GO_IDLE_STATE       equ 0   ; Resets the memory card
  57:     -	0001'         	MMC_CMD_SEND_OP_COND        equ 1   ; Sends host capacity support information and init.
  58:     -	0009'         	MMC_CMD_SEND_CSD            equ 9   ; Read card specific data
  59:     -	000A'         	MMC_CMD_SEND_CID            equ 10  ; Read card identification
  60:     -	000D'         	MMC_CMD_SEND_STATUS         equ 13  ; Read card status register
  61:     -	0010'         	MMC_CMD_SET_BLOCKLEN        equ 16  ; Set block length (in bytes)
  62:     -	0011'         	MMC_CMD_READ_SINGLE_BLOCK   equ 17  ; Reads a block
  63:     -	0018'         	MMC_CMD_WRITE_BLOCK         equ 24  ; Writes a block
  64:     -	0037'         	MMC_CMD_APP_CMD             equ 55  ; Next command is an application specific command
  65:     -	003B'         	MMC_CMD_CRC_ON_OFF          equ 59  ; Turns the CRC option on or off
  66:				;
  67:				; The list describes all the application specific commands supported/reserved by the 
  68:				; memory card. All the following commands shall be preceded with APP_CMD (CMD55).
  69:     -	0029'         	MMC_ACMD_MC_SEND_OP_COND    equ 41  ; Sends host capacity support information and init
  70:				;
  71:				; R1 response bits
  72:     -	        	BITDEF MMC_R1_IDLE, 0           ; In idle state
  73:     -	        	BITDEF MMC_R1_ERA_RST, 1        ; Erase reset
  74:     -	        	BITDEF MMC_R1_ILL_CMD, 2        ; Illegal command
  75:     -	        	BITDEF MMC_R1_CMD_CRC_ERR, 3    ; Command CRC error
  76:     -	        	BITDEF MMC_R1_ERA_SEQ_ERR, 4    ; Erase sequence error
  77:     -	        	BITDEF MMC_R1_ADDR_ERR, 5       ; Address error
  78:     -	        	BITDEF MMC_R1_PAR_ERR, 6        ; Parameter error
  79:     -	        	BITDEF MMC_R1_START, 7          ; Zero identifies an R1 response
  80:				;
  81:				;
  82:     -	0006'         	MMC_CID_PNM_SIZE      equ 6   ; Product name length (bytes)
  83:				;
  84:				; Card IDentification (CID) register (128 bits)
  85:     -	        	                STRUCT
  86:     -	        	                STR_BYTE MMC_CID_MID    ; Manufacturer ID
  87:     -	        	                STR_WORD MMC_CID_OID    ; OEM/Application ID
  88:     -	        	                STR_BLOCK MMC_CID_PNM, MMC_CID_PNM_SIZE ; Product name
  89:     -	        	                STR_BYTE MMC_CID_PRV    ; Product revision
  90:     -	        	                STR_LONG MMC_CID_PSN    ; Product serial number
  91:     -	        	                STR_BYTE MMC_CID_MDT    ; Manufacturing date
  92:     -	        	                STR_BYTE MMC_CID_CRC    ; CRC7 checksum and "1"
  93:     -	        	                STR_END MMC_CID_SIZE
  94:				;
  95:				;
  96:				; Card-Specific Data (CSD) register (128 bits). It contains a number of bit fields
  97:				; that aren't necessarily byte aligned. In these cases, the entries simply identify
  98:				; the bit numbers contained.
  99:     -	        	                STRUCT
 100:     -	        	                STR_BYTE MMC_CSD_VERSION    ; (127-120) CSD version, spec version
 101:     -	        	                STR_BYTE MMC_CSD_TAAC       ; (119-112) data read access-time-1
 102:     -	        	                STR_BYTE MMC_CSD_NSAC       ; (111-104) data read access-time-2
 103:     -	        	                STR_BYTE MMC_CSD_TR_SPD     ; (103-96) max. data transfer rate
 104:     -	        	                STR_BYTE MMC_CSD_95_88      ; Card command classes (MS 8 bits)
 105:     -	        	                STR_BYTE MMC_CSD_87_80      ; CCC (LS bits) and max. read data length
 106:     -	        	                STR_BYTE MMC_CSD_79_72      ; Flags and C_SIZE bits 10 and 11
 107:     -	        	                STR_BYTE MMC_CSD_71_64      ; C_SIZE bits 2 to 9
 108:     -	        	                STR_BYTE MMC_CSD_63_56      ; C_SIZE bits 1 to 0 and some currents
 109:     -	        	                STR_BYTE MMC_CSD_55_48      ; Currents & C_SIZE_MULT (MS 2 bits)
 110:     -	        	                STR_BYTE MMC_CSD_47_40      ; C_SIZE_MULT (LS bit) and erase size (part)
 111:     -	        	                STR_BYTE MMC_CSD_39_32      ; Erase size (part) and WP group size
 112:     -	        	                STR_BYTE MMC_CSD_31_24      ; WP group enable, ECC and write parameters (part)
 113:     -	        	                STR_BYTE MMC_CSD_23_16      ; Write block lenth (part) and reserved
 114:     -	        	                STR_BYTE MMC_CSD_15_8       ; Flags
 115:     -	        	                STR_BYTE MMC_CSD_CRC        ; CRC7 checksum and "1"
 116:     -	        	                STR_END MMC_CSD_SIZE
 117:				
**** monitor.z80 ****
  82:				                include "disass.i"      ; Z80 disassembler
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//disass.i ****
   1:				; ***************************************
   2:				; * ZARC Monitor Disassembly Routines   *
   3:				; * Written by: Merlin Skinner          *
   4:				; * Date Started: 27/9/2020             *
   5:				; ***************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef disass   ; Inhibit for this module
  17:				;
  18:				                extern diproc   ; Disassemble an instruction to intermediate form
  19:				                extern diprnt   ; Print the result
  20:				;
  21:				                endif
  22:				            endif
  23:				;
  24:     -	0010'         	DIS_BUF_SIZE    equ 16          ; Length of intermediate disassembly buffer
  25:     -	0004'         	DIS_MAX_INSTLEN equ 4           ; Maximum length of instructions
  26:				; Note: invalid instructions may exceed this length.
**** monitor.z80 ****
  83:				                include "cpm.i"         ; CP/M support
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  17:     -	0001'         	                ifndef cpm          ; Inhibit for this module
  18:				; Constants
  19:				;
  20:				; Variables 
  21:				                extern cppags       ; CP/M page allocations
  22:				;
  23:				; Functions
  24:				                extern cpinit       ; Load and start CP/M
  25:				                extern cpmem        ; Allocate CP/M pages
  26:				;
  27:				                endif
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** monitor.z80 ****
  84:				                include "heap.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//heap.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Heap Incude File           *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 7/8/2020                  *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef heap         ; Inhibit for this module
  17:				;
  18:				                extern hinit        ; Initialise
  19:				                extern halloc       ; Allocate memory
  20:				;
  21:				                endif
  22:				            endif
  23:				
**** monitor.z80 ****
  85:				                include "cache.i"       ; MMC sector cache
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cache.i ****
   1:				; ***********************************************
   2:				; * ZARC Monitor Memory Card Cache Include File *
   3:				; * Written by: Merlin Skinner                  *
   4:				; * Date Started: 23/11/2020                    *
   5:				; ***********************************************
   6:				;
   7:				; Constants and structures associated with the MMC memory card sector cache.
   8:				;
   9:				; "Dirty" in this case indicates sector data that is in the cache, but has not yet
  10:				; been written to the MMC.
  11:				;
  12:				;
  13:				; The following conditionals are intended to allow the same include file to be
  14:				; used in the defining module and elsewhere as required. Some includes are used
  15:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  16:				; the extern and public statements are not desirable.
  17:				;
  18:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  19:     -	0001'         	                ifndef cache        ; Inhibit for this module
  20:				; Functions
  21:				                extern cacold       ; Reset cache (cold start)
  22:				                extern cawarm       ; Initialise cache (warm start)
  23:				                extern carpt        ; Report status
  24:				                extern caflus       ; Flush cache
  25:				                extern cars         ; Read sector
  26:				                extern caws         ; Write sector
  27:				                extern cacrs        ; Read CP/M sector
  28:				                extern cacws        ; Write CP/M sector
  29:				; Variables
  30:				; (None)
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:     -	0010'         	MCCA_BUFFERS                equ 16      ; Number of cached sector buffers
  36:     -	0008'         	MCCA_DIRT_THRES             equ MCCA_BUFFERS / 2    ; Target no. of dirty buffers
  37:				;
  38:				;
  39:				; Sector cache structure. This contains the data associated with a single cached
  40:				; sector.
  41:     -	        	                STRUCT
  42:     -	        	                STR_BYTE MCCAS_STATUS       ; Status byte
  43:     -	        	                STR_24BIT MCCAS_SECTOR      ; 24-bit sector number
  44:     -	        	                STR_WORD MCCAS_CSUM         ; Checksum of data
  45:     -	        	                STR_BLOCK MCCAS_DATA, MMC_SECTOR_SIZE   ; Cached data
  46:     -	        	                STR_END MCCAS_SIZE
  47:				;
  48:				; MCCAS_STATUS byte is defined as follows:
  49:				; Bits 0 to 3 - set if the corresponding CP/M sector in this MMC sector is dirty.
  50:     -	        	BITDEF MCCAS_STAT_CPM0, 0       ; CP/M sector 0 (0 to 0x7f)
  51:     -	        	BITDEF MCCAS_STAT_CPM1, 1       ; CP/M sector 1 (0x80 to 0x0ff)
  52:     -	        	BITDEF MCCAS_STAT_CPM2, 2       ; CP/M sector 2 (0x100 to 0x17f)
  53:     -	        	BITDEF MCCAS_STAT_CPM3, 3       ; CP/M sector 3 (0x180 to 0x1ff)
  54:     -	        	BITDEF MCCAS_STAT_VALID, 4      ; Buffer contains valid data
  55:				;
  56:     -	000F'         	MCCAS_STAT_DIRT_MASK    equ MCCAS_STAT_CPM0_MASK + MCCAS_STAT_CPM1_MASK + MCCAS_STAT_CPM2_MASK + MCCAS_STAT_CPM3_MASK
  57:				
**** monitor.z80 ****
  86:				                include "memory.i"      ; Memory page allocation
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//memory.i ****
   1:				; *******************************************
   2:				; * ZARC Memory Include File                *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 24/11/2021                *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef memory       ; Inhibit for this module
  17:				;
  18:				                extern mpinit       ; Initialise
  19:				                extern mprpt        ; Report status to console
  20:				                extern mpall        ; Allocate new page
  21:				                extern mpfree       ; Free allocated page
  22:				                extern mpstat       ; Allocation status
  23:				                extern mppnam       ; Print entry name
  24:				;
  25:				                endif
  26:				            endif
  27:				;
  28:				; Physical memory constants are found in zarc.i
  29:				;
  30:     -	0004'         	MPA_NAME_LEN        equ 4               ; Page owner name length (bytes)
  31:				;
  32:				; Memory map
  33:     -	4000'         	MMAP_PAGE_SIZE      equ 0x4000          ; Memory mapping bank / page size
  34:     -	0004'         	MMAP_BANKS          equ 4               ; Number of 16 kB banks
  35:     -	0040'         	MMAP_PAGES          equ 0x40            ; Number of 16 kB RAM pages
  36:     -	0000'         	MMAP_BANK0_START    equ 0x0000
  37:     -	3FFF'         	MMAP_BANK0_END      equ 0x3fff
  38:     -	4000'         	MMAP_BANK1_START    equ 0x4000
  39:     -	7FFF'         	MMAP_BANK1_END      equ 0x7fff
  40:     -	8000'         	MMAP_BANK2_START    equ 0x8000
  41:     -	BFFF'         	MMAP_BANK2_END      equ 0xbfff
  42:     -	C000'         	MMAP_BANK3_START    equ 0xc000
  43:     -	FFFF'         	MMAP_BANK3_END      equ 0xffff
  44:				;
  45:				;
  46:				;
  47:				; ****************
  48:				; * Memory Usage *
  49:				; ****************
  50:				;
  51:				;
  52:				; Memory banks setup.
  53:				; 0 (0000 - 3FFF): 3f read only, supervisor - monitor program
  54:				; 1 (4000 - 7FFF): 3e writeable - monitor variables, stacks, buffers etc.
  55:				; 2 (8000 - BFFF): (not used)
  56:				; 3 (C000 - FFFF): (mapped as required)
  57:				;
  58:     -	003F'         	MMAP_MON_B0_PAGE    equ 0x3f        ; Page for bank 0
  59:     -	003E'         	MMAP_MON_B1_PAGE    equ 0x3e        ; Page for bank 1
  60:				;
  61:     -	0040'         	STACKS_SIZE     equ 64              ; Space allocated to normal stacks
  62:				;
  63:     -	7FFF'         	HEAP_TOP        equ MMAP_BANK1_END  ; Top (end) of heap space.
  64:				
**** monitor.z80 ****
  87:				;
  88:				;
  89:				;
  90:				; *************
  91:				; * Externals *
  92:				; *************
  93:				;
  94:				; Routines
  95:				                public panic            ; System error exception
  96:				                public rusby            ; Read byte from user space
  97:				                public ruswd            ; Read 16-bit word from user space
  98:				                public wusby            ; Write byte to user space
  99:				                public wuswd            ; Write 16-bit word to user space
 100:				                extern prpnam           ; Print memory page name
 101:				;
 102:				; Variables
 103:				                public tikdiv           ; Tick divider
 104:				                public mscnt            ; Monitor start count
 105:				                public mcspd            ; Approximate CPU speed in KHz
 106:				                public mcrun            ; Switch context to user code
 107:				                public mdisrg           ; Display registers
 108:				                public mstate           ; Machine state structure
 109:				                public warm1            ; Warm start marker 1 
 110:				;
 111:				;
 112:				; *************
 113:				; * Constants *
 114:				; *************
 115:				;
 116:     -	0100'         	CMD_HIST_SIZE   equ 256                 ; Command history size
 117:     -	0050'         	CMD_BUF_SIZE    equ 80                  ; Command buffer length
 118:     -	0055'         	WARM_MAGIC_1    equ 0x55                ; Warm start magic numbers
 119:     -	00AA'         	WARM_MAGIC_2    equ 0xaa
 120:     -	0002'         	DIS_PRE_INSTRS  equ 2                   ; Number of instructions to show before PC
 121:     -	0002'         	DIS_POST_INSTRS equ 2                   ; Number of instructions to show after PC
 122:				;
 123:				; Exception types.
 124:     -	        	                ENUM_START
 125:     -	        	                ENUM XPTT_MON_ENT
 126:     -	        	                ENUM XPTT_RST08
 127:     -	        	                ENUM XPTT_RST10
 128:     -	        	                ENUM XPTT_RST18
 129:     -	        	                ENUM XPTT_RST20
 130:     -	        	                ENUM XPTT_RST28
 131:     -	        	                ENUM XPTT_RST30
 132:     -	        	                ENUM XPTT_RST38
 133:     -	        	                ENUM XPTT_NMI
 134:     -	        	                ENUM XPTT_PANIC
 135:     -	        	                ENUM_END XPTT_CNT       ; Number of types
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Main Code *
 141:				; *************
 142:				;
 143:				                cseg                    ; Code segment
 144:				;
 145:				; Linker -P option sets start address (0x0000). Do not attempt to write to RAM
 146:				; until the memory mapping has been set up.
 147:    0+4	0000' F3      	reset           di
 148:    4+7	0001' 0EFF    	                ld c, 0xff
 149:   11+10	0003' C3F600  	                jp init
 150:				;
 151:				; Make space to allow RST and interrupt vectors to be inserted if we are running
 152:				; at 0x0000.
 153:     -	0006'         	                defs 0x63               ; Skip to end of NMI vector allowing for a jump
 154:				;
 155:				; Functions made externally available have fixed entry points in the same manner
 156:				; CP/M uses. This allows changes to the monitor without having to recompile
 157:				; other modules.
 158:				; The jump vector table begins at NMI vector plus space for a jump instruction.
 159:				; Entries here must match the jump table in monitor.i.
 160:     -	0001'         	                assert ($ - reset) = (Z80_NMI_VEC + 3)  ; Verify start
 161:				; From monitor.z80
 162:   21+10	0069' C35604  	                jp mon_entry    ; Normal monitor entry
 163:   31+10	006C' C3DB04  	                jp panic        ; System error monitor entry
 164:				; From io.z80
 165:   41+10	006F' C30000  	                jp conwch       ; Write character to the console
 166:   51+10	0072' C30000  	                jp conrch       ; Read character from the console
 167:   61+10	0075' C30000  	                jp consta       ; Fetch console port status
 168:   71+10	0078' C30000  	                jp s1wch        ; Write character to serial port 1
 169:   81+10	007B' C30000  	                jp s1rch        ; Read character from serial port 1
 170:   91+10	007E' C30000  	                jp s1sta        ; Fetch serial port 1 status
 171:  101+10	0081' C30000  	                jp s2wch        ; Write character to serial port 2
 172:  111+10	0084' C30000  	                jp s2rch        ; Read character from serial port 2
 173:  121+10	0087' C30000  	                jp s2sta        ; Fetch serial port 2 status
 174:				; From utility.z80
 175:  131+10	008A' C30000  	                jp cwnwln       ; Write new line characters to console
 176:  141+10	008D' C30000  	                jp conwms       ; Print null-terminated string to the console
 177:  151+10	0090' C30000  	                jp conwmn       ; Print message <n> in a list
 178:  161+10	0093' C30000  	                jp skpspc       ; Step hl past spaces
 179:  171+10	0096' C30000  	                jp toupca       ; Convert character in A to upper case
 180:  181+10	0099' C30000  	                jp toloca       ; Convert character in A to lower case
 181:  191+10	009C' C30000  	                jp cwvich       ; Print only visible 7-bit characters
 182:  201+10	009F' C30000  	                jp cwpspc       ; Print a space
 183:  211+10	00A2' C30000  	                jp mtwdli       ; Match word in a string against list of options
 184:  221+10	00A5' C30000  	                jp cwphnb       ; Print least-significant nibble in A in hexadecimal
 185:  231+10	00A8' C30000  	                jp cwphby       ; Print A in hexadecimal
 186:  241+10	00AB' C30000  	                jp cwphwd       ; Print HL in hexadecimal
 187:  251+10	00AE' C30000  	                jp cwpdby       ; Print A in decimal. Leading zeros are suppressed.
 188:  261+10	00B1' C30000  	                jp cwpdwd       ; Print HL in decimal. Leading zeros are suppressed.
 189:  271+10	00B4' C30000  	                jp cwpdlo       ; Print DEHL in decimal. Leading zeros are suppressed
 190:  281+10	00B7' C30000  	                jp rdhxwd       ; Read a 16-bit hexadecimal number from a string
 191:  291+10	00BA' C30000  	                jp rdduwd       ; Read a 16-bit unsigned decimal number from a string
 192:  301+10	00BD' C30000  	                jp rddulo       ; Read a 32-bit unsigned decimal number from a string
 193:				; From maths.z80
 194:  311+10	00C0' C30000  	                jp madlbu       ; 32-bit / 8-bit unsigned divide
 195:  321+10	00C3' C30000  	                jp madwbu       ; 16-bit / 8-bit unsigned divide
 196:  331+10	00C6' C30000  	                jp madbbu       ; 8-bit / 8-bit unsigned divide
 197:  341+10	00C9' C30000  	                jp mamwwu       ; 16-bit * 16-bit unsigned multiply
 198:  351+10	00CC' C30000  	                jp mamlbu       ; 32-bit * 8-bit unsigned multiply
 199:  361+10	00CF' C30000  	                jp crc16x       ; Software CRC-16 (XMODEM)
 200:				; From time.z80
 201:  371+10	00D2' C30000  	                jp tird         ; Read current time and date
 202:  381+10	00D5' C30000  	                jp tiwr         ; Set time and date
 203:  391+10	00D8' C30000  	                jp tiitos       ; Convert integer time to structure
 204:  401+10	00DB' C30000  	                jp tistoi       ; Convert structure time to integer
 205:  411+10	00DE' C30000  	                jp cwptm        ; Print time structure to console
 206:				; From mmc.z80
 207:  421+10	00E1' C30000  	                jp mcprer       ; Print memory card error text
 208:				; From cache.z80
 209:  431+10	00E4' C30000  	                jp cacrs        ; CP/M read sector
 210:  441+10	00E7' C30000  	                jp cacws        ; CP/M write sector
 211:  451+10	00EA' C30000  	                jp caflus       ; Flush cache (write dirty buffers)
 212:				; From memory.z80
 213:  461+10	00ED' C30000  	                jp mpall        ; Allocate new page
 214:  471+10	00F0' C30000  	                jp mpfree       ; Free allocated page
 215:  481+10	00F3' C30000  	                jp mpstat       ; Allocation status
 216:				;
 217:     -	0001'         	                assert ($ - reset) = MCALL_JPTBL_NEXT   ; Verify end
 218:				;
 219:				; Go here from reset or after an exception.
 220:				; C - 0xff if we are here due to a reset.
 221:  491+4	00F6' F3      	init            di                      ; Required if coming from exception handler
 222:				;
 223:				; Set initial memory map. Page 0 is made writeable initially to allow vectors to be
 224:				; initialised. Set unused banks to arbitrary values so the FPGA shadow registers
 225:				; reflect the real bank registers.
 226:				; Note - can't call mmap_page0_rw here as we have no writeable stack yet.
 227:				;
 228:				; Set bank 0 (0x0000 to 0x3fff) writeable with I/O access.
 229:  495+7	00F7' 3E7F    	                ld a, MMAP_MON_B0_PAGE + MMAP_SUPER_MASK
 230:  502+11	00F9' D304    	                out (IOA_MMAP_0), a
 231:				; Bank 1 (0x4000 to 0x7fff) writeable.
 232:  513+7	00FB' 3E3E    	                ld a, MMAP_MON_B1_PAGE
 233:  520+11	00FD' D305    	                out (IOA_MMAP_1), a
 234:				; Banks 2 and 3 are mapped later as required.
 235:				;
 236:				; Enable memory mapping so we can write.
 237:  531+7	00FF' 3E02    	                ld a, SYSCTRL_MMAP_MASK
 238:  538+11	0101' D302    	                out (IOA_CONTROL), a
 239:				;
 240:				; Set rst_flag appropriately now we can write.
 241:  549+4	0103' 79      	                ld a, c
 242:  553+13	0104' 325F00  	                ld (rst_flag), a        ; Flag reset (or RST 00)
 243:				;
 244:  566+10	0107' 31C501  	                ld sp, mon_stack_p1     ; Setup stack
 245:				; IX is pre-loaded with the base address of the machine state structure as so
 246:				; much code uses it.
 247:  576+14	010A' DD216501	                ld ix, mstate           ; Machine state structure
 248:				;
 249:				; Write vectors to locations in the monitor. These may be overwitten as required.
 250:				; RST 0 already points to the initialisation code.
 251:  590+7	010E' 3E08    	                ld a, 0x08
 252:  597+10	0110' 116804  	                ld de, default_rst08    ; Point to default handler
 253:  607+17	0113' CD3404  	                call utrivc
 254:  624+10+7	0116' DCDB04  	                call c, panic           ; Panic on error
 255:				;
 256:  634+7	0119' 3E10    	                ld a, 0x10
 257:  641+10	011B' 117504  	                ld de, default_rst10    ; Point to default handler
 258:  651+17	011E' CD3404  	                call utrivc
 259:  668+10+7	0121' DCDB04  	                call c, panic           ; Panic on error
 260:				;
 261:  678+7	0124' 3E18    	                ld a, 0x18
 262:  685+10	0126' 118704  	                ld de, default_rst18    ; Point to default handler
 263:  695+17	0129' CD3404  	                call utrivc
 264:  712+10+7	012C' DCDB04  	                call c, panic           ; Panic on error
 265:				;
 266:  722+7	012F' 3E20    	                ld a, 0x20
 267:  729+10	0131' 119804  	                ld de, default_rst20    ; Point to default handler
 268:  739+17	0134' CD3404  	                call utrivc
 269:  756+10+7	0137' DCDB04  	                call c, panic           ; Panic on error
 270:				;
 271:  766+7	013A' 3E28    	                ld a, 0x28
 272:  773+10	013C' 11A804  	                ld de, default_rst28    ; Point to default handler
 273:  783+17	013F' CD3404  	                call utrivc
 274:  800+10+7	0142' DCDB04  	                call c, panic           ; Panic on error
 275:				;
 276:  810+7	0145' 3E30    	                ld a, 0x30
 277:  817+10	0147' 11B904  	                ld de, default_rst30    ; Point to default handler
 278:  827+17	014A' CD3404  	                call utrivc
 279:  844+10+7	014D' DCDB04  	                call c, panic           ; Panic on error
 280:				;
 281:  854+7	0150' 3E38    	                ld a, 0x38
 282:  861+10	0152' 11CA04  	                ld de, default_rst38    ; Point to default handler
 283:  871+17	0155' CD3404  	                call utrivc
 284:  888+10+7	0158' DCDB04  	                call c, panic           ; Panic on error
 285:				;
 286:				; NMI vector
 287:  898+10	015B' 11EC04  	                ld de, default_nmi      ; Point to default handler
 288:  908+10	015E' 216600  	                ld hl, Z80_NMI_VEC
 289:  918+10	0161' 36C3    	                ld (hl), 0xc3           ; Jump instruction
 290:  928+6	0163' 23      	                inc hl
 291:  934+7	0164' 73      	                ld (hl), e              ; LS byte of address
 292:  941+6	0165' 23      	                inc hl
 293:  947+7	0166' 72      	                ld (hl), d              ; MS byte of address
 294:				;
 295:  954+7	0167' 3E0F    	                ld a, NMI_REASONS_ALL
 296:  961+11	0169' D30C    	                out (IOA_NMI_REASONS)   ; Discard any pending NMI reasons
 297:				;
 298:  972+17	016B' CD5104  	                call mmap_page0_ro      ; Set page 0 to read only
 299:				;
 300:  989+17	016E' CD6107  	                call con_init_basic     ; Initialise console I/O in basic mode
 301:				;
 302: 1006+17	0171' CD0000  	                call cpuspd             ; Measure approximate CPU clock speed
 303: 1023+20	0174' ED435600	                ld (mcspd), bc          ; Approximate CPU speed in KHz
 304:				;
 305:				; Is this a cold or warm start? Markers are placed at the beginning and the
 306:				; end of the variables area. If these are set appropriately, we must have run
 307:				; before so this is a warm start.
 308: 1043+13	0178' 3A0000  	                ld a, (warm1)
 309: 1056+7	017B' FE55    	                cp WARM_MAGIC_1
 310: 1063+7+5	017D' 2009    	                jr nz, init_cold
 311: 1070+13	017F' 3AC501  	                ld a, (warm2)
 312: 1083+7	0182' FEAA    	                cp WARM_MAGIC_2
 313: 1090+7+5	0184' 2002    	                jr nz, init_cold
 314: 1097+12	0186' 1855    	                jr init_warm            ; Do warm start
 315:				;
 316:				; Cold start initialisation.
 317:				; Use the default monitor stack location.
 318: 1109+10	0188' 210000  	init_cold       ld hl, 0
 319: 1119+16	018B' 220100  	                ld (mscnt), hl    ; Reset reset counter
 320:				; Initialise user registers.
 321: 1135+10	018E' 216501  	                ld hl, mstate
 322: 1145+7	0191' 0620    	                ld b, MST_SIZE
 323: 1152+4	0193' AF      	                xor a
 324: 1156+7	0194' 77      	ic_zero_lp      ld (hl), a
 325: 1163+6	0195' 23      	                inc hl
 326: 1169+8+5	0196' 10FC    	                djnz ic_zero_lp
 327:				;
 328:				; Set default memory mapping (CP/M map), albeit without I/O access (SUPER bit).
 329: 1177+19	0198' DD360101	                ld (ix + MST_MMAP_EN), 1    ; Memory mapping enabled
 330: 1196+19	019C' DD360200	                ld (ix + MST_MMAP0), 0
 331: 1215+19	01A0' DD360301	                ld (ix + MST_MMAP1), 1
 332: 1234+19	01A4' DD360402	                ld (ix + MST_MMAP2), 2
 333: 1253+19	01A8' DD360503	                ld (ix + MST_MMAP3), 3
 334:				;
 335:				; Initialise the command history. Fill the buffer with end of string characters.
 336: 1272+10	01AC' 216100  	                ld hl, cmd_history
 337: 1282+10	01AF' 116200  	                ld de, cmd_history + 1
 338: 1292+10	01B2' 3600    	                ld (hl), 0
 339: 1302+10	01B4' 01FF00  	                ld bc, CMD_HIST_SIZE - 1
 340: 1312+16+5	01B7' EDB0    	                ldir
 341: 1328+10	01B9' 216100  	                ld hl, cmd_history
 342: 1338+16	01BC' 226101  	                ld (cmd_hist_iptr), hl  ; Set pointer to start of buffer
 343:				;
 344: 1354+7	01BF' 3E00    	                ld a, PORT_SER1         ; Serial port 1
 345: 1361+13	01C1' 320000  	                ld (coport), a          ; Set default console port
 346: 1374+13	01C4' 320000  	                ld (trport), a          ; Set default data transfer port
 347:				;
 348:				; Set warm start markers
 349: 1387+7	01C7' 3E55    	                ld a, WARM_MAGIC_1
 350: 1394+13	01C9' 320000  	                ld (warm1), a
 351: 1407+7	01CC' 3EAA    	                ld a, WARM_MAGIC_2
 352: 1414+13	01CE' 32C501  	                ld (warm2), a
 353:				;
 354: 1427+10	01D1' 213608  	                ld hl, cold_start_msg   ; Announce cold start
 355: 1437+17	01D4' CD0000  	                call conwms             ; Print message
 356:				;
 357: 1454+17	01D7' CD0000  	                call cacold             ; Reset memory card cache (cold start)
 358: 1471+17	01DA' CD0000  	                call mpinit             ; Initialise page map
 359:				;
 360:				; Warm start (may be after cold start code).
 361:				; Increment the restart counter. This includes resets and exceptions
 362:				; that cause the monitor to be entered.
 363: 1488+10	01DD' 210100  	init_warm       ld hl, mscnt            ; Monitor start count
 364: 1498+11	01E0' 34      	                inc (hl)
 365: 1509+7+5	01E1' 2007    	                jr nz, init_signon
 366: 1516+6	01E3' 23      	                inc hl
 367: 1522+11	01E4' 34      	                inc (hl)
 368:				;
 369:				; For the time being at least, force the console to serial port 1 on any reset,
 370:				; not just cold starts. This helps to avoid loss of control of the system.
 371: 1533+7	01E5' 3E00    	                ld a, PORT_SER1         ; Serial port 1
 372: 1540+13	01E7' 320000  	                ld (coport), a          ; Set default console port
 373:				;
 374:				; Sign on
 375: 1553+17	01EA' CD0000  	init_signon     call cwnwln             ; Write new line characters to console
 376: 1570+17	01ED' CD0000  	                call cwnwln
 377:				;
 378: 1587+13	01F0' 3A5F00  	                ld a, (rst_flag)
 379: 1600+4	01F3' A7      	                and a
 380: 1604+7+5	01F4' 2806    	                jr z, init_skip_ban     ; Skip banner if not a reset
 381:				;
 382:				; Display banner message.
 383: 1611+10	01F6' 21BF07  	                ld hl, zarc_msg
 384: 1621+17	01F9' CD0000  	                call conwms             ; Print message
 385:				;
 386:				; Display normal sign-on.
 387: 1638+10	01FC' 212208  	init_skip_ban   ld hl, signon_msg
 388: 1648+17	01FF' CD0000  	                call conwms             ; Print message
 389:				;
 390: 1665+13	0202' 3A5F00  	                ld a, (rst_flag)
 391: 1678+4	0205' A7      	                and a
 392: 1682+7+5	0206' 281B    	                jr z, get_cmd           ; Skip if not a reset
 393:				;
 394:				; Additional processing if we are here due to a reset.
 395:				;
 396:				; Set unused banks to arbitrary values so the FPGA shadow registers reflect the
 397:				; real bank register.
 398: 1689+7	0208' 3E80    	                ld a, 0x00 + MMAP_PROT_MASK
 399: 1696+11	020A' D306    	                out (IOA_MMAP_2), a
 400: 1707+11	020C' D307    	                out (IOA_MMAP_3), a
 401:				; Initialise heap.
 402: 1718+17	020E' CD0000  	                call hinit
 403:				;
 404:				; Set memory card to idle (not initialised).
 405: 1735+7	0211' 3E00    	init_ints_ok    ld a, MMC_STAT_IDLE
 406: 1742+13	0213' 320000  	                ld (mcstat), a
 407:				; Attempt to initialise it.
 408: 1755+17	0216' CD0000  	                call mcinit
 409: 1772+4	0219' A7      	                and a
 410:				; Print error text if there is an error.
 411: 1776+10+7	021A' C40000  	                call nz, mcprer         ; Print memory card error text
 412:				;
 413: 1786+17	021D' CD0000  	                call cawarm             ; Initialise cache (warm start)
 414: 1803+17	0220' CD0000  	                call caflus             ; Flush cache (write dirty buffers)
 415:				;
 416:				; Command loop
 417: 1820+10	0223' 31C501  	get_cmd         ld sp, mon_stack_p1     ; Reset stack
 418: 1830+10	0226' 214B08  	                ld hl, cmd_prompt       ; Display prompt
 419: 1840+17	0229' CD0000  	                call conwms             ; Print message
 420:				; Initialise the history buffer output pointer.
 421: 1857+16	022C' 2A6101  	                ld hl, (cmd_hist_iptr)
 422: 1873+17	022F' CD5103  	                call hist_val_ptr       ; Make sure it is valid
 423: 1890+16	0232' 226301  	                ld (cmd_hist_optr), hl  ; Reset history recall pointer
 424:				; Initialise start and length.
 425: 1906+10	0235' 210300  	                ld hl, cmd_buf          ; Point to start of buffer
 426: 1916+4	0238' AF      	                xor a                   ; Clear length
 427: 1920+13	0239' 325300  	                ld (cmd_len), a
 428:				; Character loop
 429: 1933+17	023C' CD0000  	gc_loop         call conrch             ; Fetch next character from user
 430:				; Process command on CR.
 431: 1950+7	023F' FE0D    	                cp ascii_cr
 432: 1957+10	0241' CA2303  	                jp z, gc_cr
 433:				; DEL or BS deletes the last character.
 434: 1967+7	0244' FE7F    	                cp ascii_del
 435: 1974+7+5	0246' 2828    	                jr z, gc_delete
 436: 1981+7	0248' FE08    	                cp ascii_bs
 437: 1988+7+5	024A' 2824    	                jr z, gc_delete
 438: 1995+7	024C' FE10    	                cp 'P' - 0x40           ; ^P (as most Linux / Unix shells)
 439: 2002+7+5	024E' 2825    	                jr z, gc_prev
 440: 2009+7	0250' FE0E    	                cp 'N' - 0x40           ; ^N (as most Linux / Unix shells)
 441: 2016+7+5	0252' 2846    	                jr z, gc_next
 442: 2023+7	0254' FE20    	                cp 0x20
 443: 2030+7+5	0256' 38E4    	                jr c, gc_loop           ; Ignore all other control characters
 444: 2037+8	0258' CB7F    	                bit 7, a
 445: 2045+7+5	025A' 20E0    	                jr nz, gc_loop          ; Ignore any 8-bit character (non-printable)
 446:				; This is a printable character.
 447: 2052+4	025C' 47      	                ld b,a                  ; Save character
 448: 2056+13	025D' 3A5300  	                ld a, (cmd_len)
 449: 2069+4	0260' 3C      	                inc a                   ; Allow space for terminator
 450: 2073+7	0261' FE50    	                cp CMD_BUF_SIZE
 451: 2080+7+5	0263' 30D7    	                jr nc, gc_loop          ; Ignore if no space
 452: 2087+13	0265' 325300  	                ld (cmd_len), a         ; Store updated length
 453: 2100+4	0268' 78      	                ld a, b                 ; Restore character
 454: 2104+7	0269' 77      	                ld (hl), a              ; Store in buffer
 455: 2111+6	026A' 23      	                inc hl
 456: 2117+17	026B' CD0000  	                call conwch             ; Echo it
 457: 2134+12	026E' 18CC    	                jr gc_loop
 458:				;
 459:				; Delete the last character.
 460: 2146+17	0270' CD0B03  	gc_delete       call gc_do_del          ; Delete a character if there is one
 461: 2163+12	0273' 18C7    	                jr gc_loop
 462:				;
 463:				; Recall the previous command from the history. cmd_hist_optr is initially set to
 464:				; cmd_hist_iptr, so points to the location after the terminator of the previous
 465:				; command.
 466: 2175+11	0275' E5      	gc_prev         push hl                 ; Save command buffer pointer
 467: 2186+16	0276' 2A6301  	                ld hl, (cmd_hist_optr)  ; History recall pointer
 468: 2202+6	0279' 2B      	                dec hl                  ; Point to terminator of last command
 469: 2208+17	027A' CD5103  	                call hist_val_ptr       ; Validate pointer
 470: 2225+17	027D' CDF702  	                call gc_check_end
 471: 2242+7+5	0280' 2815    	                jr z, gcp_abort         ; Exit if pointers match
 472: 2249+7	0282' 0E00    	                ld c, 0                 ; Count length
 473:				; Scan backwards, looking for the terminator at the end of the command before the
 474:				; one we want.
 475: 2256+6	0284' 2B      	gcp_findprev    dec hl
 476: 2262+17	0285' CD5103  	                call hist_val_ptr       ; Validate pointer
 477: 2279+17	0288' CDF702  	                call gc_check_end
 478: 2296+7+5	028B' 280A    	                jr z, gcp_abort         ; Exit if pointers match
 479: 2303+4	028D' AF      	                xor a
 480: 2307+7	028E' BE      	                cp (hl)
 481: 2314+7+5	028F' 2803    	                jr z, gcp_fnd_term      ; Terminator found
 482: 2321+4	0291' 0C      	                inc c                   ; Count non-terminator characters
 483:				; Commands can't be longer than CMD_BUF_SIZE, so C shouldn't overflow.
 484: 2325+12	0292' 18F0    	                jr gcp_findprev
 485:				; Terminator found
 486: 2337+4	0294' B9      	gcp_fnd_term    cp c
 487: 2341+7+5	0295' 2035    	                jr nz, cmd_recall
 488:				; No previous command to recall.
 489: 2348+10	0297' E1      	gcp_abort       pop hl
 490: 2358+12	0298' 18A2    	                jr gc_loop              ; Ignore the ^P
 491:				;
 492:				; Recall the next command from the history. This is only useful if a "previous"
 493:				; operation has been performed prior to this.
 494: 2370+11	029A' E5      	gc_next         push hl                 ; Save command buffer pointer
 495: 2381+16	029B' 2A6301  	                ld hl, (cmd_hist_optr)  ; History recall pointer
 496:				; Scan forwards, looking for the terminator at the end of the command.
 497: 2397+17	029E' CDF702  	gcn_findnext    call gc_check_end
 498: 2414+7+5	02A1' 2819    	                jr z, gcn_abort         ; Exit if pointers match
 499: 2421+4	02A3' AF      	                xor a
 500: 2425+7	02A4' BE      	                cp (hl)
 501: 2432+7+5	02A5' 2806    	                jr z, gcn_fnd_term      ; Terminator found
 502: 2439+6	02A7' 23      	                inc hl
 503: 2445+17	02A8' CD5103  	                call hist_val_ptr       ; Validate pointer
 504: 2462+12	02AB' 18F1    	                jr gcn_findnext
 505:				; Terminator found. We need to make sure this isn't the terminator associated with
 506:				; the last string in the buffer.
 507: 2474+4	02AD' 54      	gcn_fnd_term    ld d, h                 ; Save the address
 508: 2478+4	02AE' 5D      	                ld e, l
 509: 2482+6	02AF' 23      	                inc hl
 510: 2488+17	02B0' CD5103  	                call hist_val_ptr       ; Validate pointer
 511:				; Now HL points to the first character of the candidate command.
 512: 2505+17	02B3' CDF702  	                call gc_check_end
 513: 2522+7+5	02B6' 2804    	                jr z, gcn_abort
 514:				; A command follows.
 515: 2529+4	02B8' 62      	                ld h, d                 ; Restore the address
 516: 2533+4	02B9' 6B      	                ld l, e
 517: 2537+12	02BA' 1810    	                jr cmd_recall
 518:				; If we encountered the end of the buffer, there is no next command to recall.
 519:				; Set pointer to indicate that we are at the end of the buffer.
 520: 2549+16	02BC' 2A6101  	gcn_abort       ld hl, (cmd_hist_iptr)
 521: 2565+17	02BF' CD5103  	                call hist_val_ptr       ; Validate pointer
 522: 2582+16	02C2' 226301  	                ld (cmd_hist_optr), hl  ; Update recall pointer for next ^P or ^N
 523: 2598+10	02C5' E1      	                pop hl
 524:				; Clear the command.
 525: 2608+17	02C6' CD0103  	                call gc_del_cmd
 526: 2625+10	02C9' C33C02  	                jp gc_loop              ; Ignore the ^P
 527:				;
 528:				; We have found a valid command we want to recall. Delete any current command.
 529:				; HL - pointer to terminator at the end of the command before the one we want.
 530: 2635+4	02CC' EB      	cmd_recall      ex de, hl               ; Save history buffer pointer in DE
 531: 2639+10	02CD' E1      	                pop hl                  ; Restore saved command buffer pointer
 532:				; The command buffer pointer in HL is updated, but discarded later on. The real
 533:				; objective here is to delete the command on screen.
 534: 2649+17	02CE' CD0103  	                call gc_del_cmd         ; Delete entire command
 535:				;
 536:				;  Copy the new command to the command buffer. The terminator is not copied.
 537: 2666+4	02D1' EB      	gcp_copy        ex de, hl               ; Move history pointer back to HL
 538: 2670+10	02D2' 110300  	                ld de, cmd_buf          ; Point to start of command buffer
 539: 2680+6	02D5' 23      	                inc hl                  ; Step past previous terminator
 540: 2686+17	02D6' CD5103  	                call hist_val_ptr       ; Validate pointer
 541: 2703+16	02D9' 226301  	                ld (cmd_hist_optr), hl  ; Update recall pointer for next ^P or ^N
 542: 2719+7	02DC' 0E00    	                ld c, 0
 543:				; C - counter
 544:				; DE - pointer to command buffer
 545:				; HL - pointer to history buffer
 546: 2726+4	02DE' AF      	gcp_copy_loop   xor a
 547: 2730+7	02DF' BE      	                cp (hl)
 548: 2737+7+5	02E0' 280D    	                jr z, gcp_copy_done     ; Jump if terminator found
 549: 2744+7	02E2' 7E      	                ld a, (hl)
 550: 2751+7	02E3' 12      	                ld (de), a
 551: 2758+17	02E4' CD0000  	                call conwch             ; Display character
 552: 2775+4	02E7' 0C      	                inc c
 553: 2779+6	02E8' 13      	                inc de
 554: 2785+6	02E9' 23      	                inc hl
 555: 2791+17	02EA' CD5103  	                call hist_val_ptr       ; Validate pointer
 556: 2808+12	02ED' 18EF    	                jr gcp_copy_loop
 557:				;
 558: 2820+4	02EF' EB      	gcp_copy_done   ex de, hl               ; Set HL to command buffer address
 559: 2824+4	02F0' 79      	                ld a, c
 560: 2828+13	02F1' 325300  	                ld (cmd_len), a         ; Store new command length
 561:				; HL and cmd_len are now set to reflect the recalled command.
 562: 2841+10	02F4' C33C02  	                jp gc_loop              ; Fetch next character
 563:				;
 564:				; Check HL against cmd_hist_iptr. If there is a match, we have met the end of the
 565:				; data in the buffer. Call with:
 566:				; HL - pointer
 567:				; Returns with:
 568:				; Z flag set if pointers match, reset otherwise.
 569: 2851+13	02F7' 3A6101  	gc_check_end    ld a, (cmd_hist_iptr)
 570: 2864+4	02FA' BD      	                cp l                    ; Compare low byte
 571: 2868+5+6	02FB' C0      	                ret nz
 572: 2873+13	02FC' 3A6201  	                ld a, (cmd_hist_iptr + 1)
 573: 2886+4	02FF' BC      	                cp h                    ; Compare high byte
 574: 2890+10	0300' C9      	                ret
 575:				;
 576:				; Delete entire command.
 577:				; Call with:
 578:				; HL - pointer to location in command buffer.
 579:				; Returns with:
 580:				; HL - updated pointer (start of command buffer).
 581: 2900+13	0301' 3A5300  	gc_del_cmd      ld a, (cmd_len)
 582: 2913+4	0304' A7      	                and a
 583: 2917+5+6	0305' C8      	                ret z                   ; Exit if buffer is empty
 584: 2922+17	0306' CD0B03  	                call gc_do_del
 585: 2939+12	0309' 18F6    	                jr gc_del_cmd
 586:				;
 587:				; Delete a character from the command buffer.
 588: 2951+13	030B' 3A5300  	gc_do_del       ld a, (cmd_len)
 589: 2964+4	030E' A7      	                and a
 590: 2968+5+6	030F' C8      	                ret z                   ; Ignore if buffer is empty
 591: 2973+4	0310' 3D      	                dec a
 592: 2977+13	0311' 325300  	                ld (cmd_len), a         ; Store updated length
 593: 2990+6	0314' 2B      	                dec hl
 594:				; Delete on terminal.
 595: 2996+7	0315' 3E08    	                ld a, ascii_bs
 596: 3003+17	0317' CD0000  	                call conwch
 597: 3020+17	031A' CD0000  	                call cwpspc             ; Print a space
 598: 3037+7	031D' 3E08    	                ld a, ascii_bs
 599: 3044+17	031F' CD0000  	                call conwch
 600: 3061+10	0322' C9      	                ret
 601:				;
 602:				; End of command.
 603: 3071+4	0323' AF      	gc_cr           xor a
 604: 3075+7	0324' 77      	                ld (hl), a              ; Add terminator
 605:				; The command is now a null-terminated string in cmd_buf with cmd_len characters.
 606: 3082+17	0325' CD0000  	                call cwnwln             ; Write new line characters to console
 607: 3099+10	0328' 210300  	                ld hl, cmd_buf          ; Point to start of command buffer
 608: 3109+17	032B' CD0000  	                call skpspc             ; Skip any leading spaces
 609:				;
 610: 3126+7	032E' 7E      	                ld a, (hl)
 611: 3133+4	032F' A7      	                and a
 612: 3137+10	0330' CA2302  	                jp z, get_cmd           ; Ignore null commands
 613:				;
 614:				; Copy the command to the history circular buffer. The buffer consists of a series
 615:				; of null-terminated commands. cmd_hist_iptr points to the first free space in the
 616:				; buffer. When the buffer is full, new entries overwrite the oldest. Null commands
 617:				; are not allowed, so two terminators together indicates the end of the buffer
 618:				; contents.
 619: 3147+11	0333' E5      	                push hl                 ; Save command buffer address
 620: 3158+16	0334' 2A6101  	                ld hl, (cmd_hist_iptr)
 621: 3174+10	0337' 110300  	                ld de, cmd_buf          ; Point to start of command buffer
 622: 3184+17	033A' CD5103  	gc_hist_copy_lp call hist_val_ptr       ; Validate pointer
 623:				; HL - pointer to first space in history buffer.
 624: 3201+7	033D' 1A      	                ld a, (de)              ; Copy character
 625: 3208+7	033E' 77      	                ld (hl), a
 626: 3215+6	033F' 13      	                inc de
 627: 3221+6	0340' 23      	                inc hl
 628: 3227+4	0341' A7      	                and a
 629: 3231+7+5	0342' 20F6    	                jr nz, gc_hist_copy_lp  ; Continue unless terminator copied
 630: 3238+17	0344' CD5103  	                call hist_val_ptr       ; Validate pointer
 631: 3255+16	0347' 226101  	                ld (cmd_hist_iptr), hl  ; Update pointer
 632:				;
 633:				; Process the command.
 634: 3271+10	034A' E1      	                pop hl                  ; Restore command buffer address
 635: 3281+17	034B' CD0000  	                call mcexec             ; Execute the command
 636: 3298+10	034E' C32302  	                jp get_cmd              ; Fetch another command
 637:				;
 638:				;
 639:				; Validate the history buffer, setting it to the beginning or end in a circular
 640:				; fashion if it is out of range. This may be used to perform wrap-around as well
 641:				; as recovering from a corrupt pointer.
 642:				; Call with:
 643:				; HL - history buffer pointer
 644:				; Returns with:
 645:				; HL - validated pointer
 646: 3308+11	0351' C5      	hist_val_ptr    push bc
 647: 3319+10	0352' 016100  	                ld bc, cmd_history
 648: 3329+4	0355' A7      	                and a
 649: 3333+15	0356' ED42    	                sbc hl, bc
 650: 3348+7+5	0358' 380E    	                jr c, hvp_set_end       ; Jump if pointer < buffer start
 651: 3355+11	035A' 09      	                add hl, bc
 652: 3366+10	035B' 016101  	                ld bc, cmd_history + CMD_HIST_SIZE
 653: 3376+4	035E' A7      	                and a
 654: 3380+15	035F' ED42    	                sbc hl, bc
 655: 3395+7+5	0361' 380A    	                jr c, hvp_adj_good      ; Jump if pointer <= buffer end
 656:				; Pointer is to large.
 657: 3402+10	0363' 216100  	                ld hl, cmd_history      ; Set to start of buffer
 658: 3412+10	0366' C1      	                pop bc
 659: 3422+10	0367' C9      	                ret
 660:				; Pointer is to small.
 661: 3432+10	0368' 216001  	hvp_set_end     ld hl, cmd_history + CMD_HIST_SIZE - 1  ; Set to end of buffer
 662: 3442+10	036B' C1      	                pop bc
 663: 3452+10	036C' C9      	                ret
 664:				; Pointer is just right.
 665: 3462+11	036D' 09      	hvp_adj_good    add hl, bc              ; Restore pointer
 666: 3473+10	036E' C1      	                pop bc
 667: 3483+10	036F' C9      	                ret
 668:				;
 669:				;
 670:				; Switch context to user code. Call with:
 671:				; A - trace mode (TRM_xxx)
 672:				; DE - trace until address (relevant when A = TRM_TO_ADDR only)
 673: 3493+13	0370' 325800  	mcrun           ld (trace_mode), a
 674: 3506+20	0373' ED535900	                ld (trace_addr), de
 675:				;
 676:				; Calculate the control register value we will need later.
 677: 3526+7	0377' 0E00    	ru_keep_going   ld c, 0                 ; Initial value
 678:				; Set MMAP bit if appropriate.
 679: 3533+13	0379' 3A6601  	                ld a, (mstate + MST_MMAP_EN)
 680: 3546+4	037C' A7      	                and a
 681: 3550+7+5	037D' 2804    	                jr z, run_ctl_mmap_dn   ; Jump if no memory mapping
 682: 3557+4	037F' 79      	                ld a, c
 683: 3561+7	0380' F608    	                or SYSCTRL_MAPARM_MASK  ; Enable mapping after delay
 684: 3568+4	0382' 4F      	                ld c, a
 685:				; Set TRARM bit if appropriate.
 686: 3572+13	0383' 3A5800  	run_ctl_mmap_dn ld a, (trace_mode)
 687: 3585+7	0386' FE00    	                cp TRM_NONE
 688: 3592+7+5	0388' 2839    	                jr z, run_ctl_tr_dn     ; Jump if no trace required
 689:				; Trace is requested.
 690: 3599+13	038A' 3A6601  	                ld a, (mstate + MST_MMAP_EN)
 691: 3612+4	038D' A7      	                and a
 692: 3616+7+5	038E' 2009    	                jr nz, run_tr_map_ok
 693:				; Trace is selected, but mapping is disabled. This will fail because the
 694:				; resulting NMI won't be able to push the PC. There are other conditions that
 695:				; will cause similar issues, but we can't catch them all.
 696: 3623+10	0390' 218F09  	                ld hl, tr_map_msg      ; "Can't trace without mapping"
 697: 3633+17	0393' CD0000  	                call conwms             ; Print message
 698: 3650+10	0396' C32302  	                jp get_cmd              ; Fetch another command
 699:				; Mapping with trace is OK, so arm the trace NMI.
 700: 3660+4	0399' 79      	run_tr_map_ok   ld a, c
 701: 3664+7	039A' F601    	                or SYSCTRL_TRARM_MASK
 702: 3671+4	039C' 4F      	                ld c, a
 703:				; For trace (only), set prefix count bits according to the instruction. Valid
 704:				; prefixes are 0xCB, 0xDD, 0xED and 0xFD. This will work for all legal
 705:				; combinations such as 0xDD 0xCB.
 706:				; Check for 0xFD and 0xDD initially.
 707: 3675+16	039D' 2A6D01  	                ld hl, (mstate + MST_PC)
 708: 3691+17	03A0' CD7507  	                call rusby              ; Read byte from user space
 709: 3708+7	03A3' FEDD    	                cp 0xdd                 ; (Use IX)
 710: 3715+7+5	03A5' 2806    	                jr z, run_ddfd
 711: 3722+7	03A7' FEFD    	                cp 0xfd                 ; (Use IY)
 712: 3729+7+5	03A9' 2802    	                jr z, run_ddfd
 713: 3736+12	03AB' 1808    	                jr run_ddfd_done        ; Not a 0xFD or 0xDD
 714:				; 0xFD or 0xDD found.
 715: 3748+4	03AD' 79      	run_ddfd        ld a, c
 716: 3752+7	03AE' C620    	                add SYSCTRL_TRPRE0_MASK ; Increment TRPRE bits
 717: 3759+4	03B0' 4F      	                ld c, a
 718: 3763+6	03B1' 23      	                inc hl
 719: 3769+17	03B2' CD7507  	                call rusby              ; Read byte from user space
 720:				; Check for 0xCB and 0xED.
 721: 3786+7	03B5' FECB    	run_ddfd_done   cp 0xcb                 ; (Bit, res and set)
 722: 3793+7+5	03B7' 2806    	                jr z, run_cbed
 723: 3800+7	03B9' FEED    	                cp 0xed                 ; (Various instructons)
 724: 3807+7+5	03BB' 2802    	                jr z, run_cbed
 725: 3814+12	03BD' 1804    	                jr run_ctl_tr_dn        ; Not a 0xCB and 0xED
 726:				; 0xCB and 0xED found.
 727: 3826+4	03BF' 79      	run_cbed        ld a, c
 728: 3830+7	03C0' C620    	                add SYSCTRL_TRPRE0_MASK ; Increment TRPRE bits
 729: 3837+4	03C2' 4F      	                ld c, a
 730:				; Store the result for later.
 731: 3841+4	03C3' 79      	run_ctl_tr_dn   ld a, c
 732: 3845+13	03C4' 326000  	                ld (run_ctrl), a
 733:				;
 734: 3858+4	03C7' F3      	                di                      ; Ensure interrupts are disabled
 735:				; Modify exit routine to reflect the desired machine state on exit.
 736: 3862+17	03C8' CD4C04  	                call mmap_page0_rw      ; Set bank 0 to read/write
 737:				; A register
 738: 3879+13	03CB' 3A8201  	                ld a, (mstate + MST_AF + 1)
 739: 3892+13	03CE' 322F04  	                ld (run_ld_a + 1), a
 740:				; Interrupts enabled?
 741: 3905+7	03D1' 0EFB    	                ld c, ei                ; Assume yes
 742: 3912+13	03D3' 3A6501  	                ld a, (mstate + MST_IEN)    ; Interrupt enable flag
 743: 3925+4	03D6' A7      	                and a
 744: 3929+7+5	03D7' 2002    	                jr nz, run_ints         ; Jump if interrupts enabled
 745: 3936+7	03D9' 0E00    	                ld c, nop               ; Use NOP for no interrupts
 746: 3943+4	03DB' 79      	run_ints        ld a, c
 747: 3947+13	03DC' 323004  	                ld (run_ei), a          ; Set the desired instruction
 748:				; PC
 749: 3960+16	03DF' 2A6D01  	                ld hl, (mstate + MST_PC)
 750: 3976+16	03E2' 223204  	                ld (run_jump + 1), hl   ; Set jump address
 751:				; BC
 752: 3992+16	03E5' 2A7F01  	                ld hl, (mstate + MST_BC)
 753: 4008+16	03E8' 222C04  	                ld (run_ld_bc + 1), hl
 754:				;
 755: 4024+17	03EB' CD5104  	                call mmap_page0_ro      ; Set bank 0 to read only
 756:				;
 757:				; Point the stack pointer to the machine state structure so we can load registers
 758:				; efficiently. Interrupts are disabled, so this is safe.
 759: 4041+10	03EE' 316F01  	                ld sp, mstate + MST_IY
 760: 4051+14	03F1' FDE1    	                pop iy
 761: 4065+14	03F3' DDE1    	                pop ix
 762: 4079+10	03F5' E1      	                pop hl                  ; Alternate ("prime") registers
 763: 4089+10	03F6' D1      	                pop de
 764: 4099+10	03F7' C1      	                pop bc
 765: 4109+10	03F8' F1      	                pop af
 766: 4119+4	03F9' 08      	                ex af, af'
 767: 4123+4	03FA' D9      	                exx
 768: 4127+10	03FB' E1      	                pop hl                  ; "Normal" registers
 769: 4137+10	03FC' D1      	                pop de
 770:				; BC, AF and PC are restored later.
 771: 4147+13	03FD' 3A8301  	                ld a, (mstate + MST_I)
 772: 4160+9	0400' ED47    	                ld i, a
 773:				; R will have changed, so a correction will be required if we want to be
 774:				; completely accurate.
 775: 4169+13	0402' 3A8401  	                ld a, (mstate + MST_R)
 776: 4182+9	0405' ED4F    	                ld r, a
 777:				;
 778:				; Restore banks that are not critical to the monitor code. Banks 0 and 1 are
 779:				; stored in BC for later.
 780: 4191+13	0407' 3A6701  	                ld a, (mstate + MST_MMAP0)
 781: 4204+4	040A' 4F      	                ld c, a
 782: 4208+13	040B' 3A6801  	                ld a, (mstate + MST_MMAP1)
 783: 4221+4	040E' 47      	                ld b, a
 784: 4225+13	040F' 3A6901  	                ld a, (mstate + MST_MMAP2)
 785: 4238+11	0412' D306    	                out IOA_MMAP_2
 786: 4249+13	0414' 3A6A01  	                ld a, (mstate + MST_MMAP3)
 787: 4262+11	0417' D307    	                out IOA_MMAP_3
 788:				;
 789: 4273+6	0419' 33      	                inc sp                  ; Skip BC on stack
 790: 4279+6	041A' 33      	                inc sp
 791: 4285+10	041B' F1      	                pop af                  ; Restore AF (A will be overwritten)
 792:				; Code between now and exit must not disturb the flags!
 793: 4295+20	041C' ED7B6B01	                ld sp, (mstate + MST_SP)    ; Load user stack pointer
 794: 4315+13	0420' 3A6000  	                ld a, (run_ctrl)        ; Set pre-calculated value
 795: 4328+11	0423' D302    	                out (IOA_CONTROL), a    ; Start hardware timers if selected
 796:				; Memory mapping is now off, so we have just read-only access to page 0x3f.
 797: 4339+4	0425' 79      	                ld a, c
 798: 4343+11	0426' D304    	                out IOA_MMAP_0
 799: 4354+4	0428' 78      	                ld a, b
 800: 4358+11	0429' D305    	                out IOA_MMAP_1
 801:				; Memory mapping is now turned off so we only have page 0x3f. Set user banks 0
 802:				; and 1. The following code will be modified before execution.
 803: 4369+10	042B' 010000  	run_ld_bc       ld bc, 0
 804: 4379+7	042E' 3E00    	run_ld_a        ld a, 0
 805: 4386+4	0430' FB      	run_ei          ei                      ; Set to EI or NOP as required
 806: 4390+10	0431' C30000  	run_jump        jp 0                    ; Address will be set to desired PC
 807:				;
 808:				;
 809:				; Set RST vector to point to a new service routine.
 810:				; Call with:
 811:				; A - RST number of vector to change (0x08, 0x10, 0x18 ... 0x38)
 812:				; DE - points to the new service routine
 813:				; Returns with:
 814:				; C flag - set on error (invalid vector number)
 815: 4400+11	0434' E5      	utrivc          push hl
 816: 4411+4	0435' 6F      	                ld l, a                 ; Save vector number
 817: 4415+7	0436' E6C7    	                and 0xc7
 818: 4422+7+5	0438' 200F    	                jr nz, srvec_err
 819: 4429+4	043A' 7D      	                ld a, l
 820:				; Calculate vector address
 821: 4433+10	043B' 210000  	                ld hl, Z80_RST00_VEC
 822: 4443+4	043E' 85      	                add l
 823: 4447+4	043F' 6F      	                ld l, a
 824:				; HL - vector address
 825: 4451+10	0440' 36C3    	                ld (hl), jmp            ; Jump instruction
 826: 4461+6	0442' 23      	                inc hl
 827: 4467+7	0443' 73      	                ld (hl), e              ; LS byte of address
 828: 4474+6	0444' 23      	                inc hl
 829: 4480+7	0445' 72      	                ld (hl), d              ; MS byte of address
 830:				; Successful return
 831: 4487+10	0446' E1      	                pop hl
 832: 4497+4	0447' A7      	                and a
 833: 4501+10	0448' C9      	                ret                     ; Return with carry flag reset (OK)
 834:				; Error
 835: 4511+10	0449' E1      	srvec_err       pop hl
 836: 4521+4	044A' 37      	                scf
 837: 4525+10	044B' C9      	                ret                     ; Return with carry flag set (error)
 838:				;
 839:				;
 840:				; Set bank 0 to read/write mode to vectors etc. can be changed.
 841: 4535+7	044C' 3E7F    	mmap_page0_rw   ld a, MMAP_MON_B0_PAGE + MMAP_SUPER_MASK
 842: 4542+11	044E' D304    	                out (IOA_MMAP_0), a
 843: 4553+10	0450' C9      	                ret
 844:				;
 845:				; Set bank 0 to read only mode to prevent accidental writes.
 846: 4563+7	0451' 3EFF    	mmap_page0_ro   ld a, MMAP_MON_B0_PAGE + MMAP_PROT_MASK + MMAP_SUPER_MASK
 847: 4570+11	0453' D304    	                out (IOA_MMAP_0), a
 848: 4581+10	0455' C9      	                ret
 849:				;
 850:				;
 851:				; Default exception handlers. In all cases except trace, tracing is disabled to
 852:				; allow the monitor to run normally. This has to be done before the exception ID
 853:				; is written to avoid it being overwritten by the trace NMI ID. Interrupts are
 854:				; disabled. There is no way of telling what the interrupt enable state (IFF1) is,
 855:				; so this is the only safe option.
 856:				;
 857:				; "Enter monitor" call. We want to save the context, but not display a register
 858:				; dump.
 859: 4591+4	0456' F3      	mon_entry       di
 860: 4595+11	0457' F5      	                push af
 861: 4606+11	0458' C5      	                push bc
 862: 4617+7	0459' 3E03    	                ld a, TRM_XPT
 863: 4624+13	045B' 325800  	                ld (trace_mode), a      ; Disable tracing
 864: 4637+7	045E' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 865: 4644+13	0460' 326601  	                ld (mstate + MST_MMAP_EN), a
 866: 4657+7	0463' 3E00    	                ld a, XPTT_MON_ENT
 867: 4664+10	0465' C31105  	                jp except_hdlr
 868:				;
 869:				; Restarts cause a register dump.
 870: 4674+4	0468' F3      	default_rst08   di
 871: 4678+11	0469' F5      	                push af
 872: 4689+11	046A' C5      	                push bc
 873: 4700+7	046B' 3E03    	                ld a, TRM_XPT
 874: 4707+13	046D' 325800  	                ld (trace_mode), a      ; Disable tracing
 875: 4720+7	0470' 3E01    	                ld a, XPTT_RST08
 876: 4727+10	0472' C31105  	                jp except_hdlr
 877:				;
 878: 4737+4	0475' F3      	default_rst10   di
 879: 4741+11	0476' F5      	                push af
 880: 4752+11	0477' C5      	                push bc
 881: 4763+7	0478' 3E03    	                ld a, TRM_XPT
 882: 4770+13	047A' 325800  	                ld (trace_mode), a      ; Disable tracing
 883: 4783+7	047D' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 884: 4790+13	047F' 326601  	                ld (mstate + MST_MMAP_EN), a
 885: 4803+7	0482' 3E02    	                ld a, XPTT_RST10
 886: 4810+10	0484' C31105  	                jp except_hdlr
 887:				;
 888: 4820+4	0487' F3      	default_rst18   di
 889: 4824+11	0488' F5      	                push af
 890: 4835+11	0489' C5      	                push bc
 891: 4846+7	048A' 3E03    	                ld a, TRM_XPT
 892: 4853+13	048C' 325800  	                ld (trace_mode), a      ; Disable tracing
 893: 4866+7	048F' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 894: 4873+13	0491' 326601  	                ld (mstate + MST_MMAP_EN), a
 895: 4886+7	0494' 3E03    	                ld a, XPTT_RST18
 896: 4893+12	0496' 1879    	                jr except_hdlr
 897:				;
 898: 4905+4	0498' F3      	default_rst20   di
 899: 4909+11	0499' F5      	                push af
 900: 4920+7	049A' 3E03    	                ld a, TRM_XPT
 901: 4927+13	049C' 325800  	                ld (trace_mode), a      ; Disable tracing
 902: 4940+7	049F' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 903: 4947+13	04A1' 326601  	                ld (mstate + MST_MMAP_EN), a
 904: 4960+7	04A4' 3E04    	                ld a, XPTT_RST20
 905: 4967+12	04A6' 1869    	                jr except_hdlr
 906:				;
 907: 4979+4	04A8' F3      	default_rst28   di
 908: 4983+11	04A9' F5      	                push af
 909: 4994+11	04AA' C5      	                push bc
 910: 5005+7	04AB' 3E03    	                ld a, TRM_XPT
 911: 5012+13	04AD' 325800  	                ld (trace_mode), a      ; Disable tracing
 912: 5025+7	04B0' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 913: 5032+13	04B2' 326601  	                ld (mstate + MST_MMAP_EN), a
 914: 5045+7	04B5' 3E05    	                ld a, XPTT_RST28
 915: 5052+12	04B7' 1858    	                jr except_hdlr
 916:				;
 917: 5064+4	04B9' F3      	default_rst30   di
 918: 5068+11	04BA' F5      	                push af
 919: 5079+11	04BB' C5      	                push bc
 920: 5090+7	04BC' 3E03    	                ld a, TRM_XPT
 921: 5097+13	04BE' 325800  	                ld (trace_mode), a      ; Disable tracing
 922: 5110+7	04C1' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 923: 5117+13	04C3' 326601  	                ld (mstate + MST_MMAP_EN), a
 924: 5130+7	04C6' 3E06    	                ld a, XPTT_RST30
 925: 5137+12	04C8' 1847    	                jr except_hdlr
 926:				;
 927: 5149+4	04CA' F3      	default_rst38   di
 928: 5153+11	04CB' F5      	                push af
 929: 5164+11	04CC' C5      	                push bc
 930: 5175+7	04CD' 3E03    	                ld a, TRM_XPT
 931: 5182+13	04CF' 325800  	                ld (trace_mode), a      ; Disable tracing
 932: 5195+7	04D2' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 933: 5202+13	04D4' 326601  	                ld (mstate + MST_MMAP_EN), a
 934: 5215+7	04D7' 3E07    	                ld a, XPTT_RST38
 935: 5222+12	04D9' 1836    	                jr except_hdlr
 936:				;
 937:				; System error! Halt the system to prevent further damage. Call this routine
 938:				; in case of a serious error. This is treated as any other exception, the
 939:				; stack looks the same in any case. Note: call is preferred (rather than jump)
 940:				; as it preserves the PC.
 941: 5234+4	04DB' F3      	panic           di
 942: 5238+11	04DC' F5      	                push af
 943: 5249+11	04DD' C5      	                push bc
 944: 5260+7	04DE' 3E03    	                ld a, TRM_XPT
 945: 5267+13	04E0' 325800  	                ld (trace_mode), a      ; Disable tracing
 946: 5280+7	04E3' 3E01    	                ld a, 1                 ; Memory mapping is enabled
 947: 5287+13	04E5' 326601  	                ld (mstate + MST_MMAP_EN), a
 948: 5300+7	04E8' 3E09    	                ld a, XPTT_PANIC
 949: 5307+12	04EA' 1825    	                jr except_hdlr
 950:				;
 951:				; NMIs require special handling due to the special memory mapping mode enabled
 952:				; in hardware. In this mode, the memory mapping system is disabled except for
 953:				; write operations. NMI will remain active until released by clearing the relevant
 954:				; bit or bits in NMI_REASONS. This prevent multiple NMIs from locking up the
 955:				; system. We can determine the interrupt enable state (IFF2) so it can be restored
 956:				; if desired.
 957: 5319+11	04EC' F5      	default_nmi     push af
 958: 5330+11	04ED' C5      	                push bc                 ; Push BC on the user stack
 959:				;
 960:				; PC, AF and BC are on the user stack.
 961:				; Save memory mapping context before we change anything.
 962: 5341+11	04EE' DB04    	                in IOA_MMAP_0
 963: 5352+4	04F0' 4F      	                ld c, a
 964: 5356+11	04F1' DB05    	                in IOA_MMAP_1
 965: 5367+4	04F3' 47      	                ld b, a
 966:				; Set bank 0 (0x0000 to 0x3fff) as read-only with I/O access.
 967: 5371+7	04F4' 3EFF    	                ld a, MMAP_MON_B0_PAGE + MMAP_PROT_MASK + MMAP_SUPER_MASK
 968: 5378+11	04F6' D304    	                out (IOA_MMAP_0), a
 969:				; Bank 1 (0x4000 to 0x7fff) writeable.
 970: 5389+7	04F8' 3E3E    	                ld a, MMAP_MON_B1_PAGE
 971: 5396+11	04FA' D305    	                out (IOA_MMAP_1), a
 972:				; Enable normal memory mapping and disable mapping for writes only. From now on,
 973:				; reads and writes behave normally.
 974: 5407+7	04FC' 3E06    	                ld a, SYSCTRL_MMAP_MASK + SYSCTRL_NMCLR_MASK
 975: 5414+11	04FE' D302    	                out (IOA_CONTROL), a
 976:				; Write the saved bank 0 and 1 pages.
 977: 5425+4	0500' 79      	                ld a, c
 978: 5429+13	0501' 326701  	                ld (mstate + MST_MMAP0), a
 979: 5442+4	0504' 78      	                ld a, b
 980: 5446+13	0505' 326801  	                ld (mstate + MST_MMAP1), a
 981:				;
 982:				; Save memory mapping enable bit. This is MMAP when the NMI occurred.
 983: 5459+11	0508' DB02    	                in IOA_CONTROL
 984: 5470+7	050A' E610    	                and SYSCTRL_MMAPN_MASK
 985: 5477+13	050C' 326601  	                ld (mstate + MST_MMAP_EN), a
 986:				;
 987: 5490+7	050F' 3E08    	                ld a, XPTT_NMI
 988:				; Drop into the exception handler.
 989:				;
 990:				; Exception handler. Care is taken to preserve the machine state.
 991:				; PC, AF and BC are on the stack, and A contains the exception ID number.
 992: 5497+13	0511' 325500  	except_hdlr     ld (xpt_id), a          ; Store exception ID
 993: 5510+11	0514' DB06    	                in IOA_MMAP_2
 994: 5521+13	0516' 326901  	                ld (mstate + MST_MMAP2), a
 995: 5534+11	0519' DB07    	                in IOA_MMAP_3
 996: 5545+13	051B' 326A01  	                ld (mstate + MST_MMAP3), a
 997:				; Setup bank 0 and bank 1 for the monitor.
 998:				; Set bank 0 (0x0000 to 0x3fff) as read-only with I/O access.
 999: 5558+7	051E' 3EFF    	                ld a, MMAP_MON_B0_PAGE + MMAP_PROT_MASK + MMAP_SUPER_MASK
1000: 5565+11	0520' D304    	                out (IOA_MMAP_0), a
1001:				; Bank 1 (0x4000 to 0x7fff) writeable.
1002: 5576+7	0522' 3E3E    	                ld a, MMAP_MON_B1_PAGE
1003: 5583+11	0524' D305    	                out (IOA_MMAP_1), a
1004:				;
1005: 5594+20	0526' ED736B01	                ld (mstate + MST_SP), sp    ; Save SP
1006:				; Point the stack pointer to the machine state structure so we can save registers
1007:				; efficiently. Interrupts are disabled, so this is safe.
1008: 5614+10	052A' 317F01  	                ld sp, mstate + MST_DE + 2
1009: 5624+11	052D' D5      	                push de
1010: 5635+11	052E' E5      	                push hl
1011: 5646+4	052F' 08      	                ex af, af'
1012: 5650+4	0530' D9      	                exx
1013: 5654+11	0531' F5      	                push af                 ; Alternate registers
1014: 5665+11	0532' C5      	                push bc
1015: 5676+11	0533' D5      	                push de
1016: 5687+11	0534' E5      	                push hl
1017: 5698+15	0535' DDE5    	                push ix
1018: 5713+15	0537' FDE5    	                push iy
1019:				;
1020: 5728+10	0539' 31C501  	                ld sp, mon_stack_p1     ; Use the monitor's stack
1021: 5738+14	053C' DD216501	                ld ix, mstate           ; Machine state structure
1022: 5752+4	0540' AF      	                xor a
1023: 5756+19	0541' DD7700  	                ld (ix + MST_IEN), a    ; Assume interrupts were disabled
1024:				; R will have changed, so a correction will be required if we want to be
1025:				; completely accurate.
1026: 5775+9	0544' ED5F    	                ld a, r
1027: 5784+19	0546' DD771F  	                ld (ix + MST_R), a
1028: 5803+9	0549' ED57    	                ld a, i
1029: 5812+19	054B' DD771E  	                ld (ix + MST_I), a
1030:				;
1031:				; Determine the interrupt enable state. For NMIs, the P/V flag after "ld a, i"
1032:				; contains the state of IFF2. This gives the interrupt enable state before the
1033:				; NMI occurred. Note that this method of determining the interrupt enable status
1034:				; is not completely reliable for NMOS Z80s. However, it is good for CMOS ones,
1035:				; such as that used in ZARC.
1036:				; For entries other than NMI, there is no way of telling what the interrupt
1037:				; enable state (IFF1) is. The only safe option is to disable them.
1038: 5831+7	054E' 0E00    	                ld c, 0                 ; Assume interrupts are disabled
1039: 5838+13	0550' 3A5500  	                ld a, (xpt_id)
1040: 5851+7	0553' FE08    	                cp XPTT_NMI
1041: 5858+7+5	0555' 2007    	                jr nz, xpt_int_dis      ; Ints disabled if not an NMI
1042:				; We are processing the results of an NMI.
1043: 5865+9	0557' ED57    	                ld a, i
1044: 5874+10	0559' E25E05  	                jp po, xpt_int_dis      ; Interrupts were disabled.
1045: 5884+7	055C' 0E01    	                ld c, 1
1046: 5891+19	055E' DD7100  	xpt_int_dis     ld (ix + MST_IEN), c    ; Set enable state
1047:				;
1048:				; Read PC, AF and BC from the user stack.
1049: 5910+16	0561' 2A6B01  	                ld hl, (mstate + MST_SP)
1050:				; Emulate POP BC in user space.
1051: 5926+17	0564' CD6A07  	                call ruswd              ; Read 16-bit word from user space
1052: 5943+6	0567' 23      	                inc hl
1053: 5949+6	0568' 23      	                inc hl
1054: 5955+20	0569' ED537F01	                ld (mstate + MST_BC), de
1055:				; POP AF
1056: 5975+17	056D' CD6A07  	                call ruswd              ; Read 16-bit word from user space
1057: 5992+6	0570' 23      	                inc hl
1058: 5998+6	0571' 23      	                inc hl
1059: 6004+20	0572' ED538101	                ld (mstate + MST_AF), de
1060:				; POP PC
1061: 6024+17	0576' CD6A07  	                call ruswd              ; Read 16-bit word from user space
1062: 6041+6	0579' 23      	                inc hl
1063: 6047+6	057A' 23      	                inc hl
1064: 6053+20	057B' ED536D01	                ld (mstate + MST_PC), de
1065: 6073+16	057F' 226B01  	                ld (mstate + MST_SP), hl
1066:				; SP is updated so the monitor "sees" the stack as it was before the NMI.
1067:				;
1068:				; Machine state is saved.
1069: 6089+13	0582' 3A5500  	                ld a, (xpt_id)          ; Fetch exception ID
1070: 6102+7	0585' FE00    	                cp XPTT_MON_ENT
1071: 6109+7+5	0587' 2005    	                jr nz,xpt_not_emon
1072:				; "Enter monitor" call.
1073: 6116+7	0589' 0E00    	                ld c, 0                 ; Flag not a reset
1074: 6123+10	058B' C3F600  	                jp init                 ; Initialise monitor, stack etc.
1075:				;
1076:				; Is this a trace interrupt? If so, the behaviour is different.
1077: 6133+7	058E' FE08    	xpt_not_emon    cp XPTT_NMI
1078: 6140+7+5	0590' 2022    	                jr nz, xpt_disp_reason
1079:				; The exception is an NMI, so it could be a trace.
1080: 6147+11	0592' DB0C    	                in a, (IOA_NMI_REASONS)
1081: 6158+7	0594' E60F    	                and NMI_REASONS_ALL
1082: 6165+7	0596' FE08    	                cp NMI_TRACE_MASK
1083: 6172+7+5	0598' 201A    	                jr nz, xpt_disp_reason
1084:				; Trace interrupt (only). If we are in "trace to address" mode, we should keep
1085:				; going unless we are at the required address.
1086: 6179+13	059A' 3A5800  	                ld a, (trace_mode)
1087: 6192+7	059D' FE02    	                cp TRM_TO_ADDR
1088: 6199+7+5	059F' 2806    	                jr z, xpt_tr_to_addr    ; Jump if trace to address
1089: 6206+7	05A1' FE03    	                cp TRM_XPT
1090: 6213+7+5	05A3' 286B    	                jr z, xpt_tr_xpt        ; Jump if exception while tracing
1091: 6220+12	05A5' 180D    	                jr xpt_disp_reason      ; Stop tracing and enter monitor
1092:				;
1093:				; Trace to address.
1094: 6232+20	05A7' ED5B5900	xpt_tr_to_addr  ld de, (trace_addr)
1095: 6252+16	05AB' 2A6D01  	                ld hl, (mstate + MST_PC)
1096: 6268+4	05AE' A7      	                and a
1097: 6272+15	05AF' ED52    	                sbc hl, de
1098: 6287+10	05B1' C20906  	                jp nz, xpt_tr_notyet    ; Keep going unless there is a match
1099:				;
1100:				; Display the reason for the exception.
1101: 6297+7	05B4' 3E00    	xpt_disp_reason ld a, TRM_NONE
1102: 6304+13	05B6' 325800  	                ld (trace_mode), a      ; Disable tracing
1103: 6317+17	05B9' CD6107  	                call con_init_basic     ; Initialise console I/O in basic mode
1104: 6334+10	05BC' 214E08  	                ld hl, xpt_pre_msg
1105: 6344+17	05BF' CD0000  	                call conwms             ; Print "*** " message
1106: 6361+10	05C2' 215508  	                ld hl, xpt_desc_msgs
1107: 6371+13	05C5' 3A5500  	                ld a, (xpt_id)          ; Fetch exception ID
1108: 6384+7	05C8' 0E7C    	                ld c, "|"               ; Separator
1109: 6391+17	05CA' CD0000  	                call conwmn             ; Print message <n> in a list
1110: 6408+13	05CD' 3A5500  	                ld a, (xpt_id)          ; Fetch exception ID
1111: 6421+7	05D0' FE08    	                cp XPTT_NMI
1112: 6428+7+5	05D2' 2027    	                jr nz, xpt_notnmi
1113:				; Display reason(s) for the NMI. There may be more than one reason, for example
1114:				; a trace with a front panel switch operation.
1115: 6435+11	05D4' DB0C    	                in a, (IOA_NMI_REASONS)
1116: 6446+4	05D6' 4F      	                ld c, a
1117: 6450+10	05D7' 21A508  	                ld hl, xpt_sw_msg       ; "(front panel)" message
1118: 6460+8	05DA' CB41    	                bit NMI_SWITCH_BIT, c
1119: 6468+10+7	05DC' C40000  	                call nz, conwms
1120: 6478+10	05DF' 21B408  	                ld hl, xpt_prot_msg     ; "(write protection)" message
1121: 6488+8	05E2' CB49    	                bit NMI_PROT_VIOL_BIT, c
1122: 6496+10+7	05E4' C40000  	                call nz, conwms
1123: 6506+10	05E7' 21C808  	                ld hl, xpt_super_msg    ; "(not supervisor)" message
1124: 6516+8	05EA' CB51    	                bit NMI_SUPER_VIOL_BIT, c
1125: 6524+10+7	05EC' C40000  	                call nz, conwms
1126: 6534+10	05EF' 21DA08  	                ld hl, xpt_trace_msg    ; "(trace [single step])" message
1127: 6544+8	05F2' CB59    	                bit NMI_TRACE_BIT, c
1128: 6552+10+7	05F4' C40000  	                call nz, conwms
1129:				; Reset all reason bits. This will release the NMI signal and hence turn off the
1130:				; NMI LED on the front panel.
1131: 6562+7	05F7' 3E0F    	                ld a, NMI_REASONS_ALL
1132: 6569+11	05F9' D30C    	                out (IOA_NMI_REASONS)
1133: 6580+10	05FB' 21F108  	xpt_notnmi      ld hl, xpt_post_msg
1134: 6590+17	05FE' CD0000  	                call conwms             ; Print " ***" message
1135: 6607+17	0601' CD1806  	                call mdisrg             ; Display registers
1136: 6624+7	0604' 0E00    	                ld c, 0                 ; Flag not a reset
1137: 6631+10	0606' C3F600  	                jp init                 ; Initialise monitor, stack etc.
1138:				;
1139:				; Go here if in trace to address mode, and this isn't the required address.
1140:				; Alternatively, this is used to return to the user context if an exception
1141:				; occurs while tracing.
1142: 6641+7	0609' 3E0F    	xpt_tr_notyet   ld a, NMI_REASONS_ALL
1143: 6648+11	060B' D30C    	                out (IOA_NMI_REASONS)   ; Reset NMI reasons to release NMI signal
1144: 6659+10	060D' C37703  	                jp ru_keep_going
1145:				;
1146:				; An exception has occurred while tracing. In order to allow the monitor to run
1147:				; normally, the trace must be stopped. We need to return to the user code, but
1148:				; with trace disabled.
1149: 6669+7	0610' 3E00    	xpt_tr_xpt      ld a, TRM_NONE
1150: 6676+13	0612' 325800  	                ld (trace_mode), a      ; Disable tracing
1151: 6689+10	0615' C30906  	                jp xpt_tr_notyet        ; Return to user context
1152:				;
1153:				;
1154:				; Display all registers. The result will look something like this:
1155:				; A: xx, F: SZ.H.VNC, BC: xxxx, DE: xxxx, HL: xxxx
1156:				; A': xx, F': SZ.H.VNC, BC': xxxx, DE': xxxx, HL': xxxx
1157:				; PC: xxxx, SP: xxxx, IX: xxxx, IY: xxxx, I: xx, R: xx
1158:				; IEn: x, MMap: xx [nnnn], xx [nnnn], xx [nnnn], xx [nnnn]
1159:				; Stack: xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
1160:				; Note that this routine does not preserve any registers.
1161: 6699+10	0618' 118101  	mdisrg          ld de, mstate + MST_AF  ; Point to first saved entry
1162: 6709+10	061B' 21F808  	                ld hl, xpt_regs_msg     ; Associated text
1163: 6719+17	061E' CD1407  	                call dr_reg_set         ; Display AF, BC, DE and HL
1164: 6736+17	0621' CD1407  	                call dr_reg_set         ; Display alternate set
1165:				; PC
1166: 6753+11	0624' D5      	                push de
1167: 6764+17	0625' CD0000  	                call conwms             ; Print next part of text
1168: 6781+11	0628' E5      	                push hl
1169: 6792+16	0629' 2A6D01  	                ld hl, (mstate + MST_PC)
1170: 6808+17	062C' CD0000  	                call cwphwd             ; Print word
1171: 6825+10	062F' E1      	                pop hl
1172: 6835+6	0630' 23      	                inc hl                  ; Skip terminator
1173:				; SP
1174: 6841+17	0631' CD0000  	                call conwms             ; Print next part of text
1175: 6858+11	0634' E5      	                push hl
1176: 6869+16	0635' 2A6B01  	                ld hl, (mstate + MST_SP)
1177: 6885+17	0638' CD0000  	                call cwphwd             ; Print word
1178: 6902+10	063B' E1      	                pop hl
1179: 6912+6	063C' 23      	                inc hl                  ; Skip terminator
1180: 6918+10	063D' D1      	                pop de                  ; Restore pointer to stacked registers
1181:				; IX
1182: 6928+10	063E' 117101  	                ld de, mstate + MST_IX
1183: 6938+17	0641' CD4E07  	                call dr_16              ; Display and update pointers
1184:				; IY
1185: 6955+10	0644' 116F01  	                ld de, mstate + MST_IY
1186: 6965+17	0647' CD4E07  	                call dr_16              ; Display and update pointers
1187:				; I
1188: 6982+10	064A' 118301  	                ld de, mstate + MST_I
1189: 6992+17	064D' CD4207  	                call dr_8               ; Display and update pointers
1190:				; R - actually pretty meaningless, but for completeness.
1191: 7009+10	0650' 118401  	                ld de, mstate + MST_R
1192: 7019+17	0653' CD4207  	                call dr_8               ; Display and update pointers
1193:				; Interrupt enable.
1194: 7036+17	0656' CD0000  	                call conwms             ; Print next part of text
1195: 7053+13	0659' 3A6501  	                ld a, (mstate + MST_IEN)
1196: 7066+4	065C' A7      	                and a
1197: 7070+7+5	065D' 2802    	                jr z, disr_ien_dn
1198: 7077+7	065F' 3E01    	                ld a, 1
1199: 7084+17	0661' CD0000  	disr_ien_dn     call cwphnb             ; Print as a nibble
1200:				; Memory mapping state.
1201: 7101+6	0664' 23      	                inc hl                  ; Step past message terminator
1202: 7107+17	0665' CD0000  	                call conwms             ; Print next part of text
1203: 7124+11	0668' E5      	                push hl                 ; Save message address
1204: 7135+13	0669' 3A6601  	                ld a, (mstate + MST_MMAP_EN)
1205: 7148+4	066C' A7      	                and a
1206: 7152+7+5	066D' 2008    	                jr nz, disr_mmap_en     ; Jump if mapping enabled
1207:				; Memory mapping disabled.
1208: 7159+10	066F' 218309  	                ld hl, dr_off_msg       ; "off"
1209: 7169+17	0672' CD0000  	                call conwms             ; Print next part of text
1210: 7186+12	0675' 1820    	                jr disr_mmap_dn
1211:				;
1212:				; Memory mapping enabled. Display a summary of the mapping state.
1213: 7198+10	0677' 216701  	disr_mmap_en    ld hl, mstate + MST_MMAP0  ; Point to page states
1214: 7208+7	067A' 0604    	                ld b, MMAP_BANKS
1215: 7215+7	067C' 7E      	disr_dis_map_lp ld a, (hl)
1216: 7222+17	067D' CD0000  	                call cwphby             ; Print page number in hexadecimal
1217: 7239+17	0680' CD0000  	                call cwpspc             ; Print a space
1218:				; Print page name, e.g. "[MONP] " or "[unallocated] ".
1219: 7256+7	0683' 7E      	                ld a, (hl)
1220: 7263+7	0684' E63F    	                and MMAP_PAGE_MASK      ; Isolate page bits
1221: 7270+17	0686' CD0000  	                call prpnam             ; Print page name
1222: 7287+4	0689' 05      	                dec b
1223: 7291+7+5	068A' 280B    	                jr z, disr_mmap_dn
1224: 7298+7	068C' 3E2C    	                ld a, ","               ; Display separator
1225: 7305+17	068E' CD0000  	                call conwch
1226: 7322+17	0691' CD0000  	                call cwpspc             ; Print a space
1227: 7339+6	0694' 23      	                inc hl
1228: 7345+12	0695' 18E5    	                jr disr_dis_map_lp
1229:				;
1230:				; Display a few words at the top of the stack.
1231: 7357+10	0697' E1      	disr_mmap_dn    pop hl                  ; Restore message address
1232: 7367+6	0698' 23      	                inc hl                  ; Skip terminator
1233: 7373+17	0699' CD0000  	                call conwms             ; Print next part of text
1234:				; No more messages to print, so we can overwrite HL.
1235: 7390+16	069C' 2A6B01  	                ld hl, (mstate + MST_SP)
1236: 7406+7	069F' 060A    	                ld b, 10                ; Aligns nicely with above text
1237: 7413+17	06A1' CD0000  	disr_stk_loop   call cwpspc             ; Print a space
1238: 7430+17	06A4' CD6A07  	                call ruswd              ; Read 16-bit word from user space
1239: 7447+4	06A7' EB      	                ex de, hl
1240: 7451+17	06A8' CD0000  	                call cwphwd             ; Print word
1241: 7468+4	06AB' EB      	                ex de, hl
1242: 7472+6	06AC' 23      	                inc hl
1243: 7478+6	06AD' 23      	                inc hl
1244: 7484+8+5	06AE' 10F1    	                djnz disr_stk_loop
1245: 7492+17	06B0' CD0000  	                call cwnwln             ; Write new line characters to console
1246:				;
1247:				; Disassemble a few instructions around the PC. In order to synchronise with the
1248:				; instructions, we have to start some way before the ones we want to display. This
1249:				; works well if the PC is set to an instruction boundary and the preceeding bytes
1250:				; are code. It does less well in other cases.
1251: 7509+16	06B3' 2A6D01  	                ld hl, (mstate + MST_PC)
1252: 7525+10	06B6' 111800  	                ld de, (DIS_PRE_INSTRS * 4) + 16
1253: 7535+4	06B9' A7      	                and a
1254: 7539+15	06BA' ED52    	                sbc hl, de
1255:				; In the case of small starting values, skip the instructions prior to the PC. This
1256:				; is because the algorithm doesn't work well for very small values.
1257: 7554+7+5	06BC' 383D    	                jr c, disr_disp_curnt
1258:				; HL - disassembly address
1259: 7561+17	06BE' CD0000  	disr_align_lp   call diproc             ; Disassemble instruction to intermediate form
1260:				; If the disassembly address is >= user PC we should stop.
1261: 7578+11	06C1' E5      	                push hl
1262: 7589+20	06C2' ED5B6D01	                ld de, (mstate + MST_PC)
1263: 7609+4	06C6' A7      	                and a
1264: 7613+15	06C7' ED52    	                sbc hl, de
1265: 7628+10	06C9' E1      	                pop hl
1266: 7638+7+5	06CA' 3014    	                jr nc, disr_align_dn    ; Exit if we have gone far enough
1267:				; Store the address in the buffer.
1268:				; Make space at the end of the address buffer for the new address
1269: 7645+11	06CC' E5      	                push hl
1270: 7656+10	06CD' 115B00  	                ld de, dr_inst_add_buf      ; Destination
1271: 7666+10	06D0' 215D00  	                ld hl, dr_inst_add_buf + 2  ; Source
1272: 7676+10	06D3' 010200  	                ld bc, (DIS_PRE_INSTRS - 1) * 2
1273: 7686+16+5	06D6' EDB0    	                ldir
1274: 7702+4	06D8' EB      	                ex de, hl
1275: 7706+10	06D9' D1      	                pop de
1276:				; HL - address of last slot in buffer
1277:				; DE - disassembly address
1278:				; Insert the new instruction address.
1279: 7716+7	06DA' 73      	                ld (hl), e
1280: 7723+6	06DB' 23      	                inc hl
1281: 7729+7	06DC' 72      	                ld (hl), d
1282:				; DE - disassembly address.
1283: 7736+4	06DD' EB      	                ex de, hl
1284: 7740+12	06DE' 18DE    	                jr disr_align_lp
1285:				;
1286:				; Now dr_inst_add_buf contains the start addresses of the last DIS_PRE_INSTRS
1287:				; instructions. Display them.
1288: 7752+10	06E0' 215B00  	disr_align_dn   ld hl, dr_inst_add_buf
1289: 7762+7	06E3' 0602    	                ld b, DIS_PRE_INSTRS
1290: 7769+7	06E5' 5E      	disr_disp_prelp ld e, (hl)
1291: 7776+6	06E6' 23      	                inc hl
1292: 7782+7	06E7' 56      	                ld d, (hl)
1293: 7789+6	06E8' 23      	                inc hl
1294: 7795+4	06E9' EB      	                ex de, hl               ; Move instruction address to HL
1295:				; DE - address in dr_inst_add_buf
1296:				; HL - instruction address
1297: 7799+7	06EA' 3E20    	                ld a, ' '               ; Make space for current PC marker
1298: 7806+17	06EC' CD0000  	                call conwch             ; Write character
1299: 7823+17	06EF' CD0000  	                call diproc             ; Disassemble instruction to intermediate form
1300: 7840+17	06F2' CD0000  	                call diprnt             ; Print the result
1301: 7857+17	06F5' CD0000  	                call cwnwln             ; New line
1302: 7874+4	06F8' EB      	                ex de, hl               ; Move buffer address back to HL
1303: 7878+8+5	06F9' 10EA    	                djnz disr_disp_prelp
1304:				; Now display the next DIS_POST_INSTRS + 1 (one is for the current PC). At this point,
1305:				; we load the user PC so this disassembled instruction is guaranteed to align with it.
1306:				; Previous instruction alignment does not guarantee this, especially if the bytes
1307:				; preceeding the PC aren't executable code. This means there may be a discontinuity
1308:				; at this point.
1309: 7886+16	06FB' 2A6D01  	disr_disp_curnt ld hl, (mstate + MST_PC)
1310: 7902+7	06FE' 0603    	                ld b, DIS_PRE_INSTRS + 1
1311: 7909+7	0700' 0E2A    	                ld c, '*'               ; Marker for current PC
1312: 7916+4	0702' 79      	disr_disp_polp  ld a, c
1313: 7920+17	0703' CD0000  	                call conwch             ; Write character
1314: 7937+7	0706' 0E20    	                ld c, ' '               ; Further lines will have a space
1315: 7944+17	0708' CD0000  	                call diproc             ; Disassemble instruction to intermediate form
1316: 7961+17	070B' CD0000  	                call diprnt             ; Print the result
1317: 7978+17	070E' CD0000  	                call cwnwln             ; New line
1318: 7995+8+5	0711' 10EF    	                djnz disr_disp_polp
1319: 8003+10	0713' C9      	                ret
1320:				;
1321:				; Display AF, BC, DE and HL. This is called by the exception handling code
1322:				; for both normal and alternate register sets.
1323:				; Call with:
1324:				; HL - points to next message text
1325:				; DE - points to next register in the machine state
1326:				; Returns with:
1327:				; HL - points to next message text
1328:				; DE - points to next register in the machine state
1329:				; A register
1330:				; BC register is not preserved.
1331: 8013+6	0714' 13      	dr_reg_set      inc de                  ; Point to A (high byte of AF)
1332: 8019+17	0715' CD4207  	                call dr_8               ; Display A register
1333:				; Flags
1334: 8036+17	0718' CD0000  	                call conwms             ; Print next part of text
1335: 8053+4	071B' EB      	                ex de, hl
1336: 8057+7	071C' 7E      	                ld a, (hl)
1337: 8064+7	071D' E6D7    	                and 11010111b           ; Mask out "not used" flags
1338: 8071+4	071F' 4F      	                ld c, a
1339:				; Write flags state.
1340: 8075+7	0720' 0608    	                ld b, 8
1341: 8082+11	0722' E5      	                push hl                 ; Save register data pointer
1342: 8093+10	0723' 218709  	                ld hl, dr_flg_names     ; Point to list of flag names (letters)
1343:				; B - bit counter
1344:				; C - flags register
1345:				; HL - pointer to names
1346:				; DE - pointer to message text
1347: 8103+8	0726' CB11    	dr_flg_loop     rl c                    ; Rotate next bit into carry
1348: 8111+7+5	0728' 3804    	                jr c, dr_flg_set
1349: 8118+7	072A' 3E2E    	                ld a, '.'
1350: 8125+12	072C' 1801    	                jr dr_flg_disp
1351:				; Flag is set, so write its name
1352: 8137+7	072E' 7E      	dr_flg_set      ld a, (hl)
1353: 8144+17	072F' CD0000  	dr_flg_disp     call conwch             ; Write character
1354: 8161+6	0732' 23      	dr_flg_done     inc hl
1355: 8167+8+5	0733' 10F1    	                djnz dr_flg_loop
1356:				; Flags written
1357: 8175+10	0735' E1      	                pop hl                  ; Restore register data pointer
1358: 8185+4	0736' EB      	                ex de, hl
1359:				; DE - points to flags (F part of AF).
1360: 8189+6	0737' 1B      	                dec de                  ; Point to BC
1361: 8195+6	0738' 1B      	                dec de
1362: 8201+6	0739' 23      	                inc hl                  ; Step past message terminator
1363:				; Now do BC, DE and HL.
1364: 8207+7	073A' 0603    	                ld b, 3
1365: 8214+17	073C' CD4E07  	dr_lp           call dr_16
1366: 8231+8+5	073F' 10FB    	                djnz dr_lp
1367: 8239+10	0741' C9      	                ret
1368:				;
1369:				;
1370:				; Display an 8-bit register in hexadecimal with associated text.
1371:				; This is called by the exception handling code.
1372:				; Call with:
1373:				; HL - points to next message text
1374:				; DE - points to next register in the machine state
1375:				; Returns with:
1376:				; HL - updated message pointer (i.e. incremented)
1377:				; DE - updated register pointer (i.e. decremented)
1378: 8249+17	0742' CD0000  	dr_8            call conwms             ; Print next part of text
1379: 8266+4	0745' EB      	                ex de, hl
1380: 8270+7	0746' 7E      	                ld a, (hl)
1381: 8277+17	0747' CD0000  	                call cwphby             ; Print byte
1382: 8294+4	074A' EB      	                ex de, hl
1383: 8298+6	074B' 23      	                inc hl                  ; Step past message terminator
1384: 8304+6	074C' 1B      	                dec de                  ; Point to next item
1385: 8310+10	074D' C9      	                ret
1386:				;
1387:				;
1388:				; Display a 16-bit register in hexadecimal with associated text.
1389:				; This is called by the exception handling code.
1390:				; Call with:
1391:				; HL - points to next message text
1392:				; DE - points to next register in the machine state
1393:				; Returns with:
1394:				; HL - updated message pointer (i.e. incremented)
1395:				; DE - updated register pointer (i.e. decremented twice)
1396: 8320+17	074E' CD0000  	dr_16           call conwms             ; Print next part of text
1397: 8337+6	0751' 13      	                inc de                  ; Point to MS byte
1398: 8343+4	0752' EB      	                ex de, hl
1399: 8347+7	0753' 7E      	                ld a, (hl)              ; High byte
1400: 8354+17	0754' CD0000  	                call cwphby             ; Print byte
1401: 8371+6	0757' 2B      	                dec hl
1402: 8377+7	0758' 7E      	                ld a, (hl)              ; Low byte
1403: 8384+17	0759' CD0000  	                call cwphby             ; Print byte
1404: 8401+4	075C' EB      	                ex de, hl
1405: 8405+6	075D' 23      	                inc hl                  ; Step past message terminator
1406: 8411+6	075E' 1B      	                dec de                  ; Point to next item
1407: 8417+6	075F' 1B      	                dec de
1408: 8423+10	0760' C9      	                ret
1409:				;
1410:				;
1411:				; Initialise console I/O.
1412:				; Write some nulls to initialise console output.
1413: 8433+7	0761' 060A    	con_init_basic  ld b, 10
1414: 8440+4	0763' AF      	init_null_lp    xor a
1415: 8444+17	0764' CD0000  	                call conwch
1416: 8461+8+5	0767' 10FA    	                djnz init_null_lp
1417: 8469+10	0769' C9      	                ret
1418:				;
1419:				;
1420:				; Read 16-bit word from user space. Call with:
1421:				; HL - pointer
1422:				; Return with:
1423:				; DE - data
1424:				; HL - preserved
1425: 8479+17	076A' CD7507  	ruswd           call rusby              ; Fetch LSB
1426: 8496+4	076D' 5F      	                ld e, a
1427: 8500+6	076E' 23      	                inc hl
1428: 8506+17	076F' CD7507  	                call rusby              ; Fetch MSB
1429: 8523+4	0772' 57      	                ld d, a
1430: 8527+6	0773' 2B      	                dec hl
1431: 8533+10	0774' C9      	                ret
1432:				;
1433:				;
1434:				; Read byte from user space. Call with:
1435:				; HL - pointer
1436:				; Return with:
1437:				; A - data
1438:				; HL - preserved
1439: 8543+11	0775' E5      	rusby           push hl
1440: 8554+17	0776' CD9507  	                call map_user_addr      ; Map address to bank 3
1441: 8571+7	0779' 7E      	                ld a, (hl)              ; Fetch required byte
1442: 8578+10	077A' E1      	                pop hl
1443: 8588+10	077B' C9      	                ret
1444:				;
1445:				;
1446:				; Write 16-bit word to user space. Write protection is honoured as for wusby.
1447:				; No attempt is made to write the MS byte if the LS byte write fails.
1448:				; Call with:
1449:				; DE - data
1450:				; HL - pointer
1451:				; Returns with:
1452:				; HL - preserved
1453:				; Carry flag is set if the write failed due to write protection (MMAP_PROT set).
1454: 8598+4	077C' 7B      	wuswd           ld a, e
1455: 8602+17	077D' CD8907  	                call wusby              ; Write LSB
1456: 8619+7+5	0780' 3806    	                jr c, wuswd_wr_done     ; Jump if write protected
1457: 8626+6	0782' 23      	                inc hl
1458: 8632+4	0783' 7A      	                ld a, d
1459: 8636+17	0784' CD8907  	                call wusby              ; Write MSB
1460: 8653+6	0787' 2B      	                dec hl
1461: 8659+10	0788' C9      	wuswd_wr_done   ret                     ; Exit with error status in carry
1462:				;
1463:				;
1464:				; Write byte to user space. Write protection is honoured. This avoids write
1465:				; protection NMI violations from within the monitor. These would overwrite the
1466:				; user machine state and confuse things.
1467:				; Call with:
1468:				; A - data
1469:				; HL - pointer
1470:				; Returns with:
1471:				; HL - preserved
1472:				; Carry flag is set if the write failed due to write protection (MMAP_PROT set).
1473: 8669+11	0789' C5      	wusby           push bc
1474: 8680+4	078A' 4F      	                ld c, a                 ; Save data
1475: 8684+11	078B' E5      	                push hl
1476: 8695+17	078C' CD9507  	                call map_user_addr      ; Map address to bank 3
1477: 8712+7+5	078F' 3801    	                jr c, wusby_wr_done     ; Jump if write protected
1478: 8719+7	0791' 71      	                ld (hl), c              ; Store byte
1479:				; Exit with error flag in carry from map_user_addr.
1480: 8726+10	0792' E1      	wusby_wr_done   pop hl
1481: 8736+10	0793' C1      	                pop bc
1482: 8746+10	0794' C9      	                ret                     ; Exit with error status in carry
1483:				;
1484:				;
1485:				; Map address to bank 3. Call with:
1486:				; HL - address
1487:				; Returns with:
1488:				; HL - pointer to required address in bank 3.
1489:				; Carry flag is set if the bank is write protected (MMAP_PROT set).
1490: 8756+11	0795' E5      	map_user_addr   push hl
1491: 8767+13	0796' 3A6601  	                ld a, (mstate + MST_MMAP_EN)    ; Non-zero if memory mapping enabled
1492: 8780+4	0799' A7      	                and a
1493: 8784+7+5	079A' 2004    	                jr nz, mua_mapped
1494:				; Memory mapping is disabled. In this state, only page 0x3f is available.
1495: 8791+7	079C' 3EFF    	                ld a, 0xff              ; Emulate hardware pull-up resistors
1496: 8798+12	079E' 180F    	                jr mua_have_page
1497:				;
1498:				; Memory mapping is enabled (normal state).
1499: 8810+4	07A0' 7C      	mua_mapped      ld a, h                 ; Bits 15 and 14 are the bank number
1500: 8814+4	07A1' 07      	                rlca
1501: 8818+4	07A2' 07      	                rlca
1502: 8822+7	07A3' E603    	                and 3
1503:				; A - bank number in user space.
1504:				; Find the appropriate bank in the machine state.
1505: 8829+10	07A5' 216701  	                ld hl, mstate + MST_MMAP0
1506: 8839+4	07A8' 85      	                add l
1507: 8843+4	07A9' 6F      	                ld l, a
1508: 8847+4	07AA' 7C      	                ld a, h
1509: 8851+7	07AB' CE00    	                adc 0
1510: 8858+4	07AD' 67      	                ld h, a
1511: 8862+7	07AE' 7E      	                ld a, (hl)              ; Fetch page
1512:				; PROT and SUPER bits are set unaltered.
1513: 8869+11	07AF' D307    	mua_have_page   out (IOA_MMAP_3), a
1514: 8880+10	07B1' E1      	                pop hl                  ; Restore the address
1515: 8890+11	07B2' F5      	                push af                 ; Save page
1516:				; Find the address as it appears in bank 3.
1517: 8901+4	07B3' 7C      	                ld a, h
1518: 8905+7	07B4' E63F    	                and (high MMAP_PAGE_SIZE) - 1   ; Clear bank bits
1519: 8912+7	07B6' F6C0    	                or high MMAP_BANK3_START ; Set to bank 3
1520: 8919+4	07B8' 67      	                ld h, a
1521: 8923+10	07B9' F1      	                pop af                  ; Restore page
1522: 8933+7	07BA' E680    	                and MMAP_PROT_MASK
1523: 8940+5+6	07BC' C8      	                ret z                   ; Exit with carry clear if R/W
1524: 8945+4	07BD' 37      	                scf                     ; Indicate write protection
1525: 8949+10	07BE' C9      	mua_exit        ret                     ; Return with carry clear
1526:				;
1527:				;
1528:				;
1529:				; *************
1530:				; * Constants *
1531:				; *************
1532:				;
1533:				
1534:     -	07BF' 5F5F5F5F	zarc_msg        byte "____  __  ___   ___", 0x0d, 0x0a
	              20205F5F
	              20205F5F
	              5F202020
	              5F5F5F0D
	              0A
1535:     -	07D4' 2020202F	                byte "   / /  \ |  \ /", 0x0d, 0x0a
	              202F2020
	              5C207C20
	              205C202F
	              0D0A
1536:     -	07E6' 20202F20	                byte "  /  |__| |__/ |", 0x0d, 0x0a
	              207C5F5F
	              7C207C5F
	              5F2F207C
	              0D0A
1537:     -	07F8' 202F2020	                byte " /   |  | |  \ |", 0x0d, 0x0a
	              207C2020
	              7C207C20
	              205C207C
	              0D0A
1538:     -	080A' 2F5F5F5F	                byte "/___ |  | |  | \___", 0x0d, 0x0a, 0x0d, 0x0a, 0
	              207C2020
	              7C207C20
	              207C205C
	              5F5F5F0D
	              0A0D0A00
1539:     -	0822' 5A415243	signon_msg      byte "ZARC Monitor V1.0", 0x0d, 0x0a, 0
	              204D6F6E
	              69746F72
	              2056312E
	              300D0A00
1540:     -	0836' 0D0A2A2A	cold_start_msg  byte 0x0d, 0x0a, "*** Cold start ***", 0
	              2A20436F
	              6C642073
	              74617274
	              202A2A2A
	              00
1541:     -	084B' 3E2000  	cmd_prompt      byte "> ", 0
1542:				;
1543:				; Default exception handler messages
1544:     -	084E' 0D0A2A2A	xpt_pre_msg     byte 0x0d, 0x0a, "*** ", 0
	              2A2000
1545:     -	0855' 456E7465	xpt_desc_msgs   byte "Enter Monitor|RST 08|RST 10|RST 18|"
	              72204D6F
	              6E69746F
	              727C5253
	              54203038
	              7C525354
	              2031307C
	              52535420
	              31387C
1546:     -	0878' 52535420	                byte "RST 20|RST 28|RST 30|RST 38|"
	              32307C52
	              53542032
	              387C5253
	              54203330
	              7C525354
	              2033387C
1547:     -	0894' 4E4D497C	                byte "NMI|System panic", 0
	              53797374
	              656D2070
	              616E6963
	              00
1548:     -	08A5' 20286672	xpt_sw_msg      byte " (front panel)", 0
	              6F6E7420
	              70616E65
	              6C2900
1549:     -	08B4' 20287772	xpt_prot_msg    byte " (write protection)", 0
	              69746520
	              70726F74
	              65637469
	              6F6E2900
1550:     -	08C8' 20286E6F	xpt_super_msg   byte " (not supervisor)", 0
	              74207375
	              70657276
	              69736F72
	              2900
1551:     -	08DA' 20287472	xpt_trace_msg   byte " (trace [single step])", 0
	              61636520
	              5B73696E
	              676C6520
	              73746570
	              5D2900
1552:     -	08F1' 202A2A2A	xpt_post_msg    byte " ***", 0x0d, 0x0a, 0
	              0D0A00
1553:     -	08F8' 413A2000	xpt_regs_msg    byte "A: ", 0
1554:     -	08FC' 2C20463A	                byte ", F: (", 0
	              202800
1555:     -	0903' 292C2042	                byte "), BC: ", 0
	              433A2000
1556:     -	090B' 2C204445	                byte ", DE: ", 0
	              3A2000
1557:     -	0912' 2C20484C	                byte ", HL: ", 0
	              3A2000
1558:     -	0919' 0D0A4127	                byte 0x0d, 0x0a, "A': ", 0
	              3A2000
1559:     -	0920' 2C204627	                byte ", F': (", 0
	              3A202800
1560:     -	0928' 292C2042	                byte "), BC': ", 0
	              43273A20
	              00
1561:     -	0931' 2C204445	                byte ", DE': ", 0
	              273A2000
1562:     -	0939' 2C20484C	                byte ", HL': ", 0
	              273A2000
1563:     -	0941' 0D0A5043	                byte 0x0d, 0x0a, "PC: ", 0
	              3A2000
1564:     -	0948' 2C205350	                byte ", SP: ", 0
	              3A2000
1565:     -	094F' 2C204958	                byte ", IX: ", 0
	              3A2000
1566:     -	0956' 2C204959	                byte ", IY: ", 0
	              3A2000
1567:     -	095D' 2C20493A	                byte ", I: ", 0
	              2000
1568:     -	0963' 2C20523A	                byte ", R: ", 0
	              2000
1569:     -	0969' 0D0A4945	                byte 0x0d, 0x0a, "IEn: ", 0
	              6E3A2000
1570:     -	0971' 2C204D4D	                byte ", MMap: ", 0
	              61703A20
	              00
1571:     -	097A' 0D0A5374	                byte 0x0d, 0x0a, "Stack:", 0
	              61636B3A
	              00
1572:     -	0983' 6F666600	dr_off_msg      byte "off", 0
1573:     -	0987' 535A2E48	dr_flg_names    byte "SZ.H.VNC"
	              2E564E43
1574:     -	098F' 0D0A4361	tr_map_msg      byte 0x0d, 0x0a, "Can't trace without mapping.", 0x0d, 0x0a, 0
	              6E277420
	              74726163
	              65207769
	              74686F75
	              74206D61
	              7070696E
	              672E0D0A
	              00
1575:				;
1576:				;
1577:				;
1578:				; *************
1579:				; * Variables *
1580:				; *************
1581:				;
1582:				; Private monitor variables located in bank 1.
1583:				; Note: linker "-c" option is used, so no data is initialised here.
1584:				                dseg                ; Data segment
1585:				;
1586:     -	0000"         	warm1           defs 1              ; Warm start marker 1
1587:				;
1588:     -	0001"         	mscnt           defs 2              ; Reset counter
1589:     -	0003"         	cmd_buf         defs CMD_BUF_SIZE   ; Command buffer
1590:     -	0053"         	cmd_len         defs 1              ; Current command length
1591:     -	0054"         	tikdiv          defs 1              ; Tick divider
1592:     -	0055"         	xpt_id          defs 1              ; Exception ID
1593:     -	0056"         	mcspd           defs 2              ; Approximate CPU speed in KHz
1594:     -	0058"         	trace_mode      defs 1              ; Trace mode (TRM_xxx)
1595:     -	0059"         	trace_addr      defs 2              ; Trace to address
1596:     -	005B"         	dr_inst_add_buf defs 2 * DIS_PRE_INSTRS ; Instruction start address buffer
1597:     -	005F"         	rst_flag        defs 1              ; Reset flag
1598:     -	0060"         	run_ctrl        defs 1              ; Pre-calculated CONTROL register value
1599:     -	0061"         	cmd_history     defs CMD_HIST_SIZE  ; Commands history
1600:     -	0161"         	cmd_hist_iptr   defs 2              ; Pointer to next space in cmd_history
1601:     -	0163"         	cmd_hist_optr   defs 2              ; Pointer to command for recall in cmd_history
1602:				; User machine state.
1603:     -	0165"         	mstate          defs MST_SIZE       ; Machine state structure
1604:				;
1605:				; Stacks
1606:     -	0185"         	                defs STACKS_SIZE
1607:     -	01C5"         	mon_stack_p1                        ; Monitor stack + 1
1608:     -	01C5"         	warm2           defs 1              ; Warm start marker 2
1609:				;
1610:     -	01C6"         	                end



Statistics:

     4	passes
     0	jr promotions
   734	symbols
  2381	bytes

   318	macro calls
  1320	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
CCP_START      =D600      54784
CDISK          =04        4
CMD_BUF_SIZE   =50        80
CMD_HIST_SIZE  = 100      256
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DIS_BUF_SIZE   =10        16
DIS_MAX_INSTLEN=04        4
DIS_POST_INSTRS=02        2
DIS_PRE_INSTRS =02        2
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
HEAP_TOP       =7FFF      32767
I2C_CSR_ACKN_BIT=00        0
I2C_CSR_ACKN_MASK=01        1
I2C_CSR_BUSY_BIT=07        7
I2C_CSR_BUSY_MASK=80        128
I2C_CSR_START_BIT=01        1
I2C_CSR_START_MASK=02        2
I2C_CSR_STOP_BIT=02        2
I2C_CSR_STOP_MASK=04        4
INTS_NUM       =08        8
INT_SER1_RX_BIT=01        1
INT_SER1_RX_MASK=02        2
INT_SER1_RX_VEC=01        1
INT_SER1_TX_BIT=00        0
INT_SER1_TX_MASK=01        1
INT_SER1_TX_VEC=00        0
INT_SER2_RX_BIT=03        3
INT_SER2_RX_MASK=08        8
INT_SER2_RX_VEC=03        3
INT_SER2_TX_BIT=02        2
INT_SER2_TX_MASK=04        4
INT_SER2_TX_VEC=02        2
INT_TICK_BIT   =04        4
INT_TICK_MASK  =10        16
INT_TICK_VEC   =04        4
INT_VEC_TABLE  =FFE0      65504
IOA_CONTROL    =02        2
IOA_CRC_0      =24        36
IOA_CRC_1      =25        37
IOA_CRC_DATA   =26        38
IOA_FPGA_MAJREV=00        0
IOA_FPGA_MINREV=01        1
IOA_FP_SW      =03        3
IOA_I2C_CSR    =18        24
IOA_I2C_DATA   =19        25
IOA_INT_EN     =08        8
IOA_INT_PEND   =0A        10
IOA_MMAP_0     =04        4
IOA_MMAP_1     =05        5
IOA_MMAP_2     =06        6
IOA_MMAP_3     =07        7
IOA_NMI_REASONS=0C        12
IOA_SER1_CSR   =10        16
IOA_SER1_DATA  =11        17
IOA_SER2_CSR   =12        18
IOA_SER2_DATA  =13        19
IOA_SPI_CSR    =20        32
IOA_SPI_DATA   =21        33
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MCCAS_CSUM     =04        4
MCCAS_DATA     =06        6
MCCAS_SECTOR   =01        1
MCCAS_SIZE     = 206      518
MCCAS_STATUS   =00        0
MCCAS_STAT_CPM0_BIT=00        0
MCCAS_STAT_CPM0_MASK=01        1
MCCAS_STAT_CPM1_BIT=01        1
MCCAS_STAT_CPM1_MASK=02        2
MCCAS_STAT_CPM2_BIT=02        2
MCCAS_STAT_CPM2_MASK=04        4
MCCAS_STAT_CPM3_BIT=03        3
MCCAS_STAT_CPM3_MASK=08        8
MCCAS_STAT_DIRT_MASK=0F        15
MCCAS_STAT_VALID_BIT=04        4
MCCAS_STAT_VALID_MASK=10        16
MCCA_BUFFERS   =10        16
MCCA_DIRT_THRES=08        8
MC_STATES      =02        2
MMAP_BANK0_END =3FFF      16383
MMAP_BANK0_START=00        0
MMAP_BANK1_END =7FFF      32767
MMAP_BANK1_START=4000      16384
MMAP_BANK2_END =BFFF      49151
MMAP_BANK2_START=8000      32768
MMAP_BANK3_END =FFFF      65535
MMAP_BANK3_START=C000      49152
MMAP_BANKS     =04        4
MMAP_CPM_PAGES =04        4
MMAP_MON_B0_PAGE=3F        63
MMAP_MON_B1_PAGE=3E        62
MMAP_PAGES     =40        64
MMAP_PAGE_MASK =3F        63
MMAP_PAGE_SIZE =4000      16384
MMAP_PROT_BIT  =07        7
MMAP_PROT_MASK =80        128
MMAP_SUPER_BIT =06        6
MMAP_SUPER_MASK=40        64
MMC_ACMD_MC_SEND_OP_COND=29        41
MMC_ARG1       =01        1
MMC_ARG2       =02        2
MMC_ARG3       =03        3
MMC_ARG4       =04        4
MMC_CID_CRC    =0F        15
MMC_CID_MDT    =0E        14
MMC_CID_MID    =00        0
MMC_CID_OID    =01        1
MMC_CID_PNM    =03        3
MMC_CID_PNM_SIZE=06        6
MMC_CID_PRV    =09        9
MMC_CID_PSN    =0A        10
MMC_CID_SIZE   =10        16
MMC_CMD        =00        0
MMC_CMD_APP_CMD=37        55
MMC_CMD_CRC_ON_OFF=3B        59
MMC_CMD_GO_IDLE_STATE=00        0
MMC_CMD_READ_SINGLE_BLOCK=11        17
MMC_CMD_SEND_CID=0A        10
MMC_CMD_SEND_CSD=09        9
MMC_CMD_SEND_OP_COND=01        1
MMC_CMD_SEND_STATUS=0D        13
MMC_CMD_SET_BLOCKLEN=10        16
MMC_CMD_START  =40        64
MMC_CMD_STOP   =01        1
MMC_CMD_WRITE_BLOCK=18        24
MMC_CRC        =05        5
MMC_CSD_15_8   =0E        14
MMC_CSD_23_16  =0D        13
MMC_CSD_31_24  =0C        12
MMC_CSD_39_32  =0B        11
MMC_CSD_47_40  =0A        10
MMC_CSD_55_48  =09        9
MMC_CSD_63_56  =08        8
MMC_CSD_71_64  =07        7
MMC_CSD_79_72  =06        6
MMC_CSD_87_80  =05        5
MMC_CSD_95_88  =04        4
MMC_CSD_CRC    =0F        15
MMC_CSD_NSAC   =02        2
MMC_CSD_SIZE   =10        16
MMC_CSD_TAAC   =01        1
MMC_CSD_TR_SPD =03        3
MMC_CSD_VERSION=00        0
MMC_LOG2_SEC_SIZE=09        9
MMC_R1_ADDR_ERR_BIT=05        5
MMC_R1_ADDR_ERR_MASK=20        32
MMC_R1_CMD_CRC_ERR_BIT=03        3
MMC_R1_CMD_CRC_ERR_MASK=08        8
MMC_R1_ERA_RST_BIT=01        1
MMC_R1_ERA_RST_MASK=02        2
MMC_R1_ERA_SEQ_ERR_BIT=04        4
MMC_R1_ERA_SEQ_ERR_MASK=10        16
MMC_R1_IDLE_BIT=00        0
MMC_R1_IDLE_MASK=01        1
MMC_R1_ILL_CMD_BIT=02        2
MMC_R1_ILL_CMD_MASK=04        4
MMC_R1_PAR_ERR_BIT=06        6
MMC_R1_PAR_ERR_MASK=40        64
MMC_R1_START_BIT=07        7
MMC_R1_START_MASK=80        128
MMC_SECTOR_SIZE= 200      512
MMC_SIZE       =06        6
MMC_STAT_IDLE  =00        0
MMC_STAT_INIT  =01        1
MPA_NAME_LEN   =04        4
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MS_PER_TICK    =64        100
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NMI_PROT_VIOL_BIT=01        1
NMI_PROT_VIOL_MASK=02        2
NMI_REASONS_ALL=0F        15
NMI_REASONS_NUM=04        4
NMI_SUPER_VIOL_BIT=02        2
NMI_SUPER_VIOL_MASK=04        4
NMI_SWITCH_BIT =00        0
NMI_SWITCH_MASK=01        1
NMI_TRACE_BIT  =03        3
NMI_TRACE_MASK =08        8
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
PORT_SER1      =00        0
PORT_SER2      =01        1
PORT_STATES    =02        2
SER_CSR_FRAME_ERR_BIT=03        3
SER_CSR_FRAME_ERR_MASK=08        8
SER_CSR_RX_ALHALF_BIT=01        1
SER_CSR_RX_ALHALF_MASK=02        2
SER_CSR_RX_EMPTY_BIT=00        0
SER_CSR_RX_EMPTY_MASK=01        1
SER_CSR_RX_FULL_BIT=02        2
SER_CSR_RX_FULL_MASK=04        4
SER_CSR_TX_ALHALF_BIT=05        5
SER_CSR_TX_ALHALF_MASK=20        32
SER_CSR_TX_EMPTY_BIT=04        4
SER_CSR_TX_EMPTY_MASK=10        16
SER_CSR_TX_FULL_BIT=06        6
SER_CSR_TX_FULL_MASK=40        64
SPI_CSR_BUSY_BIT=07        7
SPI_CSR_BUSY_MASK=80        128
SPI_CSR_FAST_BIT=00        0
SPI_CSR_FAST_MASK=01        1
SPI_CSR_MC_SS_BIT=01        1
SPI_CSR_MC_SS_MASK=02        2
SPI_ERR_BADCRC =04        4
SPI_ERR_BADINIT=03        3
SPI_ERR_BADSEC =05        5
SPI_ERR_BAD_R1 =08        8
SPI_ERR_BAD_R2 =09        9
SPI_ERR_BUSY   =01        1
SPI_ERR_DATAERR=07        7
SPI_ERR_HEAP   =0A        10
SPI_ERR_NORESP =02        2
SPI_ERR_NUM    =0E        14
SPI_ERR_OK     =00        0
SPI_ERR_RANGE  =06        6
SPI_ERR_TIMEOUT=0B        11
SPI_ERR_UNKN   =0D        13
SPI_ERR_WRITE  =0C        12
STACKS_SIZE    =40        64
SYSCTRL_MAPARM_BIT=03        3
SYSCTRL_MAPARM_MASK=08        8
SYSCTRL_MMAPN_BIT=04        4
SYSCTRL_MMAPN_MASK=10        16
SYSCTRL_MMAP_BIT=01        1
SYSCTRL_MMAP_MASK=02        2
SYSCTRL_NMCLR_BIT=02        2
SYSCTRL_NMCLR_MASK=04        4
SYSCTRL_RESERVED_BIT=07        7
SYSCTRL_RESERVED_MASK=80        128
SYSCTRL_TRARM_BIT=00        0
SYSCTRL_TRARM_MASK=01        1
SYSCTRL_TRPRE0_BIT=05        5
SYSCTRL_TRPRE0_MASK=20        32
SYSCTRL_TRPRE1_BIT=06        6
SYSCTRL_TRPRE1_MASK=40        64
TICK_FREQ      =0A        10
TIM_EPOCH_YEAR =46        70
TMDST_DST      =02        2
TMDST_GMT      =01        1
TMDST_NUM      =03        3
TMDST_UNKNOWN  =00        0
TM_DST         =09        9
TM_HOURS       =02        2
TM_MDAY        =03        3
TM_MINS        =01        1
TM_MON         =04        4
TM_SECS        =00        0
TM_SIZE        =0A        10
TM_WDAY        =06        6
TM_YDAY        =07        7
TM_YEAR        =05        5
TPA_START      = 100      256
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
WARM_MAGIC_1   =55        85
WARM_MAGIC_2   =AA        170
XPTT_CNT       =0A        10
XPTT_MON_ENT   =00        0
XPTT_NMI       =08        8
XPTT_PANIC     =09        9
XPTT_RST08     =01        1
XPTT_RST10     =02        2
XPTT_RST18     =03        3
XPTT_RST20     =04        4
XPTT_RST28     =05        5
XPTT_RST30     =06        6
XPTT_RST38     =07        7
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
cacold          00        0 (extern)
cacrs           00        0 (extern)
cacws           00        0 (extern)
caflus          00        0 (extern)
carpt           00        0 (extern)
cars            00        0 (extern)
cawarm          00        0 (extern)
caws            00        0 (extern)
cmd_buf         03"       3
cmd_hist_iptr    161"     353
cmd_hist_optr    163"     355
cmd_history     61"       97
cmd_len         53"       83
cmd_prompt       84B'     2123
cmd_recall       2CC'     716
cold_start_msg   836'     2102
con_init_basic   761'     1889
conrch          00        0 (extern)
consta          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
coport          00        0 (extern)
cpinit          00        0 (extern)
cpmem           00        0 (extern)
cppags          00        0 (extern)
cpuspd          00        0 (extern)
crc16x          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwptm           00        0 (extern)
cwvich          00        0 (extern)
default_nmi      4EC'     1260
default_rst08    468'     1128
default_rst10    475'     1141
default_rst18    487'     1159
default_rst20    498'     1176
default_rst28    4A8'     1192
default_rst30    4B9'     1209
default_rst38    4CA'     1226
diprnt          00        0 (extern)
diproc          00        0 (extern)
disr_align_dn    6E0'     1760
disr_align_lp    6BE'     1726
disr_dis_map_lp  67C'     1660
disr_disp_curnt  6FB'     1787
disr_disp_polp   702'     1794
disr_disp_prelp  6E5'     1765
disr_ien_dn      661'     1633
disr_mmap_dn     697'     1687
disr_mmap_en     677'     1655
disr_stk_loop    6A1'     1697
dr_16            74E'     1870
dr_8             742'     1858
dr_flg_disp      72F'     1839
dr_flg_done      732'     1842
dr_flg_loop      726'     1830
dr_flg_names     987'     2439
dr_flg_set       72E'     1838
dr_inst_add_buf 5B"       91
dr_lp            73C'     1852
dr_off_msg       983'     2435
dr_reg_set       714'     1812
enum_counter   =0A        10
except_hdlr      511'     1297
gc_check_end     2F7'     759
gc_cr            323'     803
gc_del_cmd       301'     769
gc_delete        270'     624
gc_do_del        30B'     779
gc_hist_copy_lp  33A'     826
gc_loop          23C'     572
gc_next          29A'     666
gc_prev          275'     629
gcn_abort        2BC'     700
gcn_findnext     29E'     670
gcn_fnd_term     2AD'     685
gcp_abort        297'     663
gcp_copy         2D1'     721
gcp_copy_done    2EF'     751
gcp_copy_loop    2DE'     734
gcp_findprev     284'     644
gcp_fnd_term     294'     660
get_cmd          223'     547
halloc          00        0 (extern)
hinit           00        0 (extern)
hist_val_ptr     351'     849
hvp_adj_good     36D'     877
hvp_set_end      368'     872
i2crd           00        0 (extern)
i2cwr           00        0 (extern)
ic_zero_lp       194'     404
init            F6'       246
init_cold        188'     392
init_ints_ok     211'     529
init_null_lp     763'     1891
init_signon      1EA'     490
init_skip_ban    1FC'     508
init_warm        1DD'     477
jptbl_addr     =7E        126
madbbu          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
main           =01        1
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
map_user_addr    795'     1941
mcexec          00        0 (extern)
mcinit          00        0 (extern)
mcprer          00        0 (extern)
mcrrs           00        0 (extern)
mcrun            370'     880 (public)
mcrws           00        0 (extern)
mcspd           56"       86 (public)
mcstat          00        0 (extern)
mdisrg           618'     1560 (public)
memtal          00        0 (extern)
memtst          00        0 (extern)
mmap_page0_ro    451'     1105
mmap_page0_rw    44C'     1100
mon_entry        456'     1110
mon_stack_p1     1C5"     453
monitor        =01        1
mpall           00        0 (extern)
mpfree          00        0 (extern)
mpinit          00        0 (extern)
mppnam          00        0 (extern)
mprpt           00        0 (extern)
mpstat          00        0 (extern)
mscnt           01"       1 (public)
mstate           165"     357 (public)
mtwdli          00        0 (extern)
mua_exit         7BE'     1982
mua_have_page    7AF'     1967
mua_mapped       7A0'     1952
panic            4DB'     1243 (public)
prpnam          00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
reset           00'       0
rst_flag        5F"       95
ru_keep_going    377'     887
run_cbed         3BF'     959
run_ctl_mmap_dn  383'     899
run_ctl_tr_dn    3C3'     963
run_ctrl        60"       96
run_ddfd         3AD'     941
run_ddfd_done    3B5'     949
run_ei           430'     1072
run_ints         3DB'     987
run_jump         431'     1073
run_ld_a         42E'     1070
run_ld_bc        42B'     1067
run_tr_map_ok    399'     921
rusby            775'     1909 (public)
ruswd            76A'     1898 (public)
s1rch           00        0 (extern)
s1sta           00        0 (extern)
s1wch           00        0 (extern)
s2rch           00        0 (extern)
s2sta           00        0 (extern)
s2wch           00        0 (extern)
signon_msg       822'     2082
skpspc          00        0 (extern)
spiini          00        0 (extern)
spiss           00        0 (extern)
spitr           00        0 (extern)
srvec_err        449'     1097
str_offset     = 206      518
tiitos          00        0 (extern)
tikdiv          54"       84 (public)
tird            00        0 (extern)
tistoi          00        0 (extern)
tiwr            00        0 (extern)
toloca          00        0 (extern)
toupca          00        0 (extern)
tr_map_msg       98F'     2447
trace_addr      59"       89
trace_mode      58"       88
trarch          00        0 (extern)
trawch          00        0 (extern)
trport          00        0 (extern)
utrivc           434'     1076
warm1           00"       0 (public)
warm2            1C5"     453
wusby            789'     1929 (public)
wusby_wr_done    792'     1938
wuswd            77C'     1916 (public)
wuswd_wr_done    788'     1928
xpt_desc_msgs    855'     2133
xpt_disp_reason  5B4'     1460
xpt_id          55"       85
xpt_int_dis      55E'     1374
xpt_not_emon     58E'     1422
xpt_notnmi       5FB'     1531
xpt_post_msg     8F1'     2289
xpt_pre_msg      84E'     2126
xpt_prot_msg     8B4'     2228
xpt_regs_msg     8F8'     2296
xpt_super_msg    8C8'     2248
xpt_sw_msg       8A5'     2213
xpt_tr_notyet    609'     1545
xpt_tr_to_addr   5A7'     1447
xpt_tr_xpt       610'     1552
xpt_trace_msg    8DA'     2266
zarc_msg         7BF'     1983
