   1:				; *******************************************************
   2:				; * ZARC Monitor Diagnostics Routines                   *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 3/8/2020                              *
   5:				; *******************************************************
   6:				;
   7:				; ZARC diagnostics routines.
   8:				;
   9:				; Routines preserve all registers not required as operands or return
  10:				; values except AF unless otherwise stated below.
  11:				;
  12:				;
  13:     -	0001'         	monitor         equ 1                   ; Flag part of monitor build
  14:     -	0001'         	diags           equ 1                   ; Flag module for includes
  15:				;
  16:				;
  17:				;
  18:				; ************
  19:				; * Includes *
  20:				; ************
  21:				;
  22:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				
**** diags.z80 ****
  23:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** diags.z80 ****
  24:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  18:     -	0001'         	                ifndef main         ; Inhibit for this module
  19:				; Constants
  20:				;
  21:				; Variables 
  22:				                extern tikcnt       ; Tick counter
  23:				;
  24:				; Functions
  25:				                extern panic        ; System error exception
  26:				                extern rusby        ; Read byte from user space
  27:				                extern ruswd        ; Read 16-bit word from user space
  28:				                extern wusby        ; Write byte to user space
  29:				                extern wuswd        ; Write 16-bit word to user space
  30:				;
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** diags.z80 ****
  25:				                include "zarc.i"        ; Hardware definitions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//zarc.i ****
   1:				; ***********************************
   2:				; * ZARC Definitions                *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 26/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the ZARC system.
   8:				;
   9:				;
  10:				; ************
  11:				; * Hardware *
  12:				; ************
  13:				;
  14:				; Interrupt vector numbers in INT_VEC_TABLE.
  15:				; Address is INT_VEC_TABLE + 2 * vector number).
  16:     -	0000'         	INT_SER1_TX_VEC     equ INT_SER1_TX_BIT ; Serial port 1 transmitter buffer is half full or less
  17:     -	0001'         	INT_SER1_RX_VEC     equ INT_SER1_RX_BIT ; Serial port 1 receiver has data
  18:     -	0002'         	INT_SER2_TX_VEC     equ INT_SER2_TX_BIT ; Serial port 2 transmitter buffer is half full or less
  19:     -	0003'         	INT_SER2_RX_VEC     equ INT_SER2_RX_BIT ; Serial port 2 receiver has data
  20:     -	0004'         	INT_TICK_VEC        equ INT_TICK_BIT    ; Regular timekeeping
  21:				;
  22:     -	0064'         	MS_PER_TICK         equ 100             ; ms per tick
  23:     -	000A'         	TICK_FREQ           equ 10              ; Tick rate in Hz
  24:				;
  25:				
**** diags.z80 ****
  26:				                include "io_map.i"      ; I/O addresses mapping
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io_map.i ****
   1:				; ***********************************
   2:				; * ZARC I/O Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 3/9/2019          *
   5:				; ***********************************
   6:				
   7:				; *** I/O register address mapping ***
   8:				
   9:				; This should be kept in sync with the Definitions.vhd package file.
  10:     -	0000'         	IOA_FPGA_MAJREV equ 0x00        ; FPGA major revision
  11:     -	0001'         	IOA_FPGA_MINREV equ 0x01        ; FPGA minor revision
  12:     -	0002'         	IOA_CONTROL     equ 0x02        ; System control register
  13:     -	0003'         	IOA_FP_SW       equ 0x03        ; Front panel data switches
  14:				
  15:				; Paging
  16:     -	0004'         	IOA_MMAP_0      equ 0x04        ; Page, supervisor and protection for bank 0 (0x0000 to 0x3fff)
  17:     -	0005'         	IOA_MMAP_1      equ 0x05        ; Page, supervisor and protection for bank 1 (0x4000 to 0x7fff)
  18:     -	0006'         	IOA_MMAP_2      equ 0x06        ; Page, supervisor and protection for bank 2 (0x8000 to 0xbfff)
  19:     -	0007'         	IOA_MMAP_3      equ 0x07        ; Page, supervisor and protection for bank 3 (0xc000 to 0xffff)
  20:				
  21:				; Interrupts
  22:				; Note: Up to eight interrupts are supported. IM 2 is anticipated, and the
  23:				; fixed vector associated with each interrupt is supplied when the interrupt
  24:				; is serviced. Routine address is “I*256+databus”. Vector supplied is
  25:				; 0xe0 + 2 * interrupt number (0 to 7).
  26:				; Note: addresses 0x09 and 0x0b reserved for use if more than eight interrupt
  27:				; sources are required.
  28:     -	0008'         	IOA_INT_EN      equ 0x08        ; Enables
  29:     -	000A'         	IOA_INT_PEND    equ 0x0a        ; Pending interrupts
  30:				;
  31:				;NMI
  32:     -	000C'         	IOA_NMI_REASONS equ 0x0c        ; NMI reasons flags
  33:				;
  34:				; Serial.
  35:     -	0010'         	IOA_SER1_CSR    equ 0x10        ; Port 1 control / status
  36:     -	0011'         	IOA_SER1_DATA   equ 0x11        ; Port 1 data
  37:     -	0012'         	IOA_SER2_CSR    equ 0x12        ; Port 2 serial control / status
  38:     -	0013'         	IOA_SER2_DATA   equ 0x13        ; Port 2 serial data
  39:				
  40:				; RTC (DS1672)
  41:				; I2C, implemented using a byte interface to the CPU. Writing to the data port
  42:				; shifts out a byte. Input puts are shifted into the “other end” of the same
  43:				; register.
  44:     -	0018'         	IOA_I2C_CSR     equ 0x18        ; Control
  45:     -	0019'         	IOA_I2C_DATA    equ 0x19        ; Data
  46:				;
  47:				; SD Card
  48:				; Uses SPI mode, with a generally similar interface to that of the I2C.
  49:     -	0020'         	IOA_SPI_CSR     equ 0x20        ; Control
  50:     -	0021'         	IOA_SPI_DATA    equ 0x21        ; Data
  51:				
  52:				; CRC16 / XMODEM and MultiMediaCard CRC16
  53:				; Write to the CRC register to set the initial value. Writing to the input
  54:				; data register updates the CRC.
  55:     -	0024'         	IOA_CRC_0       equ 0x24        ; CRC register (low)
  56:     -	0025'         	IOA_CRC_1       equ 0x25        ; CRC register (high)
  57:     -	0026'         	IOA_CRC_DATA    equ 0x26        ; Input data
  58:				
  59:				; *** Proposed features ***
  60:				; Video
  61:				;IOA_VID_CTRL    equ 0x30;       ; Control (cursor on/off ...)
  62:				;IOA_VID_DATA    equ 0x31;       ; Data
  63:				;IOA_VID_CUR_X   equ 0x32;       ; Cursor X (0 to 127)
  64:				;IOA_VID_CUR_Y   equ 0x33;       ; Cursor Y (0 to 63)
  65:				;IOA_VID_START_L equ 0x34        ; Display start address (low byte)
  66:				;IOA_VID_START_H equ 0x35        ; Display start address (high byte)
  67:				
  68:				; Video palette
  69:				; Each entry consists of 6 bits of colour data. Foreground and background
  70:				; colour pairs are selected from the above palette using eight of the 22
  71:				; control codes in the display character set. This leaves codes for
  72:				; double-height, double-width etc.
  73:				;IOA_VID_PALBG0  equ 0x40        ; Background colour 0
  74:				;IOA_VID_PALFG0  equ 0x41        ; Foreground colour 0
  75:				;IOA_VID_PALBG1  equ 0x42        ; Background colour 1
  76:				;IOA_VID_PALFG1  equ 0x43        ; Foreground colour 1
  77:				;IOA_VID_PALBG2  equ 0x44        ; Background colour 2
  78:				;IOA_VID_PALFG2  equ 0x45        ; Foreground colour 2
  79:				;IOA_VID_PALBG3  equ 0x46        ; Background colour 3
  80:				;IOA_VID_PALFG3  equ 0x47        ; Foreground colour 3
  81:				;IOA_VID_PALBG4  equ 0x48        ; Background colour 4
  82:				;IOA_VID_PALFG4  equ 0x49        ; Foreground colour 4
  83:				;IOA_VID_PALBG5  equ 0x4a        ; Background colour 5
  84:				;IOA_VID_PALFG5  equ 0x4b        ; Foreground colour 5
  85:				;IOA_VID_PALBG6  equ 0x4c        ; Background colour 6
  86:				;IOA_VID_PALFG6  equ 0x4d        ; Foreground colour 6
  87:				;IOA_VID_PALBG7  equ 0x4e        ; Background colour 7
  88:				;IOA_VID_PALFG7  equ 0x4f        ; Foreground colour 7
  89:				
  90:				; Arithmetic
  91:				; Multiply, divide … based on 68000 DIV, DIVU, MUL, MULU.
  92:				; Multiply does A[16] * B[16] => C[32].
  93:				; Divide does A[32] / B[16] => C[32] (16-bit remainder [high bits] and
  94:				; 16-bit quotient [low bits]).
  95:				; Status bits include “complete” and “overflow”.
  96:				;IOA_ARITH_A_L   equ 0x50        ; A register (low)
  97:				;IOA_ARITH_A_H   equ 0x51        ; A register (high)
  98:				;IOA_ARITH_B_L   equ 0x54        ; B register (low)
  99:				;IOA_ARITH_B_H   equ 0x57        ; B register (high)
 100:				;IOA_ARITH_C_0   equ 0x58        ; C register (low)
 101:				;IOA_ARITH_C_1   equ 0x59 
 102:				;IOA_ARITH_C_2   equ 0x5a
 103:				;IOA_ARITH_C_3   equ 0x5b        ; C register (high)
 104:				;IOA_ARITH_CSR   equ 0x5c        ; Command / status
 105:				
 106:				
 107:				; *** Register bits allocation ***
 108:				
 109:				; IOA_CONTROL register
 110:     -	        	BITDEF SYSCTRL_TRARM, 0         ; 1 arms the trace interrupt
 111:     -	        	BITDEF SYSCTRL_MMAP, 1          ; 1 enables memory mapping
 112:     -	        	BITDEF SYSCTRL_NMCLR, 2         ; NMI mapping clear
 113:     -	        	BITDEF SYSCTRL_MAPARM, 3        ; NMI out arm
 114:     -	        	BITDEF SYSCTRL_MMAPN, 4         ; State of MMAP when an NMI occurred
 115:     -	        	BITDEF SYSCTRL_TRPRE0, 5        ; Number of prefixes for trace
 116:     -	        	BITDEF SYSCTRL_TRPRE1, 6
 117:     -	        	BITDEF SYSCTRL_RESERVED, 7      ; Unused bit
 118:				;
 119:				; MMAP page registers
 120:     -	        	BITDEF MMAP_PROT, 7             ; Write protection
 121:     -	        	BITDEF MMAP_SUPER, 6            ; I/O enable
 122:     -	003F'         	MMAP_PAGE_MASK  equ 0x3f        ; RAM page number bits
 123:				;
 124:				; IOA_INT_EN and IOA_INT_PEND registers.
 125:     -	0008'         	INTS_NUM        equ 8           ; Number of possible interrupt sources
 126:     -	        	BITDEF INT_SER1_TX, 0           ; Serial port 1 transmitter buffer is half full or less
 127:     -	        	BITDEF INT_SER1_RX, 1           ; Serial port 1 receiver has data
 128:     -	        	BITDEF INT_SER2_TX, 2           ; Serial port 2 transmitter buffer is half full or less
 129:     -	        	BITDEF INT_SER2_RX, 3           ; Serial port 2 receiver has data
 130:     -	        	BITDEF INT_TICK, 4              ; Regular timekeeping
 131:				;
 132:				; IOA_NMI_REASONS register.
 133:     -	0004'         	NMI_REASONS_NUM equ 4           ; Number of reasons for an NMI
 134:     -	        	BITDEF NMI_SWITCH, 0;           ; Front panel switch
 135:     -	        	BITDEF NMI_PROT_VIOL, 1;        ; Write protection violation
 136:     -	        	BITDEF NMI_SUPER_VIOL, 2;       ; Supervisor violation
 137:     -	        	BITDEF NMI_TRACE, 3;            ; Debugger trace (single step)
 138:     -	000F'         	NMI_REASONS_ALL equ NMI_SWITCH_MASK + NMI_PROT_VIOL_MASK + NMI_SUPER_VIOL_MASK + NMI_TRACE_MASK
 139:				;
 140:				; Serial CSRs (IOA_SER1_CSR and IOA_SER2_CSR).
 141:     -	        	BITDEF SER_CSR_RX_EMPTY, 0      ; Receiver buffer is empty
 142:     -	        	BITDEF SER_CSR_RX_ALHALF, 1     ; Receiver buffer is at least half full
 143:     -	        	BITDEF SER_CSR_RX_FULL, 2       ; Receiver buffer is full
 144:     -	        	BITDEF SER_CSR_FRAME_ERR, 3     ; Framing error in last character
 145:     -	        	BITDEF SER_CSR_TX_EMPTY, 4      ; Transmitter buffer is empty
 146:     -	        	BITDEF SER_CSR_TX_ALHALF, 5     ; Transmitter buffer is at least half full
 147:     -	        	BITDEF SER_CSR_TX_FULL, 6       ; Transmitter buffer is full
 148:				; Bit 7 is not used.
 149:				;
 150:				; I2C (Inter-Integrated Circuit) master interface. Used for RTC (DS1672).
 151:				; Bits in IOA_I2C_CSR
 152:     -	        	BITDEF I2C_CSR_ACKN, 0          ; (Read / write) acknowledge from receiving device
 153:     -	        	BITDEF I2C_CSR_START, 1         ; (Write only) trigger start sequence
 154:     -	        	BITDEF I2C_CSR_STOP, 2          ; (Write only) trigger stop sequence
 155:     -	        	BITDEF I2C_CSR_BUSY, 7          ; (Read only) transceiver busy
 156:				;
 157:				; SPI (Serial Peripheral Interface) master interface. Used for memory card.
 158:				; Bits in IOA_SPI_CSR
 159:     -	        	BITDEF SPI_CSR_FAST, 0          ; (Read / write) SPI speed select
 160:     -	        	BITDEF SPI_CSR_MC_SS, 1         ; (Read / write) memory card slave select
 161:     -	        	BITDEF SPI_CSR_BUSY, 7          ; (Read only) transceiver busy
 162:				
**** diags.z80 ****
  27:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** diags.z80 ****
  28:				                include "io.i"          ; I/O routines
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io.i ****
   1:				; ***********************************
   2:				; * ZARC Basic I/O Extern Symbols   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and extern statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef io           ; Inhibit for this module
  16:				;
  17:				                ; Variables
  18:				                extern coport   ; Current console port (PRT_xxx)
  19:				                extern trport   ; Current data transfer port (PRT_xxx)
  20:				;
  21:				                ; Routines
  22:				                extern conwch   ; Write character to the console
  23:				                extern conrch   ; Read character from the console
  24:				                extern consta   ; Fetch console port status
  25:				                extern trawch   ; Write character to the data transfer port
  26:				                extern trarch   ; Read character from the data transfer port
  27:				                extern s1wch    ; Write character to serial port 1
  28:				                extern s1rch    ; Read character from serial port 1
  29:				                extern s1sta    ; Fetch serial port 1 status
  30:				                extern s2wch    ; Write character to serial port 2
  31:				                extern s2rch    ; Read character from serial port 2
  32:				                extern s2sta    ; Fetch serial port 2 status
  33:				                extern i2cwr    ; Write to I2C device
  34:				                extern i2crd    ; Read from I2C device
  35:				                extern spiini   ; Initialise SPI interface and set speed
  36:				                extern spiss    ; Set SPI slave select(s)
  37:				                extern spitr    ; Transfer byte to / from SPI device
  38:				;
  39:				                endif
  40:				            endif
  41:				;
  42:				;
  43:				; Port enumeration. Used for console and transfer port selection. Definitions must
  44:				; match names in prt_name_list (monitor.z80).
  45:     -	        	                ENUM_START
  46:     -	        	                ENUM PORT_SER1          ; Serial port 1
  47:     -	        	                ENUM PORT_SER2          ; Serial port 2
  48:     -	        	                ENUM_END PORT_STATES    ; Number of states
  49:				;
  50:				
**** diags.z80 ****
  29:				                include "utility.i"     ; Utility functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//utility.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Utility Routines   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef utility      ; Inhibit for this module
  16:				;
  17:				                extern cwnwln       ; Write new line characters to console.
  18:				                extern conwms       ; Print null-terminated string to the console
  19:				                extern conwmn       ; Print message <n> in a list
  20:				                extern skpspc       ; Step hl past spaces
  21:				                extern toupca       ; Convert character in A to upper case
  22:				                extern toloca       ; Convert character in A to lower case
  23:				                extern cwvich       ; Print only visible 7-bit characters
  24:				                extern cwpspc       ; Print a space
  25:				                extern mtwdli       ; Match word in a string against list of options
  26:				                extern cwphnb       ; Print least-significant nibble in A in hexadecimal
  27:				                extern cwphby       ; Print A in hexadecimal
  28:				                extern cwphwd       ; Print HL in hexadecimal
  29:				                extern cwpdby       ; Print A in decimal. Leading zeros are suppressed
  30:				                extern cwpdwd       ; Print HL in decimal. Leading zeros are suppressed
  31:				                extern cwpdlo       ; Print DEHL in decimal. Leading zeros are suppressed
  32:				                extern rdhxwd       ; Read a 16-bit hexadecimal number from a string
  33:				                extern rdduwd       ; Read a 16-bit unsigned decimal number from a string
  34:				                extern rddulo       ; Read a 32-bit unsigned decimal number from a string
  35:				;
  36:				                endif
  37:				            endif
  38:				;
  39:				;
  40:				; mtwdli (match word in a string against list of options) option bits. Each bit
  41:				; has the described effect if set.
  42:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  43:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  44:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  45:				
**** diags.z80 ****
  30:				                include "maths.i"       ; Mathematical functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for ZARC Z80 Computer         *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 29/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef maths        ; Inhibit for this module
  16:				;
  17:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  18:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  19:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  20:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  21:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  22:				                extern crc16x       ; Software CRC-16 (XMODEM)
  23:				;
  24:				                endif
  25:				            endif
  26:				
**** diags.z80 ****
  31:				                include "memory.i"      ; Memory page allocation
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//memory.i ****
   1:				; *******************************************
   2:				; * ZARC Memory Include File                *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 24/11/2021                *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef memory       ; Inhibit for this module
  17:				;
  18:				                extern mpinit       ; Initialise
  19:				                extern mprpt        ; Report status to console
  20:				                extern mpall        ; Allocate new page
  21:				                extern mpfree       ; Free allocated page
  22:				                extern mpstat       ; Allocation status
  23:				                extern mppnam       ; Print entry name
  24:				;
  25:				                endif
  26:				            endif
  27:				;
  28:				; Physical memory constants are found in zarc.i
  29:				;
  30:     -	0004'         	MPA_NAME_LEN        equ 4               ; Page owner name length (bytes)
  31:				;
  32:				; Memory map
  33:     -	4000'         	MMAP_PAGE_SIZE      equ 0x4000          ; Memory mapping bank / page size
  34:     -	0004'         	MMAP_BANKS          equ 4               ; Number of 16 kB banks
  35:     -	0040'         	MMAP_PAGES          equ 0x40            ; Number of 16 kB RAM pages
  36:     -	0000'         	MMAP_BANK0_START    equ 0x0000
  37:     -	3FFF'         	MMAP_BANK0_END      equ 0x3fff
  38:     -	4000'         	MMAP_BANK1_START    equ 0x4000
  39:     -	7FFF'         	MMAP_BANK1_END      equ 0x7fff
  40:     -	8000'         	MMAP_BANK2_START    equ 0x8000
  41:     -	BFFF'         	MMAP_BANK2_END      equ 0xbfff
  42:     -	C000'         	MMAP_BANK3_START    equ 0xc000
  43:     -	FFFF'         	MMAP_BANK3_END      equ 0xffff
  44:				;
  45:				;
  46:				;
  47:				; ****************
  48:				; * Memory Usage *
  49:				; ****************
  50:				;
  51:				;
  52:				; Memory banks setup.
  53:				; 0 (0000 - 3FFF): 3f read only, supervisor - monitor program
  54:				; 1 (4000 - 7FFF): 3e writeable - monitor variables, stacks, buffers etc.
  55:				; 2 (8000 - BFFF): (not used)
  56:				; 3 (C000 - FFFF): (mapped as required)
  57:				;
  58:     -	003F'         	MMAP_MON_B0_PAGE    equ 0x3f        ; Page for bank 0
  59:     -	003E'         	MMAP_MON_B1_PAGE    equ 0x3e        ; Page for bank 1
  60:				;
  61:     -	0040'         	STACKS_SIZE     equ 64              ; Space allocated to normal stacks
  62:				;
  63:     -	7FFF'         	HEAP_TOP        equ MMAP_BANK1_END  ; Top (end) of heap space.
  64:				
**** diags.z80 ****
  32:				;
  33:				;
  34:				; *************
  35:				; * Externals *
  36:				; *************
  37:				;
  38:				                public cpuspd   ; Measure approximate CPU clock speed
  39:				                public memtst   ; Test an area of memory with a range of patterns
  40:				                public memtal   ; Test entire memory
  41:				;
  42:				;
  43:				; *************
  44:				; * Constants *
  45:				; *************
  46:				;
  47:				; None
  48:				;
  49:				;
  50:				; *************
  51:				; * Main Code *
  52:				; *************
  53:				;
  54:				                cseg                ; Code segment
  55:				;
  56:				; Measure approximate CPU clock speed. This is intended by use during initialisation
  57:				; before interrupts are enabled. The tick interrupt mechanism is used as a timing
  58:				; reference (polling the relevant "pending" bit).
  59:				; Returns with:
  60:				; BC - CPU clock in KHz.
  61:    0+11	0000' D5      	cpuspd          push de
  62:   11+11	0001' E5      	                push hl
  63:   22+10	0002' 010000  	                ld bc, 0            ; Reset counter for later
  64:   32+7	0005' 2610    	                ld h, INT_TICK_MASK ; Cache value for later
  65:   39+10	0007' 110000  	                ld de, 0            ; Set timeout
  66:				; Synchronise to the tick interrupt
  67:   49+4	000A' 7C      	                ld a, h
  68:   53+11	000B' D30A    	                out (IOA_INT_PEND), a   ; Clear any pending tick interrupt
  69:     -	0000'         	                sett 0              ; Reset assembler cycle count
  70:				; Wait loop
  71:    0+11	000D' DB0A    	cspd_waittick   in IOA_INT_PEND     ; [11]
  72:   11+4	000F' A4      	                and h               ; [4]
  73:   15+7+5	0010' 2009    	                jr nz, cspd_tick    ; [7 - not taken] Jump if tick interrupt found                
  74:   22+6	0012' 13      	                inc de              ; [6]
  75:   28+4	0013' 7A      	                ld a, d             ; [4]
  76:   32+4	0014' B3      	                or e                ; [4]
  77:   36+10	0015' C20D00  	                jp nz, cspd_waittick    ; [10]
  78:				; Timed out after 0.41 s (8 MHz) or 105 s (31.25 Khz)
  79:   46+17	0018' CD0000  	                call panic          ; System panic if no tick found
  80:				;
  81:   63+4	001B' 7C      	cspd_tick       ld a, h
  82:   67+11	001C' D30A    	                out (IOA_INT_PEND), a   ; Clear pending tick interrupt
  83:     -	0000'         	                sett 0              ; Reset assembler cycle count
  84:				; The ideal period of the timing loop is 50 cycles for easy conversion  of the resulting
  85:				; count into KHz. The instructions below total 46, but allowing for I/O wait cycles then
  86:				; we are close.
  87:    0+11	001E' DB0A    	cspd_timloop    in IOA_INT_PEND     ; [11]
  88:   11+4	0020' A4      	                and h               ; [4]
  89:   15+7+5	0021' 2009    	                jr nz, cspd_tick1   ; [7 - not taken] Jump if tick interrupt found
  90:   22+6	0023' 03      	                inc bc              ; [6]
  91:   28+4	0024' 78      	                ld a, b             ; [4]
  92:   32+4	0025' B1      	                or c                ; [4]
  93:   36+10	0026' C21E00  	                jp nz, cspd_timloop ; [10]
  94:				; Timed out after 0.41 s (8 MHz) or 105 s (31.25 Khz)
  95:   46+17	0029' CD0000  	                call panic          ; System panic if no tick found
  96:				; Tick interrupt found, so we can stop counting.
  97:				; BC - count
  98:				; We need to divide by approximately 2.141.
  99:   63+10	002C' 118D77  	cspd_tick1      ld de, 30605        ; Multiplier
 100:   73+17	002F' CD0000  	                call mamwwu         ; 16-bit * 16-bit unsigned multiply
 101:				; DEHL - result
 102:				; Now divide by 65536.
 103:   90+4	0032' 42      	                ld b, d             ; Copy MSW to BC
 104:   94+4	0033' 4B      	                ld c, e
 105:   98+10	0034' E1      	                pop hl
 106:  108+10	0035' D1      	                pop de
 107:  118+10	0036' C9      	                ret
 108:				;
 109:				;
 110:				; Test an area of memory with a range of patterns. This tests memory as it is
 111:				; currently mapped.
 112:				; Call with:
 113:				; HL - start address
 114:				; BC - length
 115:				; Returns with:
 116:				; A - 0 if all went well.
 117:  128+11	0037' D5      	memtst          push de
 118:  139+4	0038' AF      	                xor a
 119:  143+13	0039' 320000  	                ld (mt_err_flag), a ; Reset error flag
 120:  156+11	003C' E5      	                push hl
 121:  167+11	003D' C5      	                push bc
 122:  178+17	003E' CDD400  	                call mt_test_patt   ; All zeros
 123:  195+10	0041' C1      	                pop bc
 124:  205+10	0042' E1      	                pop hl
 125:  215+11	0043' E5      	                push hl
 126:  226+11	0044' C5      	                push bc
 127:  237+7	0045' 3EFF    	                ld a, 0xff
 128:  244+17	0047' CDD400  	                call mt_test_patt   ; All ones
 129:  261+10	004A' C1      	                pop bc
 130:  271+10	004B' E1      	                pop hl
 131:				; Walking ones
 132:  281+7	004C' 1601    	                ld d, 1             ; Initial pattern
 133:  288+4	004E' 7A      	mt_walk1_lp     ld a, d
 134:  292+11	004F' E5      	                push hl
 135:  303+11	0050' C5      	                push bc
 136:  314+17	0051' CDD400  	                call mt_test_patt   ; All ones
 137:  331+10	0054' C1      	                pop bc
 138:  341+10	0055' E1      	                pop hl
 139:  351+8	0056' CB02    	                rlc d
 140:				; Keep going unless the bit has fallen off
 141:  359+7+5	0058' 30F4    	                jr nc, mt_walk1_lp
 142:				; Walking zeroes
 143:  366+7	005A' 16FE    	                ld d, 0xfe          ; Initial pattern
 144:  373+4	005C' 7A      	mt_walk0_lp     ld a, d
 145:  377+11	005D' E5      	                push hl
 146:  388+11	005E' C5      	                push bc
 147:  399+17	005F' CDD400  	                call mt_test_patt   ; All ones
 148:  416+10	0062' C1      	                pop bc
 149:  426+10	0063' E1      	                pop hl
 150:  436+8	0064' CB02    	                rlc d
 151:				; Keep going unless the bit has fallen off
 152:  444+7+5	0066' 38F4    	                jr c, mt_walk0_lp
 153:				; Addressing test. Write a repeating pattern of three bytes (1, 2 and 3)
 154:				; and verify it. No multiple of three is a power of two, so all address
 155:				; bits are tested.
 156:  451+7	0068' 1E01    	                ld e, 1             ; Initial pattern
 157:  458+11	006A' E5      	                push hl             ; Save address
 158:  469+11	006B' C5      	                push bc             ; Save length
 159:  480+10	006C' 219901  	                ld hl, mt_addr_msg
 160:  490+17	006F' CD0000  	                call conwms   ; Print "Addressing test" message
 161:				; Restore address and length but leave a copy on the stack.
 162:  507+10	0072' C1      	                pop bc
 163:  517+10	0073' E1      	                pop hl
 164:  527+11	0074' E5      	                push hl
 165:  538+11	0075' C5      	                push bc
 166:				; Write the pattern.
 167:  549+4	0076' 78      	mt_wra_lp       ld a, b
 168:  553+4	0077' B1      	                or c
 169:  557+7+5	0078' 280D    	                jr z, mt_wra_dn     ; Exit if finished
 170:  564+7	007A' 73      	                ld (hl), e
 171:				; Adjust pattern
 172:  571+4	007B' 1C      	                inc e
 173:  575+7	007C' 3E03    	                ld a, 3
 174:  582+4	007E' BB      	                cp e
 175:  586+7+5	007F' 3002    	                jr nc, mt_wra_pok
 176:  593+7	0081' 1E01    	                ld e, 1
 177:  600+6	0083' 23      	mt_wra_pok      inc hl
 178:  606+6	0084' 0B      	                dec bc
 179:  612+12	0085' 18EF    	                jr mt_wra_lp
 180:				; Restore address and length.
 181:  624+10	0087' C1      	mt_wra_dn       pop bc
 182:  634+10	0088' E1      	                pop hl
 183:				; Verify the pattern.
 184:  644+7	0089' 1E01    	                ld e, 1             ; Initial pattern
 185:  651+4	008B' 78      	mt_vea_lp       ld a, b
 186:  655+4	008C' B1      	                or c
 187:  659+7+5	008D' 2830    	                jr z, mt_done       ; Exit if finished
 188:  666+7	008F' 7E      	                ld a, (hl)
 189:  673+4	0090' BB      	                cp e
 190:  677+7+5	0091' 2820    	                jr z, mt_vea_byte_dn ; Jump if OK
 191:				; Mismatch
 192:  684+11	0093' F5      	                push af             ; Save data read
 193:  695+11	0094' E5      	                push hl             ; Save address
 194:  706+10	0095' 21B401  	                ld hl, mt_err1_msg
 195:  716+17	0098' CD0000  	                call conwms         ; Print "Error at " message
 196:  733+10	009B' E1      	                pop hl
 197:  743+11	009C' E5      	                push hl
 198:  754+17	009D' CD0000  	                call cwphwd         ; Print address in hex
 199:  771+10	00A0' 21BE01  	                ld hl, mt_err2_msg
 200:  781+17	00A3' CD0000  	                call conwms         ; Print ", read " message
 201:  798+10	00A6' E1      	                pop hl
 202:  808+10	00A7' F1      	                pop af
 203:  818+17	00A8' CD0000  	                call cwphby         ; Print data read in hex
 204:  835+17	00AB' CD0000  	                call cwnwln         ; Write new line characters to console
 205:				; Set error flag
 206:  852+7	00AE' 3E01    	                ld a, 1
 207:  859+13	00B0' 320000  	                ld (mt_err_flag), a
 208:				; Adjust pattern
 209:  872+4	00B3' 1C      	mt_vea_byte_dn  inc e
 210:  876+7	00B4' 3E03    	                ld a, 3
 211:  883+4	00B6' BB      	                cp e
 212:  887+7+5	00B7' 3002    	                jr nc, mt_vea_pok
 213:  894+7	00B9' 1E01    	                ld e, 1
 214:  901+6	00BB' 23      	mt_vea_pok      inc hl
 215:  907+6	00BC' 0B      	                dec bc
 216:  913+12	00BD' 18CC    	                jr mt_vea_lp
 217:				;
 218:  925+10	00BF' D1      	mt_done         pop de
 219:				                
 220:				; Report pass / fail state.
 221:  935+13	00C0' 3A0000  	mt_test_dn      ld a, (mt_err_flag) ; Return with error flag in A
 222:  948+4	00C3' A7      	                and a
 223:  952+7+5	00C4' 2007    	                jr nz, mt_errs
 224:				; No errors
 225:  959+10	00C6' 21E401  	                ld hl, mt_pass_msg
 226:  969+17	00C9' CD0000  	                call conwms         ; Print "Passed" message
 227:  986+10	00CC' C9      	                ret
 228:				; One or more errors occurred.
 229:  996+10	00CD' 21ED01  	mt_errs         ld hl, mt_fail_msg
 230: 1006+17	00D0' CD0000  	                call conwms         ; Print "Failed" message
 231: 1023+10	00D3' C9      	                ret 
 232:				;
 233:				; Test an area of memory with the pattern specified. This is used by memtst.
 234:				; Call with:
 235:				; A - pattern
 236:				; HL - start address
 237:				; BC - length
 238:				; mt_err_flag is set to 1 if an error is encountered.
 239:				; Note: E is not preserved.
 240: 1033+11	00D4' E5      	mt_test_patt    push hl             ; Save address
 241: 1044+11	00D5' C5      	                push bc             ; Save length
 242: 1055+4	00D6' 5F      	                ld e, a             ; Save pattern
 243: 1059+10	00D7' 21AB01  	                ld hl, mt_patt_msg
 244: 1069+17	00DA' CD0000  	                call conwms         ; Print "Pattern " message
 245: 1086+4	00DD' 7B      	                ld a, e
 246: 1090+17	00DE' CD0000  	                call cwphby         ; Print in hex
 247: 1107+17	00E1' CD0000  	                call cwnwln         ; Write new line characters to console
 248:				; Restore address and length but leave a copy on the stack.
 249: 1124+10	00E4' C1      	                pop bc
 250: 1134+10	00E5' E1      	                pop hl
 251: 1144+11	00E6' E5      	                push hl
 252: 1155+11	00E7' C5      	                push bc
 253:				; Write the pattern.
 254: 1166+4	00E8' 78      	mt_wr_patt_lp   ld a, b
 255: 1170+4	00E9' B1      	                or c
 256: 1174+7+5	00EA' 2805    	                jr z, mt_wr_patt_dn ; Exit if finished
 257: 1181+7	00EC' 73      	                ld (hl), e
 258: 1188+6	00ED' 23      	                inc hl
 259: 1194+6	00EE' 0B      	                dec bc
 260: 1200+12	00EF' 18F7    	                jr mt_wr_patt_lp
 261:				; Now check it.
 262:				; Restore address and length.
 263: 1212+10	00F1' C1      	mt_wr_patt_dn   pop bc
 264: 1222+10	00F2' E1      	                pop hl
 265:				; Verify the pattern.
 266: 1232+4	00F3' 78      	mt_ve_patt_lp   ld a, b
 267: 1236+4	00F4' B1      	                or c
 268: 1240+5+6	00F5' C8      	                ret z               ; Exit if finished
 269: 1245+7	00F6' 7E      	                ld a, (hl)
 270: 1252+4	00F7' BB      	                cp e
 271: 1256+7+5	00F8' 2820    	                jr z, mt_ve_byte_dn ; Jump if OK
 272:				; Mismatch
 273: 1263+11	00FA' F5      	                push af             ; Save data read
 274: 1274+11	00FB' E5      	                push hl             ; Save address
 275: 1285+10	00FC' 21B401  	                ld hl, mt_err1_msg
 276: 1295+17	00FF' CD0000  	                call conwms         ; Print "Error at " message
 277: 1312+10	0102' E1      	                pop hl
 278: 1322+11	0103' E5      	                push hl
 279: 1333+17	0104' CD0000  	                call cwphwd         ; Print address in hex
 280: 1350+10	0107' 21BE01  	                ld hl, mt_err2_msg
 281: 1360+17	010A' CD0000  	                call conwms         ; Print ", read " message
 282: 1377+10	010D' E1      	                pop hl
 283: 1387+10	010E' F1      	                pop af
 284: 1397+17	010F' CD0000  	                call cwphby         ; Print data read in hex
 285: 1414+17	0112' CD0000  	                call cwnwln         ; Write new line characters to console
 286:				; Set error flag
 287: 1431+7	0115' 3E01    	                ld a, 1
 288: 1438+13	0117' 320000  	                ld (mt_err_flag), a
 289: 1451+6	011A' 23      	mt_ve_byte_dn   inc hl
 290: 1457+6	011B' 0B      	                dec bc
 291: 1463+12	011C' 18D5    	                jr mt_ve_patt_lp
 292:				;
 293:				;
 294:				; Test the entire memory. This is not to be used lightly as it is very
 295:				; destructive. Loop through each page, testing them as we go.
 296:				; Returns with:
 297:				; A - 0 if all went well.
 298:				; Registers are not preserved.
 299: 1475+4	011E' AF      	memtal          xor a
 300: 1479+13	011F' 320000  	                ld (mt_err_flag), a ; Reset error flag
 301: 1492+7	0122' 0E00    	                ld c, 0             ; Starting page
 302: 1499+4	0124' 79      	mta_page_lp     ld a, c
 303: 1503+7	0125' FE3F    	                cp MMAP_MON_B0_PAGE
 304: 1510+7+5	0127' 2828    	                jr z, mta_next_page ; Skip pages used by monitor
 305: 1517+7	0129' FE3E    	                cp MMAP_MON_B1_PAGE
 306: 1524+7+5	012B' 2824    	                jr z, mta_next_page
 307:				; Print the current page
 308: 1531+10	012D' 21D001  	                ld hl, mta_page_msg
 309: 1541+17	0130' CD0000  	                call conwms         ; Print "Page" message
 310: 1558+4	0133' 79      	                ld a, c
 311: 1562+17	0134' CD0000  	                call cwphby         ; Print page in hex
 312: 1579+17	0137' CD0000  	                call cwnwln         ; Write new line characters to console
 313: 1596+4	013A' 79      	                ld a, c
 314:				; Set bank 3 (0xc000 to 0xffff) to the required page.
 315:				; Super and prot are not set so we can write, and there is no need for I/O.
 316: 1600+11	013B' D307    	                out (IOA_MMAP_3), a
 317: 1611+11	013D' C5      	                push bc             ; Save page
 318: 1622+10	013E' 2100C0  	                ld hl, MMAP_BANK3_START ; Start address
 319: 1632+11	0141' E5      	                push hl             ; Save address
 320: 1643+10	0142' 010040  	                ld bc, MMAP_PAGE_SIZE   ; Length
 321: 1653+17	0145' CD3700  	                call memtst
 322: 1670+4	0148' A7      	                and a
 323: 1674+7+5	0149' 2803    	                jr z, mta_pageok
 324: 1681+13	014B' 320000  	                ld (mt_err_flag), a ; Set error flag on error
 325: 1694+10	014E' E1      	mta_pageok      pop hl
 326: 1704+10	014F' C1      	                pop bc
 327: 1714+7	0150' 71      	                ld (hl), c          ; Write page number into first byte
 328: 1721+4	0151' 0C      	mta_next_page   inc c
 329: 1725+4	0152' 79      	                ld a, c
 330: 1729+7	0153' FE40    	                cp MMAP_PAGES
 331: 1736+7+5	0155' 38CD    	                jr c, mta_page_lp
 332:				; Verify the tags we left in each page to make sure the page select logic
 333:				; is really working.
 334:				; Loop through each page again
 335: 1743+10	0157' 21D601  	                ld hl, mta_pagetst_msg
 336: 1753+17	015A' CD0000  	                call conwms         ; Print "Paging test" message
 337: 1770+7	015D' 0E00    	                ld c, 0             ; Starting page
 338: 1777+4	015F' 79      	mta_page_sel_lp  ld a, c
 339: 1781+7	0160' FE3F    	                cp MMAP_MON_B0_PAGE
 340: 1788+7+5	0162' 282C    	                jr z, mta_next_page1 ; Skip monitor pages
 341: 1795+7	0164' FE3E    	                cp MMAP_MON_B1_PAGE
 342: 1802+7+5	0166' 2828    	                jr z, mta_next_page1
 343:				; Set bank 3 (0xc000 to 0xffff) to the required page.
 344:				; is selected as we have no further need to write.
 345: 1809+7	0168' F680    	                or MMAP_PROT_MASK   ; Select write protect
 346: 1816+11	016A' D307    	                out (IOA_MMAP_3), a
 347: 1827+10	016C' 2100C0  	                ld hl, MMAP_BANK3_START ; Set address
 348: 1837+7	016F' 7E      	                ld a, (hl)
 349:				;            or 0x20                 ; Deliberately create errors for testing
 350: 1844+4	0170' B9      	                cp c                ; Verify tag
 351: 1848+7+5	0171' 281D    	                jr z, mta_next_page1
 352:				; Mismatch
 353:				; A - data read
 354:				; C - data expected (page number)
 355: 1855+11	0173' F5      	                push af             ; Save data read
 356: 1866+10	0174' 21C601  	                ld hl, mt_err3_msg
 357: 1876+17	0177' CD0000  	                call conwms         ; Print "Expected " message
 358: 1893+4	017A' 79      	                ld a, c
 359: 1897+17	017B' CD0000  	                call cwphby         ; Print data expected in hex
 360: 1914+10	017E' 21BE01  	                ld hl, mt_err2_msg
 361: 1924+17	0181' CD0000  	                call conwms         ; Print ", read " message
 362: 1941+10	0184' F1      	                pop af
 363: 1951+17	0185' CD0000  	                call cwphby         ; Print data read in hex
 364: 1968+17	0188' CD0000  	                call cwnwln         ; Write new line characters to console
 365:				; Set error flag
 366: 1985+7	018B' 3E01    	                ld a, 1
 367: 1992+13	018D' 320000  	                ld (mt_err_flag), a
 368: 2005+4	0190' 0C      	mta_next_page1  inc c
 369: 2009+4	0191' 79      	                ld a, c
 370: 2013+7	0192' FE40    	                cp MMAP_PAGES
 371: 2020+7+5	0194' 38C9    	                jr c, mta_page_sel_lp
 372: 2027+10	0196' C3C000  	                jp mt_test_dn       ; Report pass / fail state and exit
 373:				;
 374:				;
 375:				;
 376:				; *************
 377:				; * Constants *
 378:				; *************
 379:				;
 380:     -	0199' 41646472	mt_addr_msg     byte "Addressing test", 0x0d, 0x0a, 0
	              65737369
	              6E672074
	              6573740D
	              0A00
 381:     -	01AB' 50617474	mt_patt_msg     byte "Pattern ", 0
	              65726E20
	              00
 382:     -	01B4' 4572726F	mt_err1_msg     byte "Error at ", 0
	              72206174
	              2000
 383:     -	01BE' 2C207265	mt_err2_msg     byte ", read ", 0
	              61642000
 384:     -	01C6' 45787065	mt_err3_msg     byte "Expected ", 0
	              63746564
	              2000
 385:     -	01D0' 50616765	mta_page_msg    byte "Page ", 0
	              2000
 386:     -	01D6' 50616769	mta_pagetst_msg byte "Paging test", 0x0d, 0x0a, 0
	              6E672074
	              6573740D
	              0A00
 387:     -	01E4' 50617373	mt_pass_msg     byte "Passed", 0x0d, 0x0a, 0
	              65640D0A
	              00
 388:     -	01ED' 4661696C	mt_fail_msg     byte "Failed", 0x0d, 0x0a, 0
	              65640D0A
	              00
 389:				;
 390:				;
 391:				;
 392:				; *************
 393:				; * Variables *
 394:				; *************
 395:				;
 396:				;
 397:				; Note: linker "-c" option is used, so no data is initialised here.
 398:				                dseg                ; Data segment
 399:				;
 400:     -	0000"         	mt_err_flag     defs 1              ; Memory test error flag
 401:				;
 402:     -	0001"         	                end



Statistics:

     4	passes
     0	jr promotions
   326	symbols
   502	bytes

   117	macro calls
  1320	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
HEAP_TOP       =7FFF      32767
I2C_CSR_ACKN_BIT=00        0
I2C_CSR_ACKN_MASK=01        1
I2C_CSR_BUSY_BIT=07        7
I2C_CSR_BUSY_MASK=80        128
I2C_CSR_START_BIT=01        1
I2C_CSR_START_MASK=02        2
I2C_CSR_STOP_BIT=02        2
I2C_CSR_STOP_MASK=04        4
INTS_NUM       =08        8
INT_SER1_RX_BIT=01        1
INT_SER1_RX_MASK=02        2
INT_SER1_RX_VEC=01        1
INT_SER1_TX_BIT=00        0
INT_SER1_TX_MASK=01        1
INT_SER1_TX_VEC=00        0
INT_SER2_RX_BIT=03        3
INT_SER2_RX_MASK=08        8
INT_SER2_RX_VEC=03        3
INT_SER2_TX_BIT=02        2
INT_SER2_TX_MASK=04        4
INT_SER2_TX_VEC=02        2
INT_TICK_BIT   =04        4
INT_TICK_MASK  =10        16
INT_TICK_VEC   =04        4
IOA_CONTROL    =02        2
IOA_CRC_0      =24        36
IOA_CRC_1      =25        37
IOA_CRC_DATA   =26        38
IOA_FPGA_MAJREV=00        0
IOA_FPGA_MINREV=01        1
IOA_FP_SW      =03        3
IOA_I2C_CSR    =18        24
IOA_I2C_DATA   =19        25
IOA_INT_EN     =08        8
IOA_INT_PEND   =0A        10
IOA_MMAP_0     =04        4
IOA_MMAP_1     =05        5
IOA_MMAP_2     =06        6
IOA_MMAP_3     =07        7
IOA_NMI_REASONS=0C        12
IOA_SER1_CSR   =10        16
IOA_SER1_DATA  =11        17
IOA_SER2_CSR   =12        18
IOA_SER2_DATA  =13        19
IOA_SPI_CSR    =20        32
IOA_SPI_DATA   =21        33
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MMAP_BANK0_END =3FFF      16383
MMAP_BANK0_START=00        0
MMAP_BANK1_END =7FFF      32767
MMAP_BANK1_START=4000      16384
MMAP_BANK2_END =BFFF      49151
MMAP_BANK2_START=8000      32768
MMAP_BANK3_END =FFFF      65535
MMAP_BANK3_START=C000      49152
MMAP_BANKS     =04        4
MMAP_MON_B0_PAGE=3F        63
MMAP_MON_B1_PAGE=3E        62
MMAP_PAGES     =40        64
MMAP_PAGE_MASK =3F        63
MMAP_PAGE_SIZE =4000      16384
MMAP_PROT_BIT  =07        7
MMAP_PROT_MASK =80        128
MMAP_SUPER_BIT =06        6
MMAP_SUPER_MASK=40        64
MPA_NAME_LEN   =04        4
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MS_PER_TICK    =64        100
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NMI_PROT_VIOL_BIT=01        1
NMI_PROT_VIOL_MASK=02        2
NMI_REASONS_ALL=0F        15
NMI_REASONS_NUM=04        4
NMI_SUPER_VIOL_BIT=02        2
NMI_SUPER_VIOL_MASK=04        4
NMI_SWITCH_BIT =00        0
NMI_SWITCH_MASK=01        1
NMI_TRACE_BIT  =03        3
NMI_TRACE_MASK =08        8
PORT_SER1      =00        0
PORT_SER2      =01        1
PORT_STATES    =02        2
SER_CSR_FRAME_ERR_BIT=03        3
SER_CSR_FRAME_ERR_MASK=08        8
SER_CSR_RX_ALHALF_BIT=01        1
SER_CSR_RX_ALHALF_MASK=02        2
SER_CSR_RX_EMPTY_BIT=00        0
SER_CSR_RX_EMPTY_MASK=01        1
SER_CSR_RX_FULL_BIT=02        2
SER_CSR_RX_FULL_MASK=04        4
SER_CSR_TX_ALHALF_BIT=05        5
SER_CSR_TX_ALHALF_MASK=20        32
SER_CSR_TX_EMPTY_BIT=04        4
SER_CSR_TX_EMPTY_MASK=10        16
SER_CSR_TX_FULL_BIT=06        6
SER_CSR_TX_FULL_MASK=40        64
SPI_CSR_BUSY_BIT=07        7
SPI_CSR_BUSY_MASK=80        128
SPI_CSR_FAST_BIT=00        0
SPI_CSR_FAST_MASK=01        1
SPI_CSR_MC_SS_BIT=01        1
SPI_CSR_MC_SS_MASK=02        2
STACKS_SIZE    =40        64
SYSCTRL_MAPARM_BIT=03        3
SYSCTRL_MAPARM_MASK=08        8
SYSCTRL_MMAPN_BIT=04        4
SYSCTRL_MMAPN_MASK=10        16
SYSCTRL_MMAP_BIT=01        1
SYSCTRL_MMAP_MASK=02        2
SYSCTRL_NMCLR_BIT=02        2
SYSCTRL_NMCLR_MASK=04        4
SYSCTRL_RESERVED_BIT=07        7
SYSCTRL_RESERVED_MASK=80        128
SYSCTRL_TRARM_BIT=00        0
SYSCTRL_TRARM_MASK=01        1
SYSCTRL_TRPRE0_BIT=05        5
SYSCTRL_TRPRE0_MASK=20        32
SYSCTRL_TRPRE1_BIT=06        6
SYSCTRL_TRPRE1_MASK=40        64
TICK_FREQ      =0A        10
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
conrch          00        0 (extern)
consta          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
coport          00        0 (extern)
cpuspd          00'       0 (public)
crc16x          00        0 (extern)
cspd_tick       1B'       27
cspd_tick1      2C'       44
cspd_timloop    1E'       30
cspd_waittick   0D'       13
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
diags          =01        1
enum_counter   =02        2
i2crd           00        0 (extern)
i2cwr           00        0 (extern)
jptbl_addr     =F6        246
madbbu          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
memtal           11E'     286 (public)
memtst          37'       55 (public)
monitor        =01        1
mpall           00        0 (extern)
mpfree          00        0 (extern)
mpinit          00        0 (extern)
mppnam          00        0 (extern)
mprpt           00        0 (extern)
mpstat          00        0 (extern)
mt_addr_msg      199'     409
mt_done         BF'       191
mt_err1_msg      1B4'     436
mt_err2_msg      1BE'     446
mt_err3_msg      1C6'     454
mt_err_flag     00"       0
mt_errs         CD'       205
mt_fail_msg      1ED'     493
mt_pass_msg      1E4'     484
mt_patt_msg      1AB'     427
mt_test_dn      C0'       192
mt_test_patt    D4'       212
mt_ve_byte_dn    11A'     282
mt_ve_patt_lp   F3'       243
mt_vea_byte_dn  B3'       179
mt_vea_lp       8B'       139
mt_vea_pok      BB'       187
mt_walk0_lp     5C'       92
mt_walk1_lp     4E'       78
mt_wr_patt_dn   F1'       241
mt_wr_patt_lp   E8'       232
mt_wra_dn       87'       135
mt_wra_lp       76'       118
mt_wra_pok      83'       131
mta_next_page    151'     337
mta_next_page1   190'     400
mta_page_lp      124'     292
mta_page_msg     1D0'     464
mta_page_sel_lp  15F'     351
mta_pageok       14E'     334
mta_pagetst_msg  1D6'     470
mtwdli          00        0 (extern)
panic           00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
rusby           00        0 (extern)
ruswd           00        0 (extern)
s1rch           00        0 (extern)
s1sta           00        0 (extern)
s1wch           00        0 (extern)
s2rch           00        0 (extern)
s2sta           00        0 (extern)
s2wch           00        0 (extern)
skpspc          00        0 (extern)
spiini          00        0 (extern)
spiss           00        0 (extern)
spitr           00        0 (extern)
str_offset     =20        32
tikcnt          00        0 (extern)
toloca          00        0 (extern)
toupca          00        0 (extern)
trarch          00        0 (extern)
trawch          00        0 (extern)
trport          00        0 (extern)
wusby           00        0 (extern)
wuswd           00        0 (extern)
