   1:				; *******************************************************
   2:				; * Time Routines for ZARC Z80 Computer                 *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 30/7/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Routines associated with time. The system keeps track of time as a Unix-style
   8:				; 32-bit number. Unlike Unix, this is treated as an unsigned integer and so will
   9:				; not suffer from the Year 2038 problem as it doubles the allowable postive time.
  10:				; It does, however, mean that it is not possible to represent dates before 1970.
  11:				; Leap seconds are ignored. 32-bit time does not include BST adjustment and so
  12:				; always represents GMT. However, the tiitos (convert integer time to structure)
  13:				; and tistoi (convert structure time to integer) add or remove the appropriate
  14:				; offset and so describe "clock time" without further adjustment.
  15:				;
  16:				; Routines preserve all registers not required as operands or return values except
  17:				; AF unless otherwise stated below.
  18:				;
  19:				;
  20:     -	0001'         	monitor         equ 1                   ; Flag part of monitor build
  21:     -	0001'         	time            equ 1                   ; Flag module for includes
  22:				;
  23:				;
  24:				;
  25:				; ************
  26:				; * Includes *
  27:				; ************
  28:				;
  29:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				
**** time.z80 ****
  30:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** time.z80 ****
  31:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  18:     -	0001'         	                ifndef main         ; Inhibit for this module
  19:				; Constants
  20:				;
  21:				; Variables 
  22:				                extern tikcnt       ; Tick counter
  23:				;
  24:				; Functions
  25:				                extern panic        ; System error exception
  26:				                extern rusby        ; Read byte from user space
  27:				                extern ruswd        ; Read 16-bit word from user space
  28:				                extern wusby        ; Write byte to user space
  29:				                extern wuswd        ; Write 16-bit word to user space
  30:				;
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** time.z80 ****
  32:				                include "zarc.i"        ; Hardware definitions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//zarc.i ****
   1:				; ***********************************
   2:				; * ZARC Definitions                *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 26/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the ZARC system.
   8:				;
   9:				;
  10:				; ************
  11:				; * Hardware *
  12:				; ************
  13:				;
  14:				; Interrupt vector numbers in INT_VEC_TABLE.
  15:				; Address is INT_VEC_TABLE + 2 * vector number).
  16:     -	0000'         	INT_SER1_TX_VEC     equ INT_SER1_TX_BIT ; Serial port 1 transmitter buffer is half full or less
  17:     -	0001'         	INT_SER1_RX_VEC     equ INT_SER1_RX_BIT ; Serial port 1 receiver has data
  18:     -	0002'         	INT_SER2_TX_VEC     equ INT_SER2_TX_BIT ; Serial port 2 transmitter buffer is half full or less
  19:     -	0003'         	INT_SER2_RX_VEC     equ INT_SER2_RX_BIT ; Serial port 2 receiver has data
  20:     -	0004'         	INT_TICK_VEC        equ INT_TICK_BIT    ; Regular timekeeping
  21:				;
  22:     -	0064'         	MS_PER_TICK         equ 100             ; ms per tick
  23:     -	000A'         	TICK_FREQ           equ 10              ; Tick rate in Hz
  24:				;
  25:				
**** time.z80 ****
  33:				                include "io_map.i"      ; I/O addresses mapping
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io_map.i ****
   1:				; ***********************************
   2:				; * ZARC I/O Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 3/9/2019          *
   5:				; ***********************************
   6:				
   7:				; *** I/O register address mapping ***
   8:				
   9:				; This should be kept in sync with the Definitions.vhd package file.
  10:     -	0000'         	IOA_FPGA_MAJREV equ 0x00        ; FPGA major revision
  11:     -	0001'         	IOA_FPGA_MINREV equ 0x01        ; FPGA minor revision
  12:     -	0002'         	IOA_CONTROL     equ 0x02        ; System control register
  13:     -	0003'         	IOA_FP_SW       equ 0x03        ; Front panel data switches
  14:				
  15:				; Paging
  16:     -	0004'         	IOA_MMAP_0      equ 0x04        ; Page, supervisor and protection for bank 0 (0x0000 to 0x3fff)
  17:     -	0005'         	IOA_MMAP_1      equ 0x05        ; Page, supervisor and protection for bank 1 (0x4000 to 0x7fff)
  18:     -	0006'         	IOA_MMAP_2      equ 0x06        ; Page, supervisor and protection for bank 2 (0x8000 to 0xbfff)
  19:     -	0007'         	IOA_MMAP_3      equ 0x07        ; Page, supervisor and protection for bank 3 (0xc000 to 0xffff)
  20:				
  21:				; Interrupts
  22:				; Note: Up to eight interrupts are supported. IM 2 is anticipated, and the
  23:				; fixed vector associated with each interrupt is supplied when the interrupt
  24:				; is serviced. Routine address is “I*256+databus”. Vector supplied is
  25:				; 0xe0 + 2 * interrupt number (0 to 7).
  26:				; Note: addresses 0x09 and 0x0b reserved for use if more than eight interrupt
  27:				; sources are required.
  28:     -	0008'         	IOA_INT_EN      equ 0x08        ; Enables
  29:     -	000A'         	IOA_INT_PEND    equ 0x0a        ; Pending interrupts
  30:				;
  31:				;NMI
  32:     -	000C'         	IOA_NMI_REASONS equ 0x0c        ; NMI reasons flags
  33:				;
  34:				; Serial.
  35:     -	0010'         	IOA_SER1_CSR    equ 0x10        ; Port 1 control / status
  36:     -	0011'         	IOA_SER1_DATA   equ 0x11        ; Port 1 data
  37:     -	0012'         	IOA_SER2_CSR    equ 0x12        ; Port 2 serial control / status
  38:     -	0013'         	IOA_SER2_DATA   equ 0x13        ; Port 2 serial data
  39:				
  40:				; RTC (DS1672)
  41:				; I2C, implemented using a byte interface to the CPU. Writing to the data port
  42:				; shifts out a byte. Input puts are shifted into the “other end” of the same
  43:				; register.
  44:     -	0018'         	IOA_I2C_CSR     equ 0x18        ; Control
  45:     -	0019'         	IOA_I2C_DATA    equ 0x19        ; Data
  46:				;
  47:				; SD Card
  48:				; Uses SPI mode, with a generally similar interface to that of the I2C.
  49:     -	0020'         	IOA_SPI_CSR     equ 0x20        ; Control
  50:     -	0021'         	IOA_SPI_DATA    equ 0x21        ; Data
  51:				
  52:				; CRC16 / XMODEM and MultiMediaCard CRC16
  53:				; Write to the CRC register to set the initial value. Writing to the input
  54:				; data register updates the CRC.
  55:     -	0024'         	IOA_CRC_0       equ 0x24        ; CRC register (low)
  56:     -	0025'         	IOA_CRC_1       equ 0x25        ; CRC register (high)
  57:     -	0026'         	IOA_CRC_DATA    equ 0x26        ; Input data
  58:				
  59:				; *** Proposed features ***
  60:				; Video
  61:				;IOA_VID_CTRL    equ 0x30;       ; Control (cursor on/off ...)
  62:				;IOA_VID_DATA    equ 0x31;       ; Data
  63:				;IOA_VID_CUR_X   equ 0x32;       ; Cursor X (0 to 127)
  64:				;IOA_VID_CUR_Y   equ 0x33;       ; Cursor Y (0 to 63)
  65:				;IOA_VID_START_L equ 0x34        ; Display start address (low byte)
  66:				;IOA_VID_START_H equ 0x35        ; Display start address (high byte)
  67:				
  68:				; Video palette
  69:				; Each entry consists of 6 bits of colour data. Foreground and background
  70:				; colour pairs are selected from the above palette using eight of the 22
  71:				; control codes in the display character set. This leaves codes for
  72:				; double-height, double-width etc.
  73:				;IOA_VID_PALBG0  equ 0x40        ; Background colour 0
  74:				;IOA_VID_PALFG0  equ 0x41        ; Foreground colour 0
  75:				;IOA_VID_PALBG1  equ 0x42        ; Background colour 1
  76:				;IOA_VID_PALFG1  equ 0x43        ; Foreground colour 1
  77:				;IOA_VID_PALBG2  equ 0x44        ; Background colour 2
  78:				;IOA_VID_PALFG2  equ 0x45        ; Foreground colour 2
  79:				;IOA_VID_PALBG3  equ 0x46        ; Background colour 3
  80:				;IOA_VID_PALFG3  equ 0x47        ; Foreground colour 3
  81:				;IOA_VID_PALBG4  equ 0x48        ; Background colour 4
  82:				;IOA_VID_PALFG4  equ 0x49        ; Foreground colour 4
  83:				;IOA_VID_PALBG5  equ 0x4a        ; Background colour 5
  84:				;IOA_VID_PALFG5  equ 0x4b        ; Foreground colour 5
  85:				;IOA_VID_PALBG6  equ 0x4c        ; Background colour 6
  86:				;IOA_VID_PALFG6  equ 0x4d        ; Foreground colour 6
  87:				;IOA_VID_PALBG7  equ 0x4e        ; Background colour 7
  88:				;IOA_VID_PALFG7  equ 0x4f        ; Foreground colour 7
  89:				
  90:				; Arithmetic
  91:				; Multiply, divide … based on 68000 DIV, DIVU, MUL, MULU.
  92:				; Multiply does A[16] * B[16] => C[32].
  93:				; Divide does A[32] / B[16] => C[32] (16-bit remainder [high bits] and
  94:				; 16-bit quotient [low bits]).
  95:				; Status bits include “complete” and “overflow”.
  96:				;IOA_ARITH_A_L   equ 0x50        ; A register (low)
  97:				;IOA_ARITH_A_H   equ 0x51        ; A register (high)
  98:				;IOA_ARITH_B_L   equ 0x54        ; B register (low)
  99:				;IOA_ARITH_B_H   equ 0x57        ; B register (high)
 100:				;IOA_ARITH_C_0   equ 0x58        ; C register (low)
 101:				;IOA_ARITH_C_1   equ 0x59 
 102:				;IOA_ARITH_C_2   equ 0x5a
 103:				;IOA_ARITH_C_3   equ 0x5b        ; C register (high)
 104:				;IOA_ARITH_CSR   equ 0x5c        ; Command / status
 105:				
 106:				
 107:				; *** Register bits allocation ***
 108:				
 109:				; IOA_CONTROL register
 110:     -	        	BITDEF SYSCTRL_TRARM, 0         ; 1 arms the trace interrupt
 111:     -	        	BITDEF SYSCTRL_MMAP, 1          ; 1 enables memory mapping
 112:     -	        	BITDEF SYSCTRL_NMCLR, 2         ; NMI mapping clear
 113:     -	        	BITDEF SYSCTRL_MAPARM, 3        ; NMI out arm
 114:     -	        	BITDEF SYSCTRL_MMAPN, 4         ; State of MMAP when an NMI occurred
 115:     -	        	BITDEF SYSCTRL_TRPRE0, 5        ; Number of prefixes for trace
 116:     -	        	BITDEF SYSCTRL_TRPRE1, 6
 117:     -	        	BITDEF SYSCTRL_RESERVED, 7      ; Unused bit
 118:				;
 119:				; MMAP page registers
 120:     -	        	BITDEF MMAP_PROT, 7             ; Write protection
 121:     -	        	BITDEF MMAP_SUPER, 6            ; I/O enable
 122:     -	003F'         	MMAP_PAGE_MASK  equ 0x3f        ; RAM page number bits
 123:				;
 124:				; IOA_INT_EN and IOA_INT_PEND registers.
 125:     -	0008'         	INTS_NUM        equ 8           ; Number of possible interrupt sources
 126:     -	        	BITDEF INT_SER1_TX, 0           ; Serial port 1 transmitter buffer is half full or less
 127:     -	        	BITDEF INT_SER1_RX, 1           ; Serial port 1 receiver has data
 128:     -	        	BITDEF INT_SER2_TX, 2           ; Serial port 2 transmitter buffer is half full or less
 129:     -	        	BITDEF INT_SER2_RX, 3           ; Serial port 2 receiver has data
 130:     -	        	BITDEF INT_TICK, 4              ; Regular timekeeping
 131:				;
 132:				; IOA_NMI_REASONS register.
 133:     -	0004'         	NMI_REASONS_NUM equ 4           ; Number of reasons for an NMI
 134:     -	        	BITDEF NMI_SWITCH, 0;           ; Front panel switch
 135:     -	        	BITDEF NMI_PROT_VIOL, 1;        ; Write protection violation
 136:     -	        	BITDEF NMI_SUPER_VIOL, 2;       ; Supervisor violation
 137:     -	        	BITDEF NMI_TRACE, 3;            ; Debugger trace (single step)
 138:     -	000F'         	NMI_REASONS_ALL equ NMI_SWITCH_MASK + NMI_PROT_VIOL_MASK + NMI_SUPER_VIOL_MASK + NMI_TRACE_MASK
 139:				;
 140:				; Serial CSRs (IOA_SER1_CSR and IOA_SER2_CSR).
 141:     -	        	BITDEF SER_CSR_RX_EMPTY, 0      ; Receiver buffer is empty
 142:     -	        	BITDEF SER_CSR_RX_ALHALF, 1     ; Receiver buffer is at least half full
 143:     -	        	BITDEF SER_CSR_RX_FULL, 2       ; Receiver buffer is full
 144:     -	        	BITDEF SER_CSR_FRAME_ERR, 3     ; Framing error in last character
 145:     -	        	BITDEF SER_CSR_TX_EMPTY, 4      ; Transmitter buffer is empty
 146:     -	        	BITDEF SER_CSR_TX_ALHALF, 5     ; Transmitter buffer is at least half full
 147:     -	        	BITDEF SER_CSR_TX_FULL, 6       ; Transmitter buffer is full
 148:				; Bit 7 is not used.
 149:				;
 150:				; I2C (Inter-Integrated Circuit) master interface. Used for RTC (DS1672).
 151:				; Bits in IOA_I2C_CSR
 152:     -	        	BITDEF I2C_CSR_ACKN, 0          ; (Read / write) acknowledge from receiving device
 153:     -	        	BITDEF I2C_CSR_START, 1         ; (Write only) trigger start sequence
 154:     -	        	BITDEF I2C_CSR_STOP, 2          ; (Write only) trigger stop sequence
 155:     -	        	BITDEF I2C_CSR_BUSY, 7          ; (Read only) transceiver busy
 156:				;
 157:				; SPI (Serial Peripheral Interface) master interface. Used for memory card.
 158:				; Bits in IOA_SPI_CSR
 159:     -	        	BITDEF SPI_CSR_FAST, 0          ; (Read / write) SPI speed select
 160:     -	        	BITDEF SPI_CSR_MC_SS, 1         ; (Read / write) memory card slave select
 161:     -	        	BITDEF SPI_CSR_BUSY, 7          ; (Read only) transceiver busy
 162:				
**** time.z80 ****
  34:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** time.z80 ****
  35:				                include "io.i"          ; I/O routines
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io.i ****
   1:				; ***********************************
   2:				; * ZARC Basic I/O Extern Symbols   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and extern statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef io           ; Inhibit for this module
  16:				;
  17:				                ; Variables
  18:				                extern coport   ; Current console port (PRT_xxx)
  19:				                extern trport   ; Current data transfer port (PRT_xxx)
  20:				;
  21:				                ; Routines
  22:				                extern conwch   ; Write character to the console
  23:				                extern conrch   ; Read character from the console
  24:				                extern consta   ; Fetch console port status
  25:				                extern trawch   ; Write character to the data transfer port
  26:				                extern trarch   ; Read character from the data transfer port
  27:				                extern s1wch    ; Write character to serial port 1
  28:				                extern s1rch    ; Read character from serial port 1
  29:				                extern s1sta    ; Fetch serial port 1 status
  30:				                extern s2wch    ; Write character to serial port 2
  31:				                extern s2rch    ; Read character from serial port 2
  32:				                extern s2sta    ; Fetch serial port 2 status
  33:				                extern i2cwr    ; Write to I2C device
  34:				                extern i2crd    ; Read from I2C device
  35:				                extern spiini   ; Initialise SPI interface and set speed
  36:				                extern spiss    ; Set SPI slave select(s)
  37:				                extern spitr    ; Transfer byte to / from SPI device
  38:				;
  39:				                endif
  40:				            endif
  41:				;
  42:				;
  43:				; Port enumeration. Used for console and transfer port selection. Definitions must
  44:				; match names in prt_name_list (monitor.z80).
  45:     -	        	                ENUM_START
  46:     -	        	                ENUM PORT_SER1          ; Serial port 1
  47:     -	        	                ENUM PORT_SER2          ; Serial port 2
  48:     -	        	                ENUM_END PORT_STATES    ; Number of states
  49:				;
  50:				
**** time.z80 ****
  36:				                include "maths.i"       ; Mathematical functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for ZARC Z80 Computer         *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 29/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef maths        ; Inhibit for this module
  16:				;
  17:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  18:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  19:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  20:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  21:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  22:				                extern crc16x       ; Software CRC-16 (XMODEM)
  23:				;
  24:				                endif
  25:				            endif
  26:				
**** time.z80 ****
  37:				                include "i2c.i"         ; I2C master interface
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//i2c.i ****
   1:				; ***********************************
   2:				; * ZARC I2C Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 23/7/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with the I2C (Inter-Integrated Circuit) master interface.
   8:				; Used for RTC (DS1672) initially, but it may turn out to have other uses.
   9:				;
  10:				; I2C error codes.
  11:     -	0000'         	I2C_ERR_OK      equ 0           ; No error
  12:     -	0001'         	I2C_ERR_BUSY    equ 1           ; Master interface stuck busy
  13:     -	0002'         	I2C_ERR_LB      equ 2           ; Loopback error
  14:     -	0003'         	I2C_ERR_NACK    equ 3           ; No acknowledge from receiving device
  15:     -	0004'         	I2C_ERR_RTC     equ 4           ; No valid time from RTC
  16:				;
  17:     -	0068'         	RTC_I2C_ADDR    equ 1101000b    ; DS1672 7-bit I2C device address
  18:				;
  19:				; The register map is defines as a structure.
  20:     -	        	                STRUCT
  21:     -	        	                STR_BYTE RTC_COUNT0_REG     ; LS byte of counter
  22:     -	        	                STR_BYTE RTC_COUNT1_REG
  23:     -	        	                STR_BYTE RTC_COUNT2_REG
  24:     -	        	                STR_BYTE RTC_COUNT3_REG     ; MS byte of counter
  25:     -	        	                STR_BYTE RTC_CTRL_REG       ; Control register
  26:     -	        	                STR_BYTE RTC_TRICKLE_REG    ; Trickle charger control register
  27:     -	        	                STR_END RTC_SIZE
  28:				
**** time.z80 ****
  38:				                include "time.i"        ; Routines associated with time
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//time.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Time Routines      *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				; The system keeps track of time as a Unix-style 32-bit number. Unlike Unix, this
   8:				; is treated as an unsigned integer and so will not suffer from the Year 2038 problem
   9:				; as it doubles the allowable postive time. It does, however, mean that it is not
  10:				; possible to represent dates before 1970.
  11:				
  12:				; Note that ld80 only considers the first six characters of labels significant.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0000'         	                ifndef time         ; Inhibit for this module
  23:				                endif
  24:				            endif
  25:				;
  26:				;
  27:     -	0046'         	TIM_EPOCH_YEAR  equ 70              ; Epoch year byte
  28:				;
  29:				; The following structure is used to store dates and times in human units. It is based
  30:				; on the Unix time.h tm structure.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BYTE TM_SECS    ; Seconds [0,59]
  33:     -	        	                STR_BYTE TM_MINS    ; Minutes [0,59]
  34:     -	        	                STR_BYTE TM_HOURS   ; Hours [0,23]
  35:     -	        	                STR_BYTE TM_MDAY    ; Day of month [1,31]
  36:     -	        	                STR_BYTE TM_MON     ; Month of year [1,12]
  37:     -	        	                STR_BYTE TM_YEAR    ; Years since 1900 [70,255]
  38:     -	        	                STR_BYTE TM_WDAY    ; Day of week [0,6] (Sunday = 0)
  39:     -	        	                STR_WORD TM_YDAY    ; Day of year [0,365]
  40:     -	        	                STR_BYTE TM_DST     ; Daylight savings status
  41:     -	        	                STR_END TM_SIZE
  42:				
  43:				; TM_DST can have any of the following values:
  44:     -	        	                ENUM_START
  45:     -	        	                ENUM TMDST_UNKNOWN
  46:     -	        	                ENUM TMDST_GMT      ; The time is GMT
  47:     -	        	                ENUM TMDST_DST      ; The time has DST applied (is one hour advanced)
  48:     -	        	                ENUM_END TMDST_NUM  ; Number of possible values
  49:				
**** time.z80 ****
  39:				                include "interrupts.i"  ; Interrupts
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//interrupts.i ****
   1:				; ***********************************
   2:				; * ZARC Interrupts Routines        *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef interrupts   ; Inhibit for this module
  16:				; Variables 
  17:				                extern itenfl   ; Int. enable flag (0 = basic, 1 = normal I/O mode)
  18:				                extern itdsct   ; DI nest count
  19:				; Functions
  20:				                extern itinit   ; Initialise interrupt variables and set basic I/O mode
  21:				                extern itstrt   ; Start monitor interrupts
  22:				                extern itena    ; Enable interrupts if safe
  23:				                extern itdis    ; Disable interrupts and keep count
  24:				                extern itsvec   ; Set interrupt vector to point to a new service routine
  25:				;
  26:				                endif
  27:				            endif
  28:				
**** time.z80 ****
  40:				                include "maths.i"       ; Mathematical functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for ZARC Z80 Computer         *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 29/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef maths        ; Inhibit for this module
  16:				;
  17:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  18:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  19:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  20:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  21:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  22:				                extern crc16x       ; Software CRC-16 (XMODEM)
  23:				;
  24:				                endif
  25:				            endif
  26:				
**** time.z80 ****
  41:				                include "utility.i"     ; Utility functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//utility.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Utility Routines   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef utility      ; Inhibit for this module
  16:				;
  17:				                extern cwnwln       ; Write new line characters to console.
  18:				                extern conwms       ; Print null-terminated string to the console
  19:				                extern conwmn       ; Print message <n> in a list
  20:				                extern skpspc       ; Step hl past spaces
  21:				                extern toupca       ; Convert character in A to upper case
  22:				                extern toloca       ; Convert character in A to lower case
  23:				                extern cwvich       ; Print only visible 7-bit characters
  24:				                extern cwpspc       ; Print a space
  25:				                extern mtwdli       ; Match word in a string against list of options
  26:				                extern cwphnb       ; Print least-significant nibble in A in hexadecimal
  27:				                extern cwphby       ; Print A in hexadecimal
  28:				                extern cwphwd       ; Print HL in hexadecimal
  29:				                extern cwpdby       ; Print A in decimal. Leading zeros are suppressed
  30:				                extern cwpdwd       ; Print HL in decimal. Leading zeros are suppressed
  31:				                extern cwpdlo       ; Print DEHL in decimal. Leading zeros are suppressed
  32:				                extern rdhxwd       ; Read a 16-bit hexadecimal number from a string
  33:				                extern rdduwd       ; Read a 16-bit unsigned decimal number from a string
  34:				                extern rddulo       ; Read a 32-bit unsigned decimal number from a string
  35:				;
  36:				                endif
  37:				            endif
  38:				;
  39:				;
  40:				; mtwdli (match word in a string against list of options) option bits. Each bit
  41:				; has the described effect if set.
  42:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  43:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  44:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  45:				
**** time.z80 ****
  42:				;
  43:				;
  44:				; *************
  45:				; * Externals *
  46:				; *************
  47:				;
  48:				; Routines
  49:				                public tird     ; Read current time and date
  50:				                public tiwr     ; Set time and date
  51:				                public tiitos   ; Convert integer time to structure
  52:				                public tistoi   ; Convert structure time to integer
  53:				                public cwptm    ; Print time structure to console
  54:				;
  55:				;
  56:				; *************
  57:				; * Constants *
  58:				; *************
  59:				;
  60:				; None
  61:				;
  62:				;
  63:				; *************
  64:				; * Main Code *
  65:				; *************
  66:				;
  67:				                cseg                    ; Code segment
  68:				;
  69:				;
  70:				; Read time from RTC hardware. The time is read until two consecutive reads provide
  71:				; the same time. This is to ensure that we are not reading during an overflow from one
  72:				; byte to another within the RTC. The read process is quite slow, so it makes sense to
  73:				; call this only during initialisation and rely on time maintained by interrupt for
  74:				; general use.
  75:				; Returns with:
  76:				; A - zero (OK) or I2C error code (I2C_ERR_xxx)
  77:				; DEHL - 32-bit time (if no error).
  78:    0+15	0000' DDE5    	tird            push ix
  79:   15+11	0002' C5      	                push bc
  80:   26+7	0003' 060A    	                ld b, 10                 ; Maximum retry count
  81:				; C is used to indicate buffer status. Bits are as follows:
  82:				; 0 - buffer for new time (0 = primary, 1 = secondary)
  83:				; 1 - at least one valid time has been read (enables comparison)
  84:   33+7	0005' 0E00    	                ld c, 0                 ; Use primary buffer and no valid time
  85:   40+11	0007' C5      	rrtc_rd_loop    push bc
  86:   51+7	0008' 0606    	                ld b, RTC_SIZE          ; Number of data bytes to receive
  87:   58+7	000A' 1668    	                ld d, RTC_I2C_ADDR      ; 7-bit DS1672 slave address
  88:   65+7	000C' 1E00    	                ld e, RTC_COUNT0_REG    ; Register address
  89:   72+10	000E' 210000  	                ld hl, rtc_regs_buff1   ; Point to primary register buffer
  90:   82+8	0011' CB41    	                bit 0, c
  91:   90+7+5	0013' 2803    	                jr z, rrtc_buffset      ; Jump if primary buffer in use
  92:   97+10	0015' 210600  	                ld hl, rtc_regs_buff2   ; Point to secondary register buffer
  93:  107+11	0018' E5      	rrtc_buffset    push hl                 ; Save buffer address
  94:  118+17	0019' CD0000  	                call i2crd              ; Read from I2C device
  95:  135+14	001C' DDE1    	                pop ix
  96:  149+10	001E' C1      	                pop bc                  ; Restore retry counter and buffer flags
  97:  159+4	001F' A7      	                and a
  98:  163+7+5	0020' 2054    	                jr nz, rrtc_retry       ; Jump on I2C read error with error code
  99:				; Perform basic checks.
 100:				; IX - points to the buffer in use.
 101:				; B - retry counter
 102:				; C - buffer status flags
 103:  170+19	0022' DD7E04  	                ld a, (ix + RTC_CTRL_REG)
 104:  189+8	0025' CB7F    	                bit 7, a
 105:  197+7+5	0027' 204B    	                jr nz, rrtc_bad_time    ; Error if oscillator disabled
 106:  204+19	0029' DD7E05  	                ld a, (ix + RTC_TRICKLE_REG)
 107:  223+4	002C' A7      	                and a
 108:  227+7+5	002D' 2045    	                jr nz, rrtc_bad_time    ; Jump if charger enabled
 109:				; We have read a credible time.
 110:  234+7	002F' 3E01    	                ld a, 1
 111:  241+4	0031' A9      	                xor c                   ; Toggle buffer in use bit
 112:  245+4	0032' 4F      	                ld c, a
 113:  249+8	0033' CB49    	                bit 1, c
 114:  257+7+5	0035' 2004    	                jr nz, rrtc_docompare
 115:				; This is the first valid read, so there is nothing to compare with.
 116:  264+8	0037' CBC9    	                set 1, c                ; Set valid flag for future reads
 117:  272+12	0039' 1839    	                jr rrtc_bad_time        ; Do another read
 118:				; We have read a time and have a previously read one to compare it with.
 119:  284+10	003B' 210000  	rrtc_docompare  ld hl, rtc_regs_buff1   ; Point to primary register buffer
 120:  294+8	003E' CB41    	                bit 0, c
 121:  302+7+5	0040' 2803    	                jr z, rrtc_buffset1     ; Jump if primary buffer in use
 122:  309+10	0042' 210600  	                ld hl, rtc_regs_buff2   ; Point to secondary register buffer
 123:				; Now do the compare.
 124:  319+19	0045' DD7E00  	rrtc_buffset1   ld a, (ix + RTC_COUNT0_REG)
 125:  338+7	0048' BE      	                cp (hl)
 126:  345+7+5	0049' 2029    	                jr nz, rrtc_bad_time
 127:  352+6	004B' 23      	                inc hl
 128:  358+19	004C' DD7E01  	                ld a, (ix + RTC_COUNT1_REG)
 129:  377+7	004F' BE      	                cp (hl)
 130:  384+7+5	0050' 2022    	                jr nz, rrtc_bad_time
 131:  391+6	0052' 23      	                inc hl
 132:  397+19	0053' DD7E02  	                ld a, (ix + RTC_COUNT2_REG)
 133:  416+7	0056' BE      	                cp (hl)
 134:  423+7+5	0057' 201B    	                jr nz, rrtc_bad_time
 135:  430+6	0059' 23      	                inc hl
 136:  436+19	005A' DD7E03  	                ld a, (ix + RTC_COUNT3_REG)
 137:  455+7	005D' BE      	                cp (hl)
 138:  462+7+5	005E' 2014    	                jr nz, rrtc_bad_time
 139:				; This time hasn't changed since the last read, so we have confidence in it. Read
 140:				; time into registers.
 141:  469+19	0060' DD6E00  	                ld l, (ix + RTC_COUNT0_REG)
 142:  488+6	0063' 23      	                inc hl
 143:  494+19	0064' DD6601  	                ld h, (ix + RTC_COUNT1_REG)
 144:  513+6	0067' 23      	                inc hl
 145:  519+19	0068' DD5E02  	                ld e, (ix + RTC_COUNT2_REG)
 146:  538+6	006B' 23      	                inc hl
 147:  544+19	006C' DD5603  	                ld d, (ix + RTC_COUNT3_REG)
 148:  563+10	006F' C1      	                pop bc
 149:  573+14	0070' DDE1    	                pop ix
 150:  587+4	0072' AF      	                xor a                   ; Set success code
 151:  591+10	0073' C9      	                ret
 152:				;
 153:				; We don't like the time we read.
 154:  601+7	0074' 3E04    	rrtc_bad_time   ld a, I2C_ERR_RTC       ; Set error code
 155:				; Re-read unless out of retries. The error code in A is that returned to the caller
 156:				; if we are out of retries.
 157:  608+8+5	0076' 108F    	rrtc_retry      djnz rrtc_rd_loop       ; Retry if applicable
 158:  616+10	0078' C1      	                pop bc
 159:  626+14	0079' DDE1    	                pop ix
 160:  640+10	007B' C9      	                ret                     ; Return with last error code
 161:				;
 162:				;
 163:				; Set time and date. This routine updates both the RTC hardware and the time
 164:				; maintained by the tick interrupt. When writing to the RTC, control registers
 165:				; are set up as well, so this will initialise the RTC from any state.
 166:				; Call with:
 167:				; DEHL - 32-bit time.
 168:				; Returns with:
 169:				; A - zero (OK) or I2C error code (I2C_ERR_xxx)
 170:  650+15	007C' DDE5    	tiwr            push ix
 171:				; Update the hardware RTC.
 172:  665+14	007E' DD210000	                ld ix, rtc_regs_buff1   ; Use primary register buffer
 173:				; Build register data in the buffer.
 174:  679+19	0082' DD7500  	                ld (ix + RTC_COUNT0_REG), l ; LS byte of counter
 175:  698+19	0085' DD7401  	                ld (ix + RTC_COUNT1_REG), h
 176:  717+19	0088' DD7302  	                ld (ix + RTC_COUNT2_REG), e
 177:  736+19	008B' DD7203  	                ld (ix + RTC_COUNT3_REG), d ; MS byte of counter
 178:  755+19	008E' DD360400	                ld (ix + RTC_CTRL_REG), 0   ; Enable oscillator
 179:  774+19	0092' DD360500	                ld (ix + RTC_TRICKLE_REG), 0    ; Disable trickle charger
 180:				; Write to RTC registers
 181:  793+7	0096' 0606    	                ld b, RTC_SIZE          ; Number of data bytes to write
 182:  800+7	0098' 1668    	                ld d, RTC_I2C_ADDR      ; 7-bit DS1672 slave address
 183:  807+7	009A' 1E00    	                ld e, RTC_COUNT0_REG    ; Register address
 184:  814+15	009C' DDE5    	                push ix                 ; Point hl to working area
 185:  829+10	009E' E1      	                pop hl
 186:  839+17	009F' CD0000  	                call i2cwr              ; Write to I2C device
 187:				; Return with A - zero (OK) or error code (I2C_ERR_xxx)
 188:  856+14	00A2' DDE1    	                pop ix
 189:  870+10	00A4' C9      	                ret
 190:				;
 191:				;
 192:				; Convert integer time to structure. Daylight savings is automatically applied if
 193:				; appropriate.
 194:				; Call with:
 195:				; DEHL - 32-bit time.
 196:				; IX - pointer to TM structure to be updated
 197:				; IX is preserved.
 198:  880+11	00A5' C5      	tiitos          push bc
 199:  891+16	00A6' 220C00  	                ld (int_time), hl       ; Save integer time
 200:  907+20	00A9' ED530E00	                ld (int_time + 2), de
 201:  927+19	00AD' DD360900	                ld (ix + TM_DST), TMDST_UNKNOWN ; Set initial DST state
 202:				; Start the conversion.
 203:  946+7	00B1' 0E3C    	its_start       ld c, 60                ; Divisor
 204:  953+17	00B3' CD0000  	                call madlbu             ; 32-bit / 8-bit unsigned divide
 205:  970+19	00B6' DD7700  	                ld (ix + TM_SECS), a    ; Seconds [0,59]
 206:				; DEHL - total minutes
 207:  989+7	00B9' 0E3C    	                ld c, 60                ; Divisor
 208:  996+17	00BB' CD0000  	                call madlbu             ; 32-bit / 8-bit unsigned divide
 209: 1013+19	00BE' DD7701  	                ld (ix + TM_MINS), a    ; Minutes [0,59]
 210:				; DEHL - total hours
 211: 1032+7	00C1' 0E18    	                ld c, 24                ; Divisor
 212: 1039+17	00C3' CD0000  	                call madlbu             ; 32-bit / 8-bit unsigned divide
 213: 1056+19	00C6' DD7702  	                ld (ix + TM_HOURS), a   ; Hours [0,23]
 214:				; DEHL - total days (0 to 49710, so D should be zero).
 215: 1075+4	00C9' 7A      	                ld a, d
 216: 1079+4	00CA' A7      	                and a
 217: 1083+10+7	00CB' C40000  	                call nz, panic          ; System panic if out of range
 218:				; Find day of week.
 219: 1093+11	00CE' D5      	                push de
 220: 1104+11	00CF' E5      	                push hl
 221: 1115+7	00D0' 0E07    	                ld c, 7                 ; Divisor
 222: 1122+17	00D2' CD0000  	                call madlbu             ; 32-bit / 8-bit unsigned divide
 223: 1139+7	00D5' C604    	                add 4                   ; 1/1/1970 was a Thursday
 224:				; Maintain range 0 to 6.
 225: 1146+7	00D7' FE07    	                cp 7
 226: 1153+7+5	00D9' 3802    	                jr c, its_goodday
 227: 1160+7	00DB' D607    	                sub 7                   ; Subtract a week
 228: 1167+19	00DD' DD7706  	its_goodday     ld (ix + TM_WDAY), a    ; Day of week [0,6] (Sunday = 0)
 229: 1186+10	00E0' E1      	                pop hl
 230: 1196+10	00E1' D1      	                pop de
 231:				; Find year. This is tricky as each year may or may not be a leap year.
 232:				; EHL is the time in days.
 233: 1206+7	00E2' 0E46    	                ld c, TIM_EPOCH_YEAR    ; Start with 1970
 234: 1213+11	00E4' D5      	its_yearloop    push de                 ; Save time
 235: 1224+11	00E5' E5      	                push hl
 236:				; Perform a trial subtraction, assuming a common (not leap) year initially.
 237:				; One common year is 365 (0x16d) days.
 238: 1235+4	00E6' 7D      	                ld a, l
 239: 1239+7	00E7' D66D    	                sub 0x6d
 240: 1246+4	00E9' 6F      	                ld l, a
 241: 1250+4	00EA' 7C      	                ld a, h
 242: 1254+7	00EB' DE01    	                sbc 0x01
 243: 1261+4	00ED' 67      	                ld h, a
 244: 1265+4	00EE' 7B      	                ld a, e
 245: 1269+7	00EF' DE00    	                sbc 0
 246: 1276+4	00F1' 5F      	                ld e, a
 247: 1280+7+5	00F2' 381B    	                jr c, its_yearcarry     ; Time remaining was < one common year
 248:				; Allow for leap years.
 249: 1287+4	00F4' 79      	                ld a, c
 250: 1291+17	00F5' CD8301  	                call leap_year
 251: 1308+7+5	00F8' 300E    	                jr nc, its_subyok
 252:				; Subtract a further day (the leap day).
 253: 1315+4	00FA' 7D      	                ld a, l
 254: 1319+7	00FB' D601    	                sub 0x01
 255: 1326+4	00FD' 6F      	                ld l, a
 256: 1330+4	00FE' 7C      	                ld a, h
 257: 1334+7	00FF' DE00    	                sbc 0
 258: 1341+4	0101' 67      	                ld h, a
 259: 1345+4	0102' 7B      	                ld a, e
 260: 1349+7	0103' DE00    	                sbc 0
 261: 1356+4	0105' 5F      	                ld e, a
 262: 1360+7+5	0106' 3807    	                jr c, its_yearcarry     ; Time remaining was < one day
 263:				; We have successfully subtracted a year from the total.
 264: 1367+4	0108' 0C      	its_subyok      inc c                   ; Update year
 265: 1371+6	0109' 33      	                inc sp                  ; Discard value before subtraction
 266: 1377+6	010A' 33      	                inc sp
 267: 1383+6	010B' 33      	                inc sp
 268: 1389+6	010C' 33      	                inc sp
 269: 1395+12	010D' 18D5    	                jr its_yearloop         ; Try subtracting another year
 270:				; The trial subtraction failed, so the remaining time is less than one year.
 271: 1407+10	010F' E1      	its_yearcarry   pop hl                  ; Restore time in days before subtraction
 272: 1417+10	0110' D1      	                pop de
 273: 1427+19	0111' DD7105  	                ld (ix + TM_YEAR), c    ; Years since 1900 [70,255]
 274:				; EHL - days (0 to 365, so E should be zero).
 275: 1446+4	0114' 7B      	                ld a, e
 276: 1450+4	0115' A7      	                and a
 277: 1454+10+7	0116' C40000  	                call nz, panic          ; System panic if out of range
 278:				; C - years since 1900 [70,255]
 279:				; HL - day number of the year [0,365]
 280: 1464+19	0119' DD7507  	                ld (ix + TM_YDAY), l        ; Day of year [0,365]
 281: 1483+19	011C' DD7408  	                ld (ix + TM_YDAY + 1), h
 282:				;
 283:				; Find month. This is also tricky as each year may or may not be a leap year.
 284: 1502+7	011F' 0600    	                ld b, 0                 ; Start with January
 285: 1509+4	0121' EB      	                ex de, hl               ; Move days to DE
 286: 1513+10	0122' 210003  	                ld hl, month_days       ; Point to days in month table
 287:				; B - month
 288:				; C - years since 1900 [70,255]
 289:				; DE - day of the year [0,365]
 290:				; HL - pointer to days in month table
 291: 1523+11	0125' D5      	its_monthloop   push de                 ; Save days
 292:				; Perform a trial subtraction.
 293: 1534+4	0126' 7B      	                ld a, e
 294: 1538+7	0127' 96      	                sub (hl)                ; Subtract length of month
 295: 1545+4	0128' 5F      	                ld e, a
 296: 1549+4	0129' 7A      	                ld a, d
 297: 1553+7	012A' DE00    	                sbc 0
 298: 1560+4	012C' 57      	                ld d, a
 299: 1564+7+5	012D' 381B    	                jr c, its_monthcarry    ; Time remaining was < month length
 300:				; Allow for leap years.
 301: 1571+4	012F' 79      	                ld a, c
 302: 1575+17	0130' CD8301  	                call leap_year
 303: 1592+7+5	0133' 300F    	                jr nc, its_submok
 304:				; The current year is a leap year, so we need to subtract an extra day for February.
 305: 1599+4	0135' 78      	                ld a, b
 306: 1603+7	0136' FE01    	                cp 1
 307: 1610+7+5	0138' 200A    	                jr nz, its_submok       ; Jump if not February
 308:				; Subtract a further day (the leap day).
 309: 1617+4	013A' 7B      	                ld a, e
 310: 1621+7	013B' D601    	                sub 0x01
 311: 1628+4	013D' 5F      	                ld e, a
 312: 1632+4	013E' 7A      	                ld a, d
 313: 1636+7	013F' DE00    	                sbc 0
 314: 1643+4	0141' 57      	                ld d, a
 315: 1647+7+5	0142' 3806    	                jr c, its_monthcarry    ; Time remaining was < one day
 316:				; We have successfully subtracted a month from the total.
 317: 1654+4	0144' 04      	its_submok      inc b                   ; Update month
 318: 1658+6	0145' 23      	                inc hl                  ; Update days in month pointer
 319: 1664+6	0146' 33      	                inc sp                  ; Discard value before subtraction
 320: 1670+6	0147' 33      	                inc sp
 321: 1676+12	0148' 18DB    	                jr its_monthloop        ; Try subtracting another month
 322:				; The trial subtraction failed, so the remaining time is less than one month.
 323: 1688+10	014A' D1      	its_monthcarry  pop de                  ; Restore time in days before subtraction
 324: 1698+4	014B' 04      	                inc b                   ; Adjust range
 325: 1702+19	014C' DD7004  	                ld (ix + TM_MON), b     ; Month of year [1,12]
 326:				; DE - days (0 to 31, so D should be zero).
 327: 1721+4	014F' 7A      	                ld a, d
 328: 1725+4	0150' A7      	                and a
 329: 1729+10+7	0151' C40000  	                call nz, panic          ; System panic if out of range
 330: 1739+4	0154' 1C      	                inc e                   ; Adjust range
 331: 1743+19	0155' DD7303  	                ld (ix + TM_MDAY), e    ; Day of month [1,31]
 332:				;
 333:				; Correct for DST if required.
 334: 1762+7	0158' 3E00    	                ld a, TMDST_UNKNOWN
 335: 1769+19	015A' DDBE09  	                cp (ix + TM_DST)
 336: 1788+7+5	015D' 2022    	                jr nz, its_exit         ; Exit if already set
 337:				; DST hasn't already been considered.
 338: 1795+17	015F' CDA102  	                call check_dst
 339: 1812+19	0162' DD360901	                ld (ix + TM_DST), TMDST_GMT
 340: 1831+7+5	0166' 3019    	                jr nc, its_exit
 341:				; DST correction required.
 342: 1838+19	0168' DD360902	                ld (ix + TM_DST), TMDST_DST
 343:				; 
 344:				; Add one hour to the integer time and re-convert.
 345: 1857+16	016C' 2A0C00  	                ld hl, (int_time)       ; Fetch integer time
 346: 1873+20	016F' ED5B0E00	                ld de, (int_time + 2)
 347: 1893+10	0173' 01100E  	                ld bc, 3600             ; One hour in seconds
 348: 1903+11	0176' 09      	                add hl, bc              ; Add to LSW
 349: 1914+10	0177' 010000  	                ld bc, 0
 350: 1924+4	017A' EB      	                ex de, hl
 351: 1928+15	017B' ED4A    	                adc hl, bc              ; Propagate carry to DE
 352: 1943+4	017D' EB      	                ex de, hl
 353:				; Restart the conversion.
 354: 1947+10	017E' C3B100  	                jp its_start            ; Restart the conversion
 355:				;
 356: 1957+10	0181' C1      	its_exit        pop bc
 357: 1967+10	0182' C9      	                ret
 358:				;
 359:				;
 360:				; Determine whether or not the year supplied is a leap year using the algorithm:
 361:				; if (year is not divisible by 4) then (it is a common year)
 362:				; else if (year is not divisible by 100) then (it is a leap year)
 363:				; else if (year is not divisible by 400) then (it is a common year)
 364:				; else (it is a leap year)
 365:				; From https://en.wikipedia.org/wiki/Leap_year#Algorithm
 366:				; Call with:
 367:				; A - Years since 1900 [70,255].
 368:				; Returns with:
 369:				; C flag - set to indicate a leap year.
 370: 1977+11	0183' F5      	leap_year       push af
 371: 1988+7	0184' E603    	                and 3
 372: 1995+7+5	0186' 2007    	                jr nz, ly_common
 373:				; Year is divisible by 4, so it is probably a leap year.
 374: 2002+10	0188' F1      	                pop af
 375:				; We have a leap year if it is not divisible by 100. If it is divisible by 100 and
 376:				; by 400 then it is a common year. Only years 1970 to 2155 are applicable, so we
 377:				; have only 2000 and 2100 to test.
 378: 2012+7	0189' FEC8    	                cp 200
 379: 2019+7+5	018B' 2803    	                jr z, ly_common1        ; 2100 is a common year
 380:				; 2000 is a normal leap year as it is divisible by 400.
 381: 2026+4	018D' 37      	                scf                     ; Indicate leap year
 382: 2030+10	018E' C9      	                ret
 383:				;
 384: 2040+10	018F' F1      	ly_common       pop af
 385: 2050+4	0190' A7      	ly_common1      and a                   ; Indicate common (not leap) year
 386: 2054+10	0191' C9      	                ret
 387:				;
 388:				;
 389:				; Convert structure time to integer. No validation is performed, so out of range
 390:				; values will result in an odd time being returned. Daylight savings time is
 391:				; handled according to the TM_DST value.
 392:				; Call with:
 393:				; IX - pointer to TM structure
 394:				; Returns with:
 395:				; DEHL - 32-bit time.
 396:				; IX is preserved.
 397: 2064+11	0192' C5      	tistoi          push bc
 398:				; The first part of the calculation is in days. The maximum value is approximately
 399:				; (256-70) * 365.25 = 67936.5, irritatingly just too big for 16 bits. Loop for
 400:				; each year, accumulating the number of days as we go.
 401: 2075+7	0193' 0E00    	                ld c, 0
 402: 2082+10	0195' 210000  	                ld hl, 0
 403:				; CHL - days since epoch.
 404: 2092+7	0198' 0646    	                ld b, TIM_EPOCH_YEAR    ; Start at epoch year
 405: 2099+19	019A' DD7E05  	sti_year_lp     ld a, (ix + TM_YEAR)    ; Years since 1900 [70,255]
 406: 2118+4	019D' B8      	                cp b
 407: 2122+7+5	019E' 2819    	                jr z, sti_year_dn       ; Exit if years complete
 408:				; Add a common year in days
 409: 2129+10	01A0' 116D01  	                ld de, 365
 410: 2139+11	01A3' 19      	                add hl, de
 411: 2150+7	01A4' 3E00    	                ld a, 0
 412: 2157+4	01A6' 89      	                adc c                   ; Propagate any carry
 413: 2161+4	01A7' 4F      	                ld c, a
 414: 2165+4	01A8' 78      	                ld a, b
 415: 2169+17	01A9' CD8301  	                call leap_year
 416: 2186+7+5	01AC' 3008    	                jr nc, sti_year_next
 417:				; Add a day for leap years
 418: 2193+10	01AE' 110100  	                ld de, 1
 419: 2203+11	01B1' 19      	                add hl, de
 420: 2214+7	01B2' 3E00    	                ld a, 0
 421: 2221+4	01B4' 89      	                adc c                   ; Propagate any carry
 422: 2225+4	01B5' 4F      	                ld c, a
 423: 2229+4	01B6' 04      	sti_year_next   inc b                   ; Next year
 424: 2233+12	01B7' 18E1    	                jr sti_year_lp
 425:				; CHL - days since epoch.
 426:				; Loop for each month, accumulating the number of days as we go.
 427: 2245+7	01B9' 0600    	sti_year_dn     ld b, 0                 ; Start at January
 428: 2252+4	01BB' 78      	sti_mon_lp      ld a, b
 429: 2256+4	01BC' 3C      	                inc a                   ; Adjust range to 1 to 12
 430: 2260+19	01BD' DDBE04  	                cp (ix + TM_MON)        ; Month of year [1,12]
 431: 2279+7+5	01C0' 2825    	                jr z, sti_mon_dn        ; Exit if months complete
 432: 2286+11	01C2' E5      	                push hl
 433:				; Calculate address in table.
 434: 2297+10	01C3' 210003  	                ld hl, month_days
 435: 2307+4	01C6' 7D      	                ld a, l
 436: 2311+4	01C7' 80      	                add b
 437: 2315+4	01C8' 6F      	                ld l, a
 438: 2319+4	01C9' 7C      	                ld a, h
 439: 2323+7	01CA' CE00    	                adc 0
 440: 2330+4	01CC' 67      	                ld h, a
 441: 2334+7	01CD' 5E      	                ld e, (hl)              ; Find number of days
 442: 2341+10	01CE' E1      	                pop hl
 443:				; In leap years, February has 29 days.
 444: 2351+7	01CF' 3E01    	                ld a, 1
 445: 2358+4	01D1' B8      	                cp b
 446: 2362+7+5	01D2' 2009    	                jr nz, sti_mon_add      ; Jump if not February
 447: 2369+19	01D4' DD7E05  	                ld a, (ix + TM_YEAR)    ; Years since 1900 [70,255]
 448: 2388+17	01D7' CD8301  	                call leap_year
 449: 2405+7+5	01DA' 3001    	                jr nc, sti_mon_add      ; Jump if not a leap year
 450: 2412+4	01DC' 1C      	                inc e                   ; Add a day
 451:				; Add E to the number of days so far.
 452: 2416+7	01DD' 1600    	sti_mon_add     ld d, 0
 453: 2423+11	01DF' 19      	                add hl, de
 454: 2434+7	01E0' 3E00    	                ld a, 0
 455: 2441+4	01E2' 89      	                adc c                   ; Propagate any carry
 456: 2445+4	01E3' 4F      	                ld c, a
 457: 2449+4	01E4' 04      	sti_mon_next    inc b                   ; Next month
 458: 2453+12	01E5' 18D4    	                jr sti_mon_lp
 459:				; CHL - days since epoch.
 460:				; Now add the number of days in this month.
 461: 2465+7	01E7' 1600    	sti_mon_dn      ld d, 0
 462: 2472+19	01E9' DD5E03  	                ld e, (ix + TM_MDAY)    ; Day of month [1,31]
 463: 2491+4	01EC' 1D      	                dec e                   ; Adjust range to 0 to 30                
 464: 2495+11	01ED' 19      	                add hl, de
 465: 2506+7	01EE' 3E00    	                ld a, 0
 466: 2513+4	01F0' 89      	                adc c                   ; Propagate any carry
 467: 2517+4	01F1' 5F      	                ld e, a                 ; and move result to DE
 468: 2521+7	01F2' 1600    	                ld d, 0
 469:				; DEHL - days since epoch (we will need the extra bits now).
 470:				; Multiply by 24 to find hours since epoch.
 471: 2528+7	01F4' 0E18    	                ld c, 24
 472: 2535+17	01F6' CD0000  	                call mamlbu             ; 32-bit * 8-bit unsigned multiply
 473:				; Result is in CDEHL, but we can ignore the top 8 bits.
 474:				; Add hours.
 475: 2552+7	01F9' 0600    	                ld b, 0
 476: 2559+19	01FB' DD4E02  	                ld c, (ix + TM_HOURS)   ; Hours [0,23]
 477: 2578+11	01FE' 09      	                add hl, bc
 478: 2589+7	01FF' 0E00    	                ld c, 0                 ; Now BC = 0
 479: 2596+4	0201' EB      	                ex de, hl
 480: 2600+15	0202' ED4A    	                adc hl, bc              ; Propagate any carry to DE
 481: 2615+4	0204' EB      	                ex de, hl
 482:				; DEHL - hours since epoch.
 483:				; Multiply by 60 to find minutes since epoch.
 484: 2619+7	0205' 0E3C    	                ld c, 60
 485: 2626+17	0207' CD0000  	                call mamlbu             ; 32-bit * 8-bit unsigned multiply
 486:				; Add minutes.
 487: 2643+7	020A' 0600    	                ld b, 0
 488: 2650+19	020C' DD4E01  	                ld c, (ix + TM_MINS)    ; Minutes [0,59]
 489: 2669+11	020F' 09      	                add hl, bc
 490: 2680+7	0210' 0E00    	                ld c, 0                 ; Now BC = 0
 491: 2687+4	0212' EB      	                ex de, hl
 492: 2691+15	0213' ED4A    	                adc hl, bc              ; Propagate any carry to DE
 493: 2706+4	0215' EB      	                ex de, hl
 494:				; DEHL - minutes since epoch.
 495:				; Multiply by 60 to find seconds since epoch.
 496: 2710+7	0216' 0E3C    	                ld c, 60
 497: 2717+17	0218' CD0000  	                call mamlbu             ; 32-bit * 8-bit unsigned multiply
 498:				; Add seconds.
 499: 2734+7	021B' 0600    	                ld b, 0
 500: 2741+19	021D' DD4E00  	                ld c, (ix + TM_SECS)    ; Seconds [0,59]
 501: 2760+11	0220' 09      	                add hl, bc
 502: 2771+7	0221' 0E00    	                ld c, 0                 ; Now BC = 0
 503: 2778+4	0223' EB      	                ex de, hl
 504: 2782+15	0224' ED4A    	                adc hl, bc              ; Propagate any carry to DE
 505: 2797+4	0226' EB      	                ex de, hl
 506:				; DEHL - seconds since epoch.
 507:				; If the time in the structure is DST, we need to subtract an hour (integer time
 508:				; is always GMT). Unknown DST status is treated as GMT.
 509: 2801+19	0227' DD7E09  	                ld a, (ix + TM_DST)     ; Daylight savings status
 510: 2820+7	022A' FE02    	                cp TMDST_DST
 511: 2827+7+5	022C' 200D    	                jr nz, sti_done
 512:				; Subtract an hour.
 513: 2834+10	022E' 01100E  	                ld bc, 3600             ; One hour in seconds
 514: 2844+4	0231' A7      	                and a
 515: 2848+15	0232' ED42    	                sbc hl, bc              ; Subtract from LSW
 516: 2863+10	0234' 010000  	                ld bc, 0
 517: 2873+4	0237' EB      	                ex de, hl
 518: 2877+15	0238' ED42    	                sbc hl, bc              ; Propagate carry to DE
 519: 2892+4	023A' EB      	                ex de, hl
 520: 2896+10	023B' C1      	sti_done        pop bc
 521: 2906+10	023C' C9      	                ret
 522:				;
 523:				;
 524:				; Display the structure in the form:
 525:				; <hours>:<minutes>:<seconds> [<GMT> Z <BST>] <day of week> <day>/<month>/<year>
 526:				; Call with:
 527:				; IX - pointer to TM structure
 528:				; IX is preserved.
 529: 2916+11	023D' C5      	cwptm           push bc
 530: 2927+11	023E' D5      	                push de
 531: 2938+11	023F' E5      	                push hl
 532: 2949+19	0240' DD7E02  	                ld a, (ix + TM_HOURS)
 533: 2968+17	0243' CD0000  	                call cwpdby             ; Print hours in decimal
 534: 2985+7	0246' 3E3A    	                ld a, ':'
 535: 2992+17	0248' CD0000  	                call conwch 
 536:				;
 537: 3009+19	024B' DD7E01  	                ld a, (ix + TM_MINS)
 538: 3028+17	024E' CD0000  	                call cwpdby             ; Print minutes in decimal
 539: 3045+7	0251' 3E3A    	                ld a, ':'
 540: 3052+17	0253' CD0000  	                call conwch 
 541:				;
 542: 3069+19	0256' DD7E00  	                ld a, (ix + TM_SECS)
 543: 3088+17	0259' CD0000  	                call cwpdby             ; Print seconds in decimal
 544: 3105+17	025C' CD0000  	                call cwpspc             ; Print a space
 545:				;
 546: 3122+19	025F' DD7E06  	                ld a, (ix + TM_WDAY)
 547: 3141+10	0262' 210C03  	                ld hl, tim_weekdays
 548: 3151+7	0265' 0E7C    	                ld c, "|"               ; Separator
 549: 3158+17	0267' CD0000  	                call conwmn             ; Print message <n> in a list
 550:				; Note - errors are ignored
 551: 3175+17	026A' CD0000  	                call cwpspc             ; Print a space
 552:				;
 553: 3192+19	026D' DD7E03  	                ld a, (ix + TM_MDAY)
 554: 3211+17	0270' CD0000  	                call cwpdby             ; Print day of month in decimal
 555: 3228+7	0273' 3E2F    	                ld a, '/'
 556: 3235+17	0275' CD0000  	                call conwch 
 557:				;
 558: 3252+19	0278' DD7E04  	                ld a, (ix + TM_MON)
 559: 3271+17	027B' CD0000  	                call cwpdby             ; Print month in decimal
 560: 3288+7	027E' 3E2F    	                ld a, '/'
 561: 3295+17	0280' CD0000  	                call conwch
 562:				;
 563: 3312+10	0283' 116C07  	                ld de, 1900
 564: 3322+7	0286' 2600    	                ld h, 0
 565: 3329+19	0288' DD6E05  	                ld l, (ix + TM_YEAR)    ; Years since 1900
 566: 3348+11	028B' 19      	                add hl, de              ; Add year offset
 567: 3359+17	028C' CD0000  	                call cwpdwd             ; Print year in decimal
 568:				;
 569:				; Display "GMT" or "BST" as appropriate. DST status should always be known when
 570:				; this routine is called, so users should never see the error state.
 571: 3376+17	028F' CD0000  	                call cwpspc             ; Print a space
 572: 3393+19	0292' DD7E09  	                ld a, (ix + TM_DST)     ; Daylight savings status
 573: 3412+10	0295' 214503  	                ld hl, dst_msgs
 574: 3422+7	0298' 0E7C    	                ld c, "|"               ; Separator
 575: 3429+17	029A' CD0000  	                call conwmn             ; Print message <n> in a list
 576:				;
 577: 3446+10	029D' E1      	                pop hl
 578: 3456+10	029E' D1      	                pop de
 579: 3466+10	029F' C1      	                pop bc
 580: 3476+10	02A0' C9      	                ret
 581:				;
 582:				;
 583:				; Determine whether or not the time and date described should have daylight
 584:				; savings applied. From https://www.gov.uk/when-do-the-clocks-change
 585:				; "In the UK the clocks go forward 1 hour at 1am on the last Sunday in March, and
 586:				; back 1 hour at 2am on the last Sunday in October."
 587:				; Note that this routine requires that TM_WDAY is correct.
 588:				; Call with:
 589:				; IX - pointer to TM structure
 590:				; Returns with:
 591:				; C flag - set to indicate that daylight saving is active.
 592: 3486+11	02A1' C5      	check_dst       push bc
 593: 3497+19	02A2' DD7E04  	                ld a, (ix + TM_MON)     ; Month of year [1,12]
 594: 3516+7	02A5' FE03    	                cp 3
 595: 3523+7+5	02A7' 3850    	                jr c, cdst_not_dst      ; No DST in January or February
 596: 3530+7+5	02A9' 2027    	                jr nz, cdst_apr_dec     ; Jump if April to December
 597:				; March
 598: 3537+19	02AB' DD7E03  	                ld a, (ix + TM_MDAY)    ; Day of month [1,31]
 599: 3556+7	02AE' D619    	                sub 25
 600: 3563+7+5	02B0' 3847    	                jr c, cdst_not_dst      ; No DST if not the last week
 601:				; Last week in March
 602:				; Clocks go forward 1 hour at 1am on the last Sunday in March.
 603: 3570+4	02B2' 4F      	                ld c, a
 604:				; C - day in last week in March (0 to 6)
 605: 3574+19	02B3' DD7E06  	                ld a, (ix + TM_WDAY)    ; Day of week [0,6] (Sunday = 0)
 606: 3593+4	02B6' 91      	                sub c
 607: 3597+7+5	02B7' 3002    	                jr nc, cdst_mar_nc
 608: 3604+7	02B9' C607    	                add 7                   ; Maintain range (0 to 6)
 609:				; A - day of week of the 25th day of the month.
 610: 3611+4	02BB' A7      	cdst_mar_nc     and a
 611: 3615+7+5	02BC' 2802    	                jr z, cdst_mar_idn      ; Jump if the 25th is a Sunday
 612: 3622+7	02BE' EE07    	                xor 7                   ; Invert, so Sat gives 1, Mon gives 6 etc.
 613:				; Now a gives number of days from the 25 to the first Sunday.
 614: 3629+4	02C0' B9      	cdst_mar_idn    cp c
 615: 3633+7+5	02C1' 3808    	                jr c, cdst_dst
 616: 3640+7+5	02C3' 2034    	                jr nz, cdst_not_dst
 617:				; We are on the day of the change. DST begins at 1 AM.
 618: 3647+19	02C5' DD7E02  	                ld a, (ix + TM_HOURS)   ; Hours [0,23]
 619: 3666+4	02C8' A7      	                and a
 620: 3670+7+5	02C9' 282E    	                jr z, cdst_not_dst      ; Jump if not time yet
 621:				; DST is active.
 622: 3677+10	02CB' C1      	cdst_dst        pop bc
 623: 3687+19	02CC' DD360902	                ld (ix + TM_DST), TMDST_DST  ; Daylight savings flag
 624: 3706+4	02D0' 37      	                scf                     ; Indicate leap year
 625: 3710+10	02D1' C9      	                ret
 626:				;
 627:				; April to December
 628: 3720+7	02D2' FE0A    	cdst_apr_dec    cp 10
 629: 3727+7+5	02D4' 38F5    	                jr c, cdst_dst          ; DST if April to September
 630: 3734+7+5	02D6' 2021    	                jr nz, cdst_not_dst     ; No DST in November or December
 631:				; October
 632:				; Clocks go back 1 hour at 2am on the last Sunday in October.
 633: 3741+19	02D8' DD7E03  	                ld a, (ix + TM_MDAY)    ; Day of month [1,31]
 634: 3760+7	02DB' D619    	                sub 25
 635: 3767+7+5	02DD' 38EC    	                jr c, cdst_dst          ; DST if not the last week
 636:				; Last week in October
 637: 3774+4	02DF' 4F      	                ld c, a
 638:				; C - day in last week in October (0 to 6)
 639: 3778+19	02E0' DD7E06  	                ld a, (ix + TM_WDAY)    ; Day of week [0,6] (Sunday = 0)
 640: 3797+4	02E3' 91      	                sub c
 641: 3801+7+5	02E4' 3002    	                jr nc, cdst_oct_nc
 642: 3808+7	02E6' C607    	                add 7                   ; Maintain range (0 to 6)
 643:				; A - day of week of the 25th day of the month.
 644: 3815+4	02E8' A7      	cdst_oct_nc     and a
 645: 3819+7+5	02E9' 2802    	                jr z, cdst_oct_idn      ; Jump if the 25th is a Sunday
 646: 3826+7	02EB' EE07    	                xor 7                   ; Invert, so Sat gives 1, Mon gives 6 etc.
 647:				; Now a gives number of days from the 25 to the first Sunday.
 648: 3833+4	02ED' B9      	cdst_oct_idn    cp c
 649: 3837+7+5	02EE' 3809    	                jr c, cdst_not_dst
 650: 3844+7+5	02F0' 20D9    	                jr nz, cdst_dst
 651:				; We are on the day of the change. DST ends at 2 AM.
 652: 3851+19	02F2' DD7E02  	                ld a, (ix + TM_HOURS)   ; Hours [0,23]
 653: 3870+7	02F5' FE02    	                cp 2
 654: 3877+7+5	02F7' 38D2    	                jr c, cdst_dst          ; Jump if not time yet
 655:				; DST is not active.
 656: 3884+10	02F9' C1      	cdst_not_dst    pop bc
 657: 3894+19	02FA' DD360901	                ld (ix + TM_DST), TMDST_GMT ; Daylight savings flag
 658: 3913+4	02FE' A7      	                and a                   ; Indicate no DST
 659: 3917+10	02FF' C9      	                ret
 660:				;
 661:				;
 662:				; *************
 663:				; * Constants *
 664:				; *************
 665:				;
 666:				; Days in each month. In leap years, February has 29 days.
 667:     -	0300' 1F1C1F1E	month_days      byte 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
	              1F1E1F1F
	              1E1F1E1F
 668:     -	030C' 53756E64	tim_weekdays    byte "Sunday|Monday|Tuesday|Wednesday|"
	              61797C4D
	              6F6E6461
	              797C5475
	              65736461
	              797C5765
	              646E6573
	              6461797C
 669:     -	032C' 54687572	                byte "Thursday|Friday|Saturday", 0
	              73646179
	              7C467269
	              6461797C
	              53617475
	              72646179
	              00
 670:     -	0345' 4453543F	dst_msgs        byte "DST?|GMT|BST",0
	              7C474D54
	              7C425354
	              00
 671:				;
 672:				;
 673:				;
 674:				; *************
 675:				; * Variables *
 676:				; *************
 677:				;
 678:				;
 679:				; Note: linker "-c" option is used, so no data is initialised here.
 680:				                dseg                ; Data segment
 681:				;
 682:     -	0000"         	rtc_regs_buff1  defs RTC_SIZE       ; Primary RTC registers working area
 683:     -	0006"         	rtc_regs_buff2  defs RTC_SIZE       ; Secondary RTC registers working area
 684:     -	000C"         	int_time        defs 4              ; Temporary store for integer time
 685:				;
 686:     -	0010"         	                end



Statistics:

     4	passes
     0	jr promotions
   346	symbols
   850	bytes

   141	macro calls
  1320	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
I2C_CSR_ACKN_BIT=00        0
I2C_CSR_ACKN_MASK=01        1
I2C_CSR_BUSY_BIT=07        7
I2C_CSR_BUSY_MASK=80        128
I2C_CSR_START_BIT=01        1
I2C_CSR_START_MASK=02        2
I2C_CSR_STOP_BIT=02        2
I2C_CSR_STOP_MASK=04        4
I2C_ERR_BUSY   =01        1
I2C_ERR_LB     =02        2
I2C_ERR_NACK   =03        3
I2C_ERR_OK     =00        0
I2C_ERR_RTC    =04        4
INTS_NUM       =08        8
INT_SER1_RX_BIT=01        1
INT_SER1_RX_MASK=02        2
INT_SER1_RX_VEC=01        1
INT_SER1_TX_BIT=00        0
INT_SER1_TX_MASK=01        1
INT_SER1_TX_VEC=00        0
INT_SER2_RX_BIT=03        3
INT_SER2_RX_MASK=08        8
INT_SER2_RX_VEC=03        3
INT_SER2_TX_BIT=02        2
INT_SER2_TX_MASK=04        4
INT_SER2_TX_VEC=02        2
INT_TICK_BIT   =04        4
INT_TICK_MASK  =10        16
INT_TICK_VEC   =04        4
IOA_CONTROL    =02        2
IOA_CRC_0      =24        36
IOA_CRC_1      =25        37
IOA_CRC_DATA   =26        38
IOA_FPGA_MAJREV=00        0
IOA_FPGA_MINREV=01        1
IOA_FP_SW      =03        3
IOA_I2C_CSR    =18        24
IOA_I2C_DATA   =19        25
IOA_INT_EN     =08        8
IOA_INT_PEND   =0A        10
IOA_MMAP_0     =04        4
IOA_MMAP_1     =05        5
IOA_MMAP_2     =06        6
IOA_MMAP_3     =07        7
IOA_NMI_REASONS=0C        12
IOA_SER1_CSR   =10        16
IOA_SER1_DATA  =11        17
IOA_SER2_CSR   =12        18
IOA_SER2_DATA  =13        19
IOA_SPI_CSR    =20        32
IOA_SPI_DATA   =21        33
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MMAP_PAGE_MASK =3F        63
MMAP_PROT_BIT  =07        7
MMAP_PROT_MASK =80        128
MMAP_SUPER_BIT =06        6
MMAP_SUPER_MASK=40        64
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MS_PER_TICK    =64        100
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NMI_PROT_VIOL_BIT=01        1
NMI_PROT_VIOL_MASK=02        2
NMI_REASONS_ALL=0F        15
NMI_REASONS_NUM=04        4
NMI_SUPER_VIOL_BIT=02        2
NMI_SUPER_VIOL_MASK=04        4
NMI_SWITCH_BIT =00        0
NMI_SWITCH_MASK=01        1
NMI_TRACE_BIT  =03        3
NMI_TRACE_MASK =08        8
PORT_SER1      =00        0
PORT_SER2      =01        1
PORT_STATES    =02        2
RTC_COUNT0_REG =00        0
RTC_COUNT1_REG =01        1
RTC_COUNT2_REG =02        2
RTC_COUNT3_REG =03        3
RTC_CTRL_REG   =04        4
RTC_I2C_ADDR   =68        104
RTC_SIZE       =06        6
RTC_TRICKLE_REG=05        5
SER_CSR_FRAME_ERR_BIT=03        3
SER_CSR_FRAME_ERR_MASK=08        8
SER_CSR_RX_ALHALF_BIT=01        1
SER_CSR_RX_ALHALF_MASK=02        2
SER_CSR_RX_EMPTY_BIT=00        0
SER_CSR_RX_EMPTY_MASK=01        1
SER_CSR_RX_FULL_BIT=02        2
SER_CSR_RX_FULL_MASK=04        4
SER_CSR_TX_ALHALF_BIT=05        5
SER_CSR_TX_ALHALF_MASK=20        32
SER_CSR_TX_EMPTY_BIT=04        4
SER_CSR_TX_EMPTY_MASK=10        16
SER_CSR_TX_FULL_BIT=06        6
SER_CSR_TX_FULL_MASK=40        64
SPI_CSR_BUSY_BIT=07        7
SPI_CSR_BUSY_MASK=80        128
SPI_CSR_FAST_BIT=00        0
SPI_CSR_FAST_MASK=01        1
SPI_CSR_MC_SS_BIT=01        1
SPI_CSR_MC_SS_MASK=02        2
SYSCTRL_MAPARM_BIT=03        3
SYSCTRL_MAPARM_MASK=08        8
SYSCTRL_MMAPN_BIT=04        4
SYSCTRL_MMAPN_MASK=10        16
SYSCTRL_MMAP_BIT=01        1
SYSCTRL_MMAP_MASK=02        2
SYSCTRL_NMCLR_BIT=02        2
SYSCTRL_NMCLR_MASK=04        4
SYSCTRL_RESERVED_BIT=07        7
SYSCTRL_RESERVED_MASK=80        128
SYSCTRL_TRARM_BIT=00        0
SYSCTRL_TRARM_MASK=01        1
SYSCTRL_TRPRE0_BIT=05        5
SYSCTRL_TRPRE0_MASK=20        32
SYSCTRL_TRPRE1_BIT=06        6
SYSCTRL_TRPRE1_MASK=40        64
TICK_FREQ      =0A        10
TIM_EPOCH_YEAR =46        70
TMDST_DST      =02        2
TMDST_GMT      =01        1
TMDST_NUM      =03        3
TMDST_UNKNOWN  =00        0
TM_DST         =09        9
TM_HOURS       =02        2
TM_MDAY        =03        3
TM_MINS        =01        1
TM_MON         =04        4
TM_SECS        =00        0
TM_SIZE        =0A        10
TM_WDAY        =06        6
TM_YDAY        =07        7
TM_YEAR        =05        5
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
cdst_apr_dec     2D2'     722
cdst_dst         2CB'     715
cdst_mar_idn     2C0'     704
cdst_mar_nc      2BB'     699
cdst_not_dst     2F9'     761
cdst_oct_idn     2ED'     749
cdst_oct_nc      2E8'     744
check_dst        2A1'     673
conrch          00        0 (extern)
consta          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
coport          00        0 (extern)
crc16x          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwptm            23D'     573 (public)
cwvich          00        0 (extern)
dst_msgs         345'     837
enum_counter   =03        3
i2crd           00        0 (extern)
i2cwr           00        0 (extern)
int_time        0C"       12
itdis           00        0 (extern)
itdsct          00        0 (extern)
itena           00        0 (extern)
itenfl          00        0 (extern)
itinit          00        0 (extern)
its_exit         181'     385
its_goodday     DD'       221
its_monthcarry   14A'     330
its_monthloop    125'     293
its_start       B1'       177
its_submok       144'     324
its_subyok       108'     264
its_yearcarry    10F'     271
its_yearloop    E4'       228
itstrt          00        0 (extern)
itsvec          00        0 (extern)
jptbl_addr     =F6        246
leap_year        183'     387
ly_common        18F'     399
ly_common1       190'     400
madbbu          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
monitor        =01        1
month_days       300'     768
mtwdli          00        0 (extern)
panic           00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
rrtc_bad_time   74'       116
rrtc_buffset    18'       24
rrtc_buffset1   45'       69
rrtc_docompare  3B'       59
rrtc_rd_loop    07'       7
rrtc_retry      76'       118
rtc_regs_buff1  00"       0
rtc_regs_buff2  06"       6
rusby           00        0 (extern)
ruswd           00        0 (extern)
s1rch           00        0 (extern)
s1sta           00        0 (extern)
s1wch           00        0 (extern)
s2rch           00        0 (extern)
s2sta           00        0 (extern)
s2wch           00        0 (extern)
skpspc          00        0 (extern)
spiini          00        0 (extern)
spiss           00        0 (extern)
spitr           00        0 (extern)
sti_done         23B'     571
sti_mon_add      1DD'     477
sti_mon_dn       1E7'     487
sti_mon_lp       1BB'     443
sti_mon_next     1E4'     484
sti_year_dn      1B9'     441
sti_year_lp      19A'     410
sti_year_next    1B6'     438
str_offset     =0A        10
tiitos          A5'       165 (public)
tikcnt          00        0 (extern)
tim_weekdays     30C'     780
time           =01        1
tird            00'       0 (public)
tistoi           192'     402 (public)
tiwr            7C'       124 (public)
toloca          00        0 (extern)
toupca          00        0 (extern)
trarch          00        0 (extern)
trawch          00        0 (extern)
trport          00        0 (extern)
wusby           00        0 (extern)
wuswd           00        0 (extern)
