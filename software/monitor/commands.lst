   1:				; *******************************************************
   2:				; * Commands for ZARC Z80 Computer Monitor              *
   3:				; * (Serial boot version).                              *
   4:				; * Merlin Skinner, 30/4/2021                           *
   5:				; *******************************************************
   6:				;
   7:				; User-entered commands for the monitor.
   8:				;
   9:				;
  10:     -	0001'         	monitor         equ 1                   ; Flag part of monitor build
  11:     -	0001'         	commands        equ 1                   ; Flag module for includes
  12:				;
  13:				;
  14:				;
  15:				; ************
  16:				; * Includes *
  17:				; ************
  18:				;
  19:				;
  20:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				
**** commands.z80 ****
  21:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** commands.z80 ****
  22:				                include "zarc.i"        ; Hardware definitions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//zarc.i ****
   1:				; ***********************************
   2:				; * ZARC Definitions                *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 26/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the ZARC system.
   8:				;
   9:				;
  10:				; ************
  11:				; * Hardware *
  12:				; ************
  13:				;
  14:				; Interrupt vector numbers in INT_VEC_TABLE.
  15:				; Address is INT_VEC_TABLE + 2 * vector number).
  16:     -	0000'         	INT_SER1_TX_VEC     equ INT_SER1_TX_BIT ; Serial port 1 transmitter buffer is half full or less
  17:     -	0001'         	INT_SER1_RX_VEC     equ INT_SER1_RX_BIT ; Serial port 1 receiver has data
  18:     -	0002'         	INT_SER2_TX_VEC     equ INT_SER2_TX_BIT ; Serial port 2 transmitter buffer is half full or less
  19:     -	0003'         	INT_SER2_RX_VEC     equ INT_SER2_RX_BIT ; Serial port 2 receiver has data
  20:     -	0004'         	INT_TICK_VEC        equ INT_TICK_BIT    ; Regular timekeeping
  21:				;
  22:     -	0064'         	MS_PER_TICK         equ 100             ; ms per tick
  23:     -	000A'         	TICK_FREQ           equ 10              ; Tick rate in Hz
  24:				;
  25:				
**** commands.z80 ****
  23:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  18:     -	0001'         	                ifndef main         ; Inhibit for this module
  19:				; Constants
  20:				;
  21:				; Variables 
  22:				                extern tikcnt       ; Tick counter
  23:				;
  24:				; Functions
  25:				                extern panic        ; System error exception
  26:				                extern rusby        ; Read byte from user space
  27:				                extern ruswd        ; Read 16-bit word from user space
  28:				                extern wusby        ; Write byte to user space
  29:				                extern wuswd        ; Write 16-bit word to user space
  30:				;
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** commands.z80 ****
  24:				                include "commands.i"    ; Monitor commands
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//commands.i ****
   1:				; ***********************************************
   2:				; * Commands for ZARC Include File              *
   3:				; * Written by: Merlin Skinner                  *
   4:				; * Date Started: 30/4/2021                     *
   5:				; ***********************************************
   6:				;
   7:				; Constants and structures associated with the ZARC monitor command module.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0000'         	                ifndef commands     ; Inhibit for this module
  20:				                endif
  21:				            endif
  22:				;
  23:				;
  24:				;MCCA_BUFFERS                equ 16      ; Number of cached sector buffers
  25:				;
  26:				
**** commands.z80 ****
  25:				                include "io_map.i"      ; I/O addresses mapping
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io_map.i ****
   1:				; ***********************************
   2:				; * ZARC I/O Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 3/9/2019          *
   5:				; ***********************************
   6:				
   7:				; *** I/O register address mapping ***
   8:				
   9:				; This should be kept in sync with the Definitions.vhd package file.
  10:     -	0000'         	IOA_FPGA_MAJREV equ 0x00        ; FPGA major revision
  11:     -	0001'         	IOA_FPGA_MINREV equ 0x01        ; FPGA minor revision
  12:     -	0002'         	IOA_CONTROL     equ 0x02        ; System control register
  13:     -	0003'         	IOA_FP_SW       equ 0x03        ; Front panel data switches
  14:				
  15:				; Paging
  16:     -	0004'         	IOA_MMAP_0      equ 0x04        ; Page, supervisor and protection for bank 0 (0x0000 to 0x3fff)
  17:     -	0005'         	IOA_MMAP_1      equ 0x05        ; Page, supervisor and protection for bank 1 (0x4000 to 0x7fff)
  18:     -	0006'         	IOA_MMAP_2      equ 0x06        ; Page, supervisor and protection for bank 2 (0x8000 to 0xbfff)
  19:     -	0007'         	IOA_MMAP_3      equ 0x07        ; Page, supervisor and protection for bank 3 (0xc000 to 0xffff)
  20:				
  21:				; Interrupts
  22:				; Note: Up to eight interrupts are supported. IM 2 is anticipated, and the
  23:				; fixed vector associated with each interrupt is supplied when the interrupt
  24:				; is serviced. Routine address is “I*256+databus”. Vector supplied is
  25:				; 0xe0 + 2 * interrupt number (0 to 7).
  26:				; Note: addresses 0x09 and 0x0b reserved for use if more than eight interrupt
  27:				; sources are required.
  28:     -	0008'         	IOA_INT_EN      equ 0x08        ; Enables
  29:     -	000A'         	IOA_INT_PEND    equ 0x0a        ; Pending interrupts
  30:				;
  31:				;NMI
  32:     -	000C'         	IOA_NMI_REASONS equ 0x0c        ; NMI reasons flags
  33:				;
  34:				; Serial.
  35:     -	0010'         	IOA_SER1_CSR    equ 0x10        ; Port 1 control / status
  36:     -	0011'         	IOA_SER1_DATA   equ 0x11        ; Port 1 data
  37:     -	0012'         	IOA_SER2_CSR    equ 0x12        ; Port 2 serial control / status
  38:     -	0013'         	IOA_SER2_DATA   equ 0x13        ; Port 2 serial data
  39:				
  40:				; RTC (DS1672)
  41:				; I2C, implemented using a byte interface to the CPU. Writing to the data port
  42:				; shifts out a byte. Input puts are shifted into the “other end” of the same
  43:				; register.
  44:     -	0018'         	IOA_I2C_CSR     equ 0x18        ; Control
  45:     -	0019'         	IOA_I2C_DATA    equ 0x19        ; Data
  46:				;
  47:				; SD Card
  48:				; Uses SPI mode, with a generally similar interface to that of the I2C.
  49:     -	0020'         	IOA_SPI_CSR     equ 0x20        ; Control
  50:     -	0021'         	IOA_SPI_DATA    equ 0x21        ; Data
  51:				
  52:				; CRC16 / XMODEM and MultiMediaCard CRC16
  53:				; Write to the CRC register to set the initial value. Writing to the input
  54:				; data register updates the CRC.
  55:     -	0024'         	IOA_CRC_0       equ 0x24        ; CRC register (low)
  56:     -	0025'         	IOA_CRC_1       equ 0x25        ; CRC register (high)
  57:     -	0026'         	IOA_CRC_DATA    equ 0x26        ; Input data
  58:				
  59:				; *** Proposed features ***
  60:				; Video
  61:				;IOA_VID_CTRL    equ 0x30;       ; Control (cursor on/off ...)
  62:				;IOA_VID_DATA    equ 0x31;       ; Data
  63:				;IOA_VID_CUR_X   equ 0x32;       ; Cursor X (0 to 127)
  64:				;IOA_VID_CUR_Y   equ 0x33;       ; Cursor Y (0 to 63)
  65:				;IOA_VID_START_L equ 0x34        ; Display start address (low byte)
  66:				;IOA_VID_START_H equ 0x35        ; Display start address (high byte)
  67:				
  68:				; Video palette
  69:				; Each entry consists of 6 bits of colour data. Foreground and background
  70:				; colour pairs are selected from the above palette using eight of the 22
  71:				; control codes in the display character set. This leaves codes for
  72:				; double-height, double-width etc.
  73:				;IOA_VID_PALBG0  equ 0x40        ; Background colour 0
  74:				;IOA_VID_PALFG0  equ 0x41        ; Foreground colour 0
  75:				;IOA_VID_PALBG1  equ 0x42        ; Background colour 1
  76:				;IOA_VID_PALFG1  equ 0x43        ; Foreground colour 1
  77:				;IOA_VID_PALBG2  equ 0x44        ; Background colour 2
  78:				;IOA_VID_PALFG2  equ 0x45        ; Foreground colour 2
  79:				;IOA_VID_PALBG3  equ 0x46        ; Background colour 3
  80:				;IOA_VID_PALFG3  equ 0x47        ; Foreground colour 3
  81:				;IOA_VID_PALBG4  equ 0x48        ; Background colour 4
  82:				;IOA_VID_PALFG4  equ 0x49        ; Foreground colour 4
  83:				;IOA_VID_PALBG5  equ 0x4a        ; Background colour 5
  84:				;IOA_VID_PALFG5  equ 0x4b        ; Foreground colour 5
  85:				;IOA_VID_PALBG6  equ 0x4c        ; Background colour 6
  86:				;IOA_VID_PALFG6  equ 0x4d        ; Foreground colour 6
  87:				;IOA_VID_PALBG7  equ 0x4e        ; Background colour 7
  88:				;IOA_VID_PALFG7  equ 0x4f        ; Foreground colour 7
  89:				
  90:				; Arithmetic
  91:				; Multiply, divide … based on 68000 DIV, DIVU, MUL, MULU.
  92:				; Multiply does A[16] * B[16] => C[32].
  93:				; Divide does A[32] / B[16] => C[32] (16-bit remainder [high bits] and
  94:				; 16-bit quotient [low bits]).
  95:				; Status bits include “complete” and “overflow”.
  96:				;IOA_ARITH_A_L   equ 0x50        ; A register (low)
  97:				;IOA_ARITH_A_H   equ 0x51        ; A register (high)
  98:				;IOA_ARITH_B_L   equ 0x54        ; B register (low)
  99:				;IOA_ARITH_B_H   equ 0x57        ; B register (high)
 100:				;IOA_ARITH_C_0   equ 0x58        ; C register (low)
 101:				;IOA_ARITH_C_1   equ 0x59 
 102:				;IOA_ARITH_C_2   equ 0x5a
 103:				;IOA_ARITH_C_3   equ 0x5b        ; C register (high)
 104:				;IOA_ARITH_CSR   equ 0x5c        ; Command / status
 105:				
 106:				
 107:				; *** Register bits allocation ***
 108:				
 109:				; IOA_CONTROL register
 110:     -	        	BITDEF SYSCTRL_TRARM, 0         ; 1 arms the trace interrupt
 111:     -	        	BITDEF SYSCTRL_MMAP, 1          ; 1 enables memory mapping
 112:     -	        	BITDEF SYSCTRL_NMCLR, 2         ; NMI mapping clear
 113:     -	        	BITDEF SYSCTRL_MAPARM, 3        ; NMI out arm
 114:     -	        	BITDEF SYSCTRL_MMAPN, 4         ; State of MMAP when an NMI occurred
 115:     -	        	BITDEF SYSCTRL_TRPRE0, 5        ; Number of prefixes for trace
 116:     -	        	BITDEF SYSCTRL_TRPRE1, 6
 117:     -	        	BITDEF SYSCTRL_RESERVED, 7      ; Unused bit
 118:				;
 119:				; MMAP page registers
 120:     -	        	BITDEF MMAP_PROT, 7             ; Write protection
 121:     -	        	BITDEF MMAP_SUPER, 6            ; I/O enable
 122:     -	003F'         	MMAP_PAGE_MASK  equ 0x3f        ; RAM page number bits
 123:				;
 124:				; IOA_INT_EN and IOA_INT_PEND registers.
 125:     -	0008'         	INTS_NUM        equ 8           ; Number of possible interrupt sources
 126:     -	        	BITDEF INT_SER1_TX, 0           ; Serial port 1 transmitter buffer is half full or less
 127:     -	        	BITDEF INT_SER1_RX, 1           ; Serial port 1 receiver has data
 128:     -	        	BITDEF INT_SER2_TX, 2           ; Serial port 2 transmitter buffer is half full or less
 129:     -	        	BITDEF INT_SER2_RX, 3           ; Serial port 2 receiver has data
 130:     -	        	BITDEF INT_TICK, 4              ; Regular timekeeping
 131:				;
 132:				; IOA_NMI_REASONS register.
 133:     -	0004'         	NMI_REASONS_NUM equ 4           ; Number of reasons for an NMI
 134:     -	        	BITDEF NMI_SWITCH, 0;           ; Front panel switch
 135:     -	        	BITDEF NMI_PROT_VIOL, 1;        ; Write protection violation
 136:     -	        	BITDEF NMI_SUPER_VIOL, 2;       ; Supervisor violation
 137:     -	        	BITDEF NMI_TRACE, 3;            ; Debugger trace (single step)
 138:     -	000F'         	NMI_REASONS_ALL equ NMI_SWITCH_MASK + NMI_PROT_VIOL_MASK + NMI_SUPER_VIOL_MASK + NMI_TRACE_MASK
 139:				;
 140:				; Serial CSRs (IOA_SER1_CSR and IOA_SER2_CSR).
 141:     -	        	BITDEF SER_CSR_RX_EMPTY, 0      ; Receiver buffer is empty
 142:     -	        	BITDEF SER_CSR_RX_ALHALF, 1     ; Receiver buffer is at least half full
 143:     -	        	BITDEF SER_CSR_RX_FULL, 2       ; Receiver buffer is full
 144:     -	        	BITDEF SER_CSR_FRAME_ERR, 3     ; Framing error in last character
 145:     -	        	BITDEF SER_CSR_TX_EMPTY, 4      ; Transmitter buffer is empty
 146:     -	        	BITDEF SER_CSR_TX_ALHALF, 5     ; Transmitter buffer is at least half full
 147:     -	        	BITDEF SER_CSR_TX_FULL, 6       ; Transmitter buffer is full
 148:				; Bit 7 is not used.
 149:				;
 150:				; I2C (Inter-Integrated Circuit) master interface. Used for RTC (DS1672).
 151:				; Bits in IOA_I2C_CSR
 152:     -	        	BITDEF I2C_CSR_ACKN, 0          ; (Read / write) acknowledge from receiving device
 153:     -	        	BITDEF I2C_CSR_START, 1         ; (Write only) trigger start sequence
 154:     -	        	BITDEF I2C_CSR_STOP, 2          ; (Write only) trigger stop sequence
 155:     -	        	BITDEF I2C_CSR_BUSY, 7          ; (Read only) transceiver busy
 156:				;
 157:				; SPI (Serial Peripheral Interface) master interface. Used for memory card.
 158:				; Bits in IOA_SPI_CSR
 159:     -	        	BITDEF SPI_CSR_FAST, 0          ; (Read / write) SPI speed select
 160:     -	        	BITDEF SPI_CSR_MC_SS, 1         ; (Read / write) memory card slave select
 161:     -	        	BITDEF SPI_CSR_BUSY, 7          ; (Read only) transceiver busy
 162:				
**** commands.z80 ****
  26:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** commands.z80 ****
  27:				                include "io.i"          ; I/O routines
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io.i ****
   1:				; ***********************************
   2:				; * ZARC Basic I/O Extern Symbols   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and extern statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef io           ; Inhibit for this module
  16:				;
  17:				                ; Variables
  18:				                extern coport   ; Current console port (PRT_xxx)
  19:				                extern trport   ; Current data transfer port (PRT_xxx)
  20:				;
  21:				                ; Routines
  22:				                extern conwch   ; Write character to the console
  23:				                extern conrch   ; Read character from the console
  24:				                extern consta   ; Fetch console port status
  25:				                extern trawch   ; Write character to the data transfer port
  26:				                extern trarch   ; Read character from the data transfer port
  27:				                extern s1wch    ; Write character to serial port 1
  28:				                extern s1rch    ; Read character from serial port 1
  29:				                extern s1sta    ; Fetch serial port 1 status
  30:				                extern s2wch    ; Write character to serial port 2
  31:				                extern s2rch    ; Read character from serial port 2
  32:				                extern s2sta    ; Fetch serial port 2 status
  33:				                extern i2cwr    ; Write to I2C device
  34:				                extern i2crd    ; Read from I2C device
  35:				                extern spiini   ; Initialise SPI interface and set speed
  36:				                extern spiss    ; Set SPI slave select(s)
  37:				                extern spitr    ; Transfer byte to / from SPI device
  38:				;
  39:				                endif
  40:				            endif
  41:				;
  42:				;
  43:				; Port enumeration. Used for console and transfer port selection. Definitions must
  44:				; match names in prt_name_list (monitor.z80).
  45:     -	        	                ENUM_START
  46:     -	        	                ENUM PORT_SER1          ; Serial port 1
  47:     -	        	                ENUM PORT_SER2          ; Serial port 2
  48:     -	        	                ENUM_END PORT_STATES    ; Number of states
  49:				;
  50:				
**** commands.z80 ****
  28:				                include "utility.i"     ; Utility functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//utility.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Utility Routines   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef utility      ; Inhibit for this module
  16:				;
  17:				                extern cwnwln       ; Write new line characters to console.
  18:				                extern conwms       ; Print null-terminated string to the console
  19:				                extern conwmn       ; Print message <n> in a list
  20:				                extern skpspc       ; Step hl past spaces
  21:				                extern toupca       ; Convert character in A to upper case
  22:				                extern toloca       ; Convert character in A to lower case
  23:				                extern cwvich       ; Print only visible 7-bit characters
  24:				                extern cwpspc       ; Print a space
  25:				                extern mtwdli       ; Match word in a string against list of options
  26:				                extern cwphnb       ; Print least-significant nibble in A in hexadecimal
  27:				                extern cwphby       ; Print A in hexadecimal
  28:				                extern cwphwd       ; Print HL in hexadecimal
  29:				                extern cwpdby       ; Print A in decimal. Leading zeros are suppressed
  30:				                extern cwpdwd       ; Print HL in decimal. Leading zeros are suppressed
  31:				                extern cwpdlo       ; Print DEHL in decimal. Leading zeros are suppressed
  32:				                extern rdhxwd       ; Read a 16-bit hexadecimal number from a string
  33:				                extern rdduwd       ; Read a 16-bit unsigned decimal number from a string
  34:				                extern rddulo       ; Read a 32-bit unsigned decimal number from a string
  35:				;
  36:				                endif
  37:				            endif
  38:				;
  39:				;
  40:				; mtwdli (match word in a string against list of options) option bits. Each bit
  41:				; has the described effect if set.
  42:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  43:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  44:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  45:				
**** commands.z80 ****
  29:				                include "maths.i"       ; Mathematical functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for ZARC Z80 Computer         *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 29/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef maths        ; Inhibit for this module
  16:				;
  17:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  18:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  19:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  20:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  21:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  22:				                extern crc16x       ; Software CRC-16 (XMODEM)
  23:				;
  24:				                endif
  25:				            endif
  26:				
**** commands.z80 ****
  30:				                include "interrupts.i"  ; Interrupts
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//interrupts.i ****
   1:				; ***********************************
   2:				; * ZARC Interrupts Routines        *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef interrupts   ; Inhibit for this module
  16:				; Variables 
  17:				                extern itenfl   ; Int. enable flag (0 = basic, 1 = normal I/O mode)
  18:				                extern itdsct   ; DI nest count
  19:				; Functions
  20:				                extern itinit   ; Initialise interrupt variables and set basic I/O mode
  21:				                extern itstrt   ; Start monitor interrupts
  22:				                extern itena    ; Enable interrupts if safe
  23:				                extern itdis    ; Disable interrupts and keep count
  24:				                extern itsvec   ; Set interrupt vector to point to a new service routine
  25:				;
  26:				                endif
  27:				            endif
  28:				
**** commands.z80 ****
  31:				                include "time.i"        ; Routines associated with time
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//time.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Time Routines      *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				; The system keeps track of time as a Unix-style 32-bit number. Unlike Unix, this
   8:				; is treated as an unsigned integer and so will not suffer from the Year 2038 problem
   9:				; as it doubles the allowable postive time. It does, however, mean that it is not
  10:				; possible to represent dates before 1970.
  11:				
  12:				; Note that ld80 only considers the first six characters of labels significant.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef time         ; Inhibit for this module
  16:				;
  17:				                extern tird         ; Read current time and date
  18:				                extern tiwr         ; Set time and date
  19:				                extern tiitos       ; Convert integer time to structure
  20:				                extern tistoi       ; Convert structure time to integer
  21:				                extern cwptm        ; Print time structure to console
  22:				;
  23:				                endif
  24:				            endif
  25:				;
  26:				;
  27:     -	0046'         	TIM_EPOCH_YEAR  equ 70              ; Epoch year byte
  28:				;
  29:				; The following structure is used to store dates and times in human units. It is based
  30:				; on the Unix time.h tm structure.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BYTE TM_SECS    ; Seconds [0,59]
  33:     -	        	                STR_BYTE TM_MINS    ; Minutes [0,59]
  34:     -	        	                STR_BYTE TM_HOURS   ; Hours [0,23]
  35:     -	        	                STR_BYTE TM_MDAY    ; Day of month [1,31]
  36:     -	        	                STR_BYTE TM_MON     ; Month of year [1,12]
  37:     -	        	                STR_BYTE TM_YEAR    ; Years since 1900 [70,255]
  38:     -	        	                STR_BYTE TM_WDAY    ; Day of week [0,6] (Sunday = 0)
  39:     -	        	                STR_WORD TM_YDAY    ; Day of year [0,365]
  40:     -	        	                STR_BYTE TM_DST     ; Daylight savings status
  41:     -	        	                STR_END TM_SIZE
  42:				
  43:				; TM_DST can have any of the following values:
  44:     -	        	                ENUM_START
  45:     -	        	                ENUM TMDST_UNKNOWN
  46:     -	        	                ENUM TMDST_GMT      ; The time is GMT
  47:     -	        	                ENUM TMDST_DST      ; The time has DST applied (is one hour advanced)
  48:     -	        	                ENUM_END TMDST_NUM  ; Number of possible values
  49:				
**** commands.z80 ****
  32:				                include "diags.i"       ; Diagnostics
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//diags.i ****
   1:				; ***************************************
   2:				; * ZARC Monitor Diagostics Routines    *
   3:				; * Written by: Merlin Skinner          *
   4:				; * Date Started: 3/8/2020              *
   5:				; ***************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef diags        ; Inhibit for this module
  16:				;
  17:				                extern cpuspd       ; Measure approximate CPU clock speed
  18:				                extern memtst       ; Test an area of memory with a range of patterns
  19:				                extern memtal       ; Test entire memory
  20:				;
  21:				                endif
  22:				            endif
  23:				
**** commands.z80 ****
  33:				                include "spi.i"         ; SPI master interface
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//spi.i ****
   1:				; ***********************************
   2:				; * ZARC SPI Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 7/8/2020          *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with the SPI (Inter-Integrated Circuit) master interface.
   8:				; Used for the memory card initially, but it may turn out to have other uses.
   9:				;
  10:				;
  11:				; Memory card command structure
  12:     -	        	                STRUCT
  13:     -	        	                STR_BYTE MMC_CMD    ; Command including start bits
  14:     -	        	                STR_BYTE MMC_ARG1   ; Arguments
  15:     -	        	                STR_BYTE MMC_ARG2   ; Arguments
  16:     -	        	                STR_BYTE MMC_ARG3   ; Arguments
  17:     -	        	                STR_BYTE MMC_ARG4   ; Arguments
  18:     -	        	                STR_BYTE MMC_CRC    ; CRC and stop bit
  19:     -	        	                STR_END MMC_SIZE
  20:				
  21:				; SPI error codes. This should be maintained in sync with err_msgs in mmc_card.z80.
  22:     -	        	                ENUM_START
  23:     -	        	                ENUM SPI_ERR_OK         ; No error
  24:     -	        	                ENUM SPI_ERR_BUSY       ; Master interface stuck busy
  25:				; Memory card error codes.
  26:     -	        	                ENUM SPI_ERR_NORESP     ; No response received from card
  27:     -	        	                ENUM SPI_ERR_BADINIT    ; Initialisation failed
  28:     -	        	                ENUM SPI_ERR_BADCRC     ; CRC error
  29:     -	        	                ENUM SPI_ERR_BADSEC     ; Bad sector size
  30:     -	        	                ENUM SPI_ERR_RANGE      ; Parameter out of range
  31:     -	        	                ENUM SPI_ERR_DATAERR    ; Data error token received
  32:     -	        	                ENUM SPI_ERR_BAD_R1     ; Card reported error in R1 response
  33:     -	        	                ENUM SPI_ERR_BAD_R2     ; Card reported error in R2 response
  34:     -	        	                ENUM SPI_ERR_HEAP       ; Out of heap space
  35:     -	        	                ENUM SPI_ERR_TIMEOUT    ; Busy timeout
  36:     -	        	                ENUM SPI_ERR_WRITE      ; Write error
  37:     -	        	                ENUM SPI_ERR_UNKN       ; Unknown error
  38:     -	        	                ENUM_END SPI_ERR_NUM    ; Number of errors
**** commands.z80 ****
  34:				                include "mmc.i"         ; Memory card
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//mmc.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Memory Card Include File   *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 7/8/2020                  *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef mmc          ; Inhibit for this module
  17:				; Functions
  18:				                extern mcinit       ; Initialise memory card
  19:				                extern mcprer       ; Print memory card error text
  20:				                extern mcrrs        ; Raw read sector
  21:				                extern mcrws        ; Raw write sector
  22:				; Variables
  23:				                extern mcstat       ; Card state (MC_STAT_xxx)
  24:				;
  25:				                endif
  26:				            endif
  27:				;
  28:				;
  29:     -	0200'         	MMC_SECTOR_SIZE             equ 512     ; Sector size
  30:     -	0009'         	MMC_LOG2_SEC_SIZE           equ 9       ; Save number of shifts for above
  31:     -	0040'         	MMC_CMD_START               equ 0x40    ; Command start bits (01b) shifted for
  32:				                                        ; command byte
  33:     -	0001'         	MMC_CMD_STOP                equ 0x01    ; Stop bit (in CRC byte)
  34:				;
  35:				;
  36:				; Card state (mcstat) states.
  37:     -	        	                ENUM_START
  38:     -	        	                ENUM MMC_STAT_IDLE      ; Not initialised
  39:     -	        	                ENUM MMC_STAT_INIT      ; Initialised (can do raw read / writes)
  40:				
  41:     -	        	                ENUM_END MC_STATES  ; Number of states
  42:				;
  43:				;
  44:				; Memory card command structure
  45:     -	        	                STRUCT
  46:     -	        	                STR_BYTE MMC_CMD    ; Command including start bits
  47:     -	        	                STR_BYTE MMC_ARG1   ; Arguments
  48:     -	        	                STR_BYTE MMC_ARG2   ; Arguments
  49:     -	        	                STR_BYTE MMC_ARG3   ; Arguments
  50:     -	        	                STR_BYTE MMC_ARG4   ; Arguments
  51:     -	        	                STR_BYTE MMC_CRC    ; CRC and stop bit
  52:     -	        	                STR_END MMC_SIZE
  53:				;
  54:				;
  55:				; SPI mode commands (CMDn from MMC-System-Spec-v3.31.pdf chapter 4.9).
  56:     -	0000'         	MMC_CMD_GO_IDLE_STATE       equ 0   ; Resets the memory card
  57:     -	0001'         	MMC_CMD_SEND_OP_COND        equ 1   ; Sends host capacity support information and init.
  58:     -	0009'         	MMC_CMD_SEND_CSD            equ 9   ; Read card specific data
  59:     -	000A'         	MMC_CMD_SEND_CID            equ 10  ; Read card identification
  60:     -	000D'         	MMC_CMD_SEND_STATUS         equ 13  ; Read card status register
  61:     -	0010'         	MMC_CMD_SET_BLOCKLEN        equ 16  ; Set block length (in bytes)
  62:     -	0011'         	MMC_CMD_READ_SINGLE_BLOCK   equ 17  ; Reads a block
  63:     -	0018'         	MMC_CMD_WRITE_BLOCK         equ 24  ; Writes a block
  64:     -	0037'         	MMC_CMD_APP_CMD             equ 55  ; Next command is an application specific command
  65:     -	003B'         	MMC_CMD_CRC_ON_OFF          equ 59  ; Turns the CRC option on or off
  66:				;
  67:				; The list describes all the application specific commands supported/reserved by the 
  68:				; memory card. All the following commands shall be preceded with APP_CMD (CMD55).
  69:     -	0029'         	MMC_ACMD_MC_SEND_OP_COND    equ 41  ; Sends host capacity support information and init
  70:				;
  71:				; R1 response bits
  72:     -	        	BITDEF MMC_R1_IDLE, 0           ; In idle state
  73:     -	        	BITDEF MMC_R1_ERA_RST, 1        ; Erase reset
  74:     -	        	BITDEF MMC_R1_ILL_CMD, 2        ; Illegal command
  75:     -	        	BITDEF MMC_R1_CMD_CRC_ERR, 3    ; Command CRC error
  76:     -	        	BITDEF MMC_R1_ERA_SEQ_ERR, 4    ; Erase sequence error
  77:     -	        	BITDEF MMC_R1_ADDR_ERR, 5       ; Address error
  78:     -	        	BITDEF MMC_R1_PAR_ERR, 6        ; Parameter error
  79:     -	        	BITDEF MMC_R1_START, 7          ; Zero identifies an R1 response
  80:				;
  81:				;
  82:     -	0006'         	MMC_CID_PNM_SIZE      equ 6   ; Product name length (bytes)
  83:				;
  84:				; Card IDentification (CID) register (128 bits)
  85:     -	        	                STRUCT
  86:     -	        	                STR_BYTE MMC_CID_MID    ; Manufacturer ID
  87:     -	        	                STR_WORD MMC_CID_OID    ; OEM/Application ID
  88:     -	        	                STR_BLOCK MMC_CID_PNM, MMC_CID_PNM_SIZE ; Product name
  89:     -	        	                STR_BYTE MMC_CID_PRV    ; Product revision
  90:     -	        	                STR_LONG MMC_CID_PSN    ; Product serial number
  91:     -	        	                STR_BYTE MMC_CID_MDT    ; Manufacturing date
  92:     -	        	                STR_BYTE MMC_CID_CRC    ; CRC7 checksum and "1"
  93:     -	        	                STR_END MMC_CID_SIZE
  94:				;
  95:				;
  96:				; Card-Specific Data (CSD) register (128 bits). It contains a number of bit fields
  97:				; that aren't necessarily byte aligned. In these cases, the entries simply identify
  98:				; the bit numbers contained.
  99:     -	        	                STRUCT
 100:     -	        	                STR_BYTE MMC_CSD_VERSION    ; (127-120) CSD version, spec version
 101:     -	        	                STR_BYTE MMC_CSD_TAAC       ; (119-112) data read access-time-1
 102:     -	        	                STR_BYTE MMC_CSD_NSAC       ; (111-104) data read access-time-2
 103:     -	        	                STR_BYTE MMC_CSD_TR_SPD     ; (103-96) max. data transfer rate
 104:     -	        	                STR_BYTE MMC_CSD_95_88      ; Card command classes (MS 8 bits)
 105:     -	        	                STR_BYTE MMC_CSD_87_80      ; CCC (LS bits) and max. read data length
 106:     -	        	                STR_BYTE MMC_CSD_79_72      ; Flags and C_SIZE bits 10 and 11
 107:     -	        	                STR_BYTE MMC_CSD_71_64      ; C_SIZE bits 2 to 9
 108:     -	        	                STR_BYTE MMC_CSD_63_56      ; C_SIZE bits 1 to 0 and some currents
 109:     -	        	                STR_BYTE MMC_CSD_55_48      ; Currents & C_SIZE_MULT (MS 2 bits)
 110:     -	        	                STR_BYTE MMC_CSD_47_40      ; C_SIZE_MULT (LS bit) and erase size (part)
 111:     -	        	                STR_BYTE MMC_CSD_39_32      ; Erase size (part) and WP group size
 112:     -	        	                STR_BYTE MMC_CSD_31_24      ; WP group enable, ECC and write parameters (part)
 113:     -	        	                STR_BYTE MMC_CSD_23_16      ; Write block lenth (part) and reserved
 114:     -	        	                STR_BYTE MMC_CSD_15_8       ; Flags
 115:     -	        	                STR_BYTE MMC_CSD_CRC        ; CRC7 checksum and "1"
 116:     -	        	                STR_END MMC_CSD_SIZE
 117:				
**** commands.z80 ****
  35:				                include "disass.i"      ; Z80 disassembler
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//disass.i ****
   1:				; ***************************************
   2:				; * ZARC Monitor Disassembly Routines   *
   3:				; * Written by: Merlin Skinner          *
   4:				; * Date Started: 27/9/2020             *
   5:				; ***************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef disass   ; Inhibit for this module
  17:				;
  18:				                extern diproc   ; Disassemble an instruction to intermediate form
  19:				                extern diprnt   ; Print the result
  20:				;
  21:				                endif
  22:				            endif
  23:				;
  24:     -	0010'         	DIS_BUF_SIZE    equ 16          ; Length of intermediate disassembly buffer
  25:     -	0004'         	DIS_MAX_INSTLEN equ 4           ; Maximum length of instructions
  26:				; Note: invalid instructions may exceed this length.
**** commands.z80 ****
  36:				                include "cpm.i"         ; CP/M support
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  17:     -	0001'         	                ifndef cpm          ; Inhibit for this module
  18:				; Constants
  19:				;
  20:				; Variables 
  21:				                extern cppags       ; CP/M page allocations
  22:				;
  23:				; Functions
  24:				                extern cpinit       ; Load and start CP/M
  25:				                extern cpmem        ; Allocate CP/M pages
  26:				;
  27:				                endif
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** commands.z80 ****
  37:				                include "heap.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//heap.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Heap Incude File           *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 7/8/2020                  *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef heap         ; Inhibit for this module
  17:				;
  18:				                extern hinit        ; Initialise
  19:				                extern halloc       ; Allocate memory
  20:				;
  21:				                endif
  22:				            endif
  23:				
**** commands.z80 ****
  38:				                include "cache.i"       ; MMC sector cache
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cache.i ****
   1:				; ***********************************************
   2:				; * ZARC Monitor Memory Card Cache Include File *
   3:				; * Written by: Merlin Skinner                  *
   4:				; * Date Started: 23/11/2020                    *
   5:				; ***********************************************
   6:				;
   7:				; Constants and structures associated with the MMC memory card sector cache.
   8:				;
   9:				; "Dirty" in this case indicates sector data that is in the cache, but has not yet
  10:				; been written to the MMC.
  11:				;
  12:				;
  13:				; The following conditionals are intended to allow the same include file to be
  14:				; used in the defining module and elsewhere as required. Some includes are used
  15:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  16:				; the extern and public statements are not desirable.
  17:				;
  18:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  19:     -	0001'         	                ifndef cache        ; Inhibit for this module
  20:				; Functions
  21:				                extern cacold       ; Reset cache (cold start)
  22:				                extern cawarm       ; Initialise cache (warm start)
  23:				                extern carpt        ; Report status
  24:				                extern caflus       ; Flush cache
  25:				                extern cars         ; Read sector
  26:				                extern caws         ; Write sector
  27:				                extern cacrs        ; Read CP/M sector
  28:				                extern cacws        ; Write CP/M sector
  29:				; Variables
  30:				; (None)
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:     -	0010'         	MCCA_BUFFERS                equ 16      ; Number of cached sector buffers
  36:     -	0008'         	MCCA_DIRT_THRES             equ MCCA_BUFFERS / 2    ; Target no. of dirty buffers
  37:				;
  38:				;
  39:				; Sector cache structure. This contains the data associated with a single cached
  40:				; sector.
  41:     -	        	                STRUCT
  42:     -	        	                STR_BYTE MCCAS_STATUS       ; Status byte
  43:     -	        	                STR_24BIT MCCAS_SECTOR      ; 24-bit sector number
  44:     -	        	                STR_WORD MCCAS_CSUM         ; Checksum of data
  45:     -	        	                STR_BLOCK MCCAS_DATA, MMC_SECTOR_SIZE   ; Cached data
  46:     -	        	                STR_END MCCAS_SIZE
  47:				;
  48:				; MCCAS_STATUS byte is defined as follows:
  49:				; Bits 0 to 3 - set if the corresponding CP/M sector in this MMC sector is dirty.
  50:     -	        	BITDEF MCCAS_STAT_CPM0, 0       ; CP/M sector 0 (0 to 0x7f)
  51:     -	        	BITDEF MCCAS_STAT_CPM1, 1       ; CP/M sector 1 (0x80 to 0x0ff)
  52:     -	        	BITDEF MCCAS_STAT_CPM2, 2       ; CP/M sector 2 (0x100 to 0x17f)
  53:     -	        	BITDEF MCCAS_STAT_CPM3, 3       ; CP/M sector 3 (0x180 to 0x1ff)
  54:     -	        	BITDEF MCCAS_STAT_VALID, 4      ; Buffer contains valid data
  55:				;
  56:     -	000F'         	MCCAS_STAT_DIRT_MASK    equ MCCAS_STAT_CPM0_MASK + MCCAS_STAT_CPM1_MASK + MCCAS_STAT_CPM2_MASK + MCCAS_STAT_CPM3_MASK
  57:				
**** commands.z80 ****
  39:				                include "memory.i"      ; Memory page allocation
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//memory.i ****
   1:				; *******************************************
   2:				; * ZARC Memory Include File                *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 24/11/2021                *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef memory       ; Inhibit for this module
  17:				;
  18:				                extern mpinit       ; Initialise
  19:				                extern mprpt        ; Report status to console
  20:				                extern mpall        ; Allocate new page
  21:				                extern mpfree       ; Free allocated page
  22:				                extern mpstat       ; Allocation status
  23:				                extern mppnam       ; Print entry name
  24:				;
  25:				                endif
  26:				            endif
  27:				;
  28:				; Physical memory constants are found in zarc.i
  29:				;
  30:     -	0004'         	MPA_NAME_LEN        equ 4               ; Page owner name length (bytes)
  31:				;
  32:				; Memory map
  33:     -	4000'         	MMAP_PAGE_SIZE      equ 0x4000          ; Memory mapping bank / page size
  34:     -	0004'         	MMAP_BANKS          equ 4               ; Number of 16 kB banks
  35:     -	0040'         	MMAP_PAGES          equ 0x40            ; Number of 16 kB RAM pages
  36:     -	0000'         	MMAP_BANK0_START    equ 0x0000
  37:     -	3FFF'         	MMAP_BANK0_END      equ 0x3fff
  38:     -	4000'         	MMAP_BANK1_START    equ 0x4000
  39:     -	7FFF'         	MMAP_BANK1_END      equ 0x7fff
  40:     -	8000'         	MMAP_BANK2_START    equ 0x8000
  41:     -	BFFF'         	MMAP_BANK2_END      equ 0xbfff
  42:     -	C000'         	MMAP_BANK3_START    equ 0xc000
  43:     -	FFFF'         	MMAP_BANK3_END      equ 0xffff
  44:				;
  45:				;
  46:				;
  47:				; ****************
  48:				; * Memory Usage *
  49:				; ****************
  50:				;
  51:				;
  52:				; Memory banks setup.
  53:				; 0 (0000 - 3FFF): 3f read only, supervisor - monitor program
  54:				; 1 (4000 - 7FFF): 3e writeable - monitor variables, stacks, buffers etc.
  55:				; 2 (8000 - BFFF): (not used)
  56:				; 3 (C000 - FFFF): (mapped as required)
  57:				;
  58:     -	003F'         	MMAP_MON_B0_PAGE    equ 0x3f        ; Page for bank 0
  59:     -	003E'         	MMAP_MON_B1_PAGE    equ 0x3e        ; Page for bank 1
  60:				;
  61:     -	0040'         	STACKS_SIZE     equ 64              ; Space allocated to normal stacks
  62:				;
  63:     -	7FFF'         	HEAP_TOP        equ MMAP_BANK1_END  ; Top (end) of heap space.
  64:				
**** commands.z80 ****
  40:				;
  41:				;
  42:				;
  43:				; *************
  44:				; * Externals *
  45:				; *************
  46:				;
  47:				;
  48:				; "externs" listed here are ones that are unlikely to be of interest to modules
  49:				; other than monitor.z80.
  50:				; Routines
  51:				                public mcexec           ; Execute a command
  52:				                public mcprot           ; Write protection error reporting
  53:				                public prpnam           ; Print memory page name
  54:				;
  55:				; From monitor.z80
  56:				                extern mcrun            ; Switch context to user code
  57:				                extern mdisrg           ; Display registers
  58:				                extern warm1            ; Warm start marker 1 
  59:				;
  60:				; Variables
  61:				; From monitor.z80
  62:				                extern mscnt            ; Monitor start count
  63:				                extern mcspd            ; Approximate CPU speed in KHz
  64:				                extern mstate           ; Machine state structure
  65:				;
  66:				;
  67:				;
  68:				; *************
  69:				; * Constants *
  70:				; *************
  71:				;
  72:				;
  73:     -	0008'         	CD_BYTESPERLINE equ 8                   ; Number of bytes per line for dump command
  74:     -	0008'         	MON_DL_MAXLEN   equ 8                   ; Maximum length of relocated download code
  75:				;
  76:				; Dump command ellipsis states for cd_disp_flag.
  77:     -	        	                ENUM_START
  78:     -	        	                ENUM CD_DISP_PRN        ; Data is to be displayed
  79:     -	        	                ENUM CD_DISP_SAME       ; Identical data is to be skipped
  80:     -	        	                ENUM CD_DISP_ELDN       ; Ellipsis displayed
  81:     -	        	                ENUM_END CD_DISP_STATES ; Number of states
  82:				;
  83:				;
  84:				;
  85:				; *************
  86:				; * Main Code *
  87:				; *************
  88:				;
  89:				;
  90:				                cseg                    ; Code segment
  91:				;
  92:				; Execute a command. Call with:
  93:				; HL - points to the beginning of the null-terminated command.
  94:				; No registers are preserved.
  95:    0+10	0000' 115C08  	mcexec          ld de, cmd_list
  96:				; Attempt to match the command. Ignore case and allow abbreviations.
  97:   10+7	0003' 3E03    	                ld a, MTWDLI_ABBREV_MASK | MTWDLI_ICASE_MASK
  98:   17+17	0005' CD0000  	                call mtwdli             ; Match against list of options
  99:   34+4	0008' A7      	                and a
 100:   38+7+5	0009' 2822    	                jr z, cmd_bad
 101:				;
 102:				; Find address of command code
 103:   45+11	000B' E5      	                push hl                 ; Save command buffer pointer
 104:   56+10	000C' 211A09  	                ld hl, cmd_vectors
 105:   66+4	000F' 3D      	                dec a                   ; Start index from zero
 106:   70+4	0010' 87      	                add a                   ; Convert index to a word offset
 107:   74+4	0011' 85      	                add l                   ; Add low byte
 108:   78+4	0012' 6F      	                ld l,a
 109:   82+7	0013' 3E00    	                ld a, 0
 110:   89+4	0015' 8C      	                adc a, h                ; Add carry to high byte
 111:   93+4	0016' 67      	                ld h, a
 112:				; HL is cmd_vectors + 2 * index
 113:   97+7	0017' 5E      	                ld e, (hl)              ; Read address
 114:  104+6	0018' 23      	                inc hl
 115:  110+7	0019' 56      	                ld d, (hl)
 116:  117+10	001A' E1      	                pop hl                  ; Restore command buffer pointer
 117:  127+17	001B' CD0000  	                call skpspc             ; Skip any leading spaces
 118:				; Save the stack pointer so commands have the option of exiting without worrying
 119:				; about leaving things on the stack.
 120:  144+20	001E' ED730000	                ld (cmd_sp), sp
 121:				; IX is pre-loaded with the base address of the machine state structure as several
 122:				; commands use it.
 123:  164+14	0022' DD210000	                ld ix, mstate           ; Machine state structure
 124:  178+11	0026' D5      	                push de
 125:				; HL points to the separator after the command word or the terminator.
 126:  189+10	0027' C9      	                ret                     ; Go to command routine
 127:				;
 128:				; Commands may either simply return or jump here when processing is complete.
 129:				; Going here is always safe as it does not rely on the stack state.
 130:  199+20	0028' ED7B0000	cmd_done        ld sp, (cmd_sp)
 131:  219+10	002C' C9      	                ret
 132:				;
 133:				; Can't match command against any of the valid ones.
 134:  229+10	002D' 215609  	cmd_bad         ld hl, cmd_bad_msg
 135:  239+17	0030' CD0000  	                call conwms             ; Print message
 136:  256+10	0033' C9      	                ret
 137:				;
 138:				; Operand error
 139:  266+10	0034' 216409  	cmd_op_error    ld hl, op_err_msg
 140:  276+17	0037' CD0000  	                call conwms             ; Print message
 141:  293+10	003A' C32800  	                jp cmd_done
 142:				;
 143:				; Write protection error.
 144:				; HL - fault address in user space
 145:  303+11	003D' E5      	mcprot          push hl
 146:  314+10	003E' 217409  	                ld hl, wr_prot_msg      ; "Write protection violation, address: "
 147:  324+17	0041' CD0000  	                call conwms             ; Print message
 148:  341+10	0044' E1      	                pop hl
 149:  351+17	0045' CD0000  	                call cwphwd             ; Print address in hexadecimal
 150:  368+17	0048' CD0000  	                call cwnwln             ; Write new line characters to console
 151:  385+10	004B' C32800  	                jp cmd_done
 152:				;
 153:				; Print terse help text.
 154:  395+10	004E' 21F109  	cmd_help        ld hl, help_msg
 155:  405+17	0051' CD0000  	                call conwms             ; Print message
 156:  422+10	0054' C9      	                ret
 157:				;
 158:				;
 159:				; Display an area of memory in hex and ASCII. The format is similar to
 160:				; Linux's hexdump -C:
 161:				; 1234  00 11 22 33 44 55 66 77  |abcdefgh|
 162:				; Command format:
 163:				; dump <start addr> [<length>]
 164:				; length defaults to 0x0040 if not specified. Duplicate lines are omitted.
 165:				; Omission is indicated by an ellipsis.
 166:  432+17	0055' CD0000  	cmd_dump        call rdhxwd             ; Fetch address
 167:  449+10	0058' DA3400  	                jp c, cmd_op_error      ; Address is required
 168:  459+11	005B' D5      	                push de                 ; Save starting address
 169:  470+17	005C' CD0000  	                call skpspc             ; Skip spaces
 170:  487+17	005F' CD0000  	                call rdhxwd             ; Fetch length
 171:  504+11	0062' F5      	                push af                 ; Save carry flag
 172:  515+17	0063' CD0000  	                call skpspc             ; Skip spaces
 173:				; The next thing in the command buffer should be the terminator.
 174:  532+4	0066' AF      	                xor a
 175:  536+7	0067' BE      	                cp (hl)
 176:  543+10	0068' C23400  	                jp nz, cmd_op_error
 177:  553+10	006B' F1      	                pop af
 178:  563+7+5	006C' 3003    	                jr nc, cd_got_len
 179:  570+10	006E' 114000  	                ld de, 0x0040           ; Use default length
 180:  580+10	0071' E1      	cd_got_len      pop hl                  ; Put address in HL
 181:  590+7	0072' 3E00    	                ld a, CD_DISP_PRN       ; Force display for first line
 182:  597+13	0074' 320A00  	                ld (cd_disp_flag), a
 183:				;
 184:				; DE - bytes to display
 185:				; HL - memory address
 186:  610+11	0077' E5      	cd_line_lp      push hl                 ; Save address
 187:				; Calculate how many bytes to display in this line.
 188:  621+7	0078' 0E08    	                ld c, CD_BYTESPERLINE   ; Assume maximum initially
 189:  628+4	007A' 7A      	                ld a,d
 190:  632+4	007B' A7      	                and a
 191:  636+7+5	007C' 2006    	                jr nz, cd_line_st
 192:				; 0xff bytes or fewer.
 193:  643+4	007E' 7B      	                ld a,e
 194:  647+4	007F' B9      	                cp c
 195:  651+10	0080' D28400  	                jnc cd_line_st          ; Jump if >= maximum remaining
 196:  661+4	0083' 4B      	                ld c, e                 ; Use remaining byte count
 197:  665+7	0084' 0608    	cd_line_st      ld b, CD_BYTESPERLINE   ; Bytes per line
 198:				; B - byte counter for this line
 199:				; C - number of bytes to display (allows for partial final lines)
 200:				; DE - bytes remaining to display
 201:				; HL - pointer to data
 202:  672+4	0086' 79      	                ld a, c
 203:  676+4	0087' A7      	                and a
 204:  680+10	0088' CA3801  	                jp z, cd_done           ; Exit if no bytes to display
 205:				; Read the data to display into cd_line_bytes, comparing with the data already
 206:				; there to see if it would be changed.
 207:  690+11	008B' C5      	                push bc                 ; Save counters
 208:  701+11	008C' D5      	                push de
 209:  712+10	008D' 110200  	                ld de, cd_line_bytes    ; Buffer address
 210:  722+4	0090' EB      	                ex de, hl
 211:				; C - number of bytes to display (allows for partial final lines)
 212:				; DE - pointer to data
 213:				; HL - pointer to cd_line_bytes
 214:  726+11	0091' E5      	cd_fetch_loop   push hl
 215:  737+4	0092' 6B      	                ld l, e
 216:  741+4	0093' 62      	                ld h, d
 217:  745+17	0094' CD0000  	                call rusby              ; Read byte from user space
 218:  762+10	0097' E1      	                pop hl
 219:  772+7	0098' BE      	                cp (hl)
 220:  779+7	0099' 77      	                ld (hl), a
 221:  786+7+5	009A' 2805    	                jr z, cd_fetch_fldn
 222:				; Difference detected, so flag display required.
 223:  793+7	009C' 3E00    	                ld a, CD_DISP_PRN       ; Flag display required
 224:  800+13	009E' 320A00  	                ld (cd_disp_flag), a
 225:  813+6	00A1' 23      	cd_fetch_fldn   inc hl
 226:  819+6	00A2' 13      	                inc de
 227:  825+4	00A3' 0D      	                dec c
 228:  829+4	00A4' 79      	                ld a, c
 229:  833+4	00A5' A7      	                and a
 230:  837+7+5	00A6' 20E9    	                jr nz, cd_fetch_loop
 231:  844+10	00A8' D1      	                pop de                  ; Restore counters
 232:  854+10	00A9' C1      	                pop bc
 233:  864+10	00AA' E1      	                pop hl                  ; Restore pointer to data
 234:  874+11	00AB' E5      	                push hl
 235:				; Display the line if cd_disp_flag is set.
 236:  885+13	00AC' 3A0A00  	                ld a, (cd_disp_flag)
 237:  898+7	00AF' FE00    	                cp CD_DISP_PRN
 238:  905+7+5	00B1' 2820    	                jr z, cd_print_line
 239:  912+7	00B3' FE02    	                cp CD_DISP_ELDN
 240:  919+7+5	00B5' 2870    	                jr z, cd_line_done      ; Nothing to do if ellipsis shown
 241:				;
 242:				; Display ellipsis.
 243:  926+11	00B7' C5      	                push bc                 ; Save counters
 244:				; Print spaces.
 245:  937+7	00B8' 060E    	                ld b, 14
 246:  944+17	00BA' CD0000  	cd_ellspc_loop  call cwpspc             ; Print a space
 247:  961+8+5	00BD' 10FB    	                djnz cd_ellspc_loop
 248:				; Print ellipsis.
 249:  969+7	00BF' 0603    	                ld b, 3
 250:  976+7	00C1' 3E2E    	cd_ellips_loop  ld a, '.'
 251:  983+17	00C3' CD0000  	                call conwch
 252: 1000+8+5	00C6' 10F9    	                djnz cd_ellips_loop
 253: 1008+17	00C8' CD0000  	                call cwnwln             ; New line
 254: 1025+10	00CB' C1      	                pop bc                  ; Restore counters
 255:				; Set flag appropriately, so we don't display multiple lines with an ellipsis.
 256: 1035+7	00CC' 3E02    	                ld a, CD_DISP_ELDN      ; Flag ellipsis displayed
 257: 1042+13	00CE' 320A00  	                ld (cd_disp_flag), a
 258: 1055+12	00D1' 1854    	                jr cd_line_done         ; Line complete
 259:				;
 260:				; Display the line of data.
 261: 1067+17	00D3' CD0000  	cd_print_line   call cwphwd             ; Print address in hexadecimal
 262:				; Print spaces to separate address from data.
 263: 1084+17	00D6' CD0000  	                call cwpspc             ; Print a space
 264: 1101+17	00D9' CD0000  	                call cwpspc             ; Print a space
 265:				; Write data in hex.                
 266: 1118+10	00DC' 210200  	                ld hl, cd_line_bytes    ; Buffer address
 267: 1128+11	00DF' C5      	                push bc                 ; Save counters
 268:				; For each byte, display either data or spaces according to the number
 269:				; of bytes left.
 270: 1139+4	00E0' 79      	cd_hex_lp       ld a, c
 271: 1143+4	00E1' A7      	                and a
 272: 1147+7+5	00E2' 2008    	                jr nz, cd_hex_gotdata
 273:				; No data left. Print spaces instead.
 274: 1154+17	00E4' CD0000  	                call cwpspc             ; Print a space
 275: 1171+17	00E7' CD0000  	                call cwpspc             ; Print a space
 276: 1188+12	00EA' 1805    	                jr cd_hex_bydn
 277:				; Display byte
 278: 1200+7	00EC' 7E      	cd_hex_gotdata  ld a, (hl)
 279: 1207+17	00ED' CD0000  	                call cwphby             ; Print in hex
 280: 1224+4	00F0' 0D      	                dec c                   ; Reduce displayed data counter
 281:				; Spaces or hex printed. Display a separator.
 282: 1228+17	00F1' CD0000  	cd_hex_bydn     call cwpspc             ; Print a space
 283: 1245+6	00F4' 23      	                inc hl
 284: 1251+8+5	00F5' 10E9    	                djnz cd_hex_lp          ; Loop for all bytes in a row
 285:				; Hex-ASCII separator
 286: 1259+17	00F7' CD0000  	                call cwpspc             ; Print a space
 287: 1276+7	00FA' 3E7C    	                ld a, '|'
 288: 1283+17	00FC' CD0000  	                call conwch
 289:				; Write data in ASCII.
 290: 1300+10	00FF' C1      	                pop bc                  ; Restore counters
 291: 1310+11	0100' C5      	                push bc
 292: 1321+10	0101' 210200  	                ld hl, cd_line_bytes    ; Buffer address
 293:				; For each byte, display either the character or a space according to the
 294:				; number of bytes left.
 295: 1331+4	0104' 79      	cd_asc_lp       ld a, c
 296: 1335+4	0105' A7      	                and a
 297: 1339+7+5	0106' 2005    	                jr nz, cd_asc_gotdata
 298:				; No data left. Print a space instead.
 299: 1346+17	0108' CD0000  	                call cwpspc             ; Print a space
 300: 1363+12	010B' 1809    	                jr cd_asc_bydn
 301:				; Display byte
 302: 1375+7	010D' 7E      	cd_asc_gotdata  ld a, (hl)
 303: 1382+11	010E' C5      	                push bc                 ; Save counters
 304: 1393+7	010F' 0E2E    	                ld c, '.'               ; Substitution character
 305: 1400+17	0111' CD0000  	                call cwvich             ; Print visible characters only
 306: 1417+10	0114' C1      	                pop bc                  ; Restore counters
 307: 1427+4	0115' 0D      	                dec c                   ; Reduce displayed data counter
 308: 1431+6	0116' 23      	cd_asc_bydn     inc hl
 309: 1437+8+5	0117' 10EB    	                djnz cd_asc_lp
 310: 1445+10	0119' C1      	                pop bc                  ; Restore counters
 311:				; Separator
 312: 1455+7	011A' 3E7C    	                ld a, '|'
 313: 1462+17	011C' CD0000  	                call conwch
 314: 1479+17	011F' CD0000  	                call cwnwln             ; End of line
 315:				; Flag identical data for next line. This will be overwritten if differences are
 316:				; detected.
 317: 1496+7	0122' 3E01    	                ld a, CD_DISP_SAME
 318: 1503+13	0124' 320A00  	                ld (cd_disp_flag), a
 319:				; Line complete.
 320: 1516+10	0127' E1      	cd_line_done    pop hl
 321: 1526+11	0128' C5      	                push bc
 322:				; Reduce overall bytes displayed (in DE) by the appropriate amount (in C).
 323: 1537+7	0129' 0600    	                ld b, 0
 324: 1544+4	012B' EB      	                ex de, hl
 325: 1548+4	012C' A7      	                and a
 326: 1552+15	012D' ED42    	                sbc hl, bc
 327: 1567+4	012F' EB      	                ex de, hl
 328:				; Update address for next line.
 329: 1571+10	0130' 010800  	                ld bc, CD_BYTESPERLINE
 330: 1581+11	0133' 09      	                add hl, bc
 331: 1592+10	0134' C1      	                pop bc
 332: 1602+10	0135' C37700  	                jp cd_line_lp           ; Do next line
 333:				;               
 334: 1612+10	0138' E1      	cd_done         pop hl                  ; Discard address
 335: 1622+10	0139' C9      	                ret
 336:				;
 337:				;
 338:				; Disassemble an area of memory.
 339:				; Command format:
 340:				; disassemble [<start addr>] [<length>]
 341:				; start addr defaults to the current PC if not specified.
 342:				; length defaults to 0x0010 if not specified.
 343: 1632+17	013A' CD0000  	cmd_disassemble call skpspc             ; Skip spaces
 344: 1649+17	013D' CD0000  	                call rdhxwd             ; Fetch address
 345: 1666+7+5	0140' 300E    	                jr nc, cdi_operands
 346:				; No operands, so the next thing in the command buffer should be the terminator.
 347: 1673+4	0142' AF      	                xor a
 348: 1677+7	0143' BE      	                cp (hl)
 349: 1684+10	0144' C23400  	                jp nz, cmd_op_error
 350:				; Set default address (PC) and length.
 351: 1694+19	0147' DD6E08  	                ld l, (ix + MST_PC)
 352: 1713+19	014A' DD6609  	                ld h, (ix + MST_PC + 1)
 353: 1732+11	014D' E5      	                push hl                 ; Save starting address
 354: 1743+12	014E' 1813    	                jr cdi_def_len          ; Use default lengthx
 355:				;
 356:				; We have at least one operand (the address).
 357: 1755+11	0150' D5      	cdi_operands    push de                 ; Save starting address
 358: 1766+17	0151' CD0000  	                call skpspc             ; Skip spaces
 359: 1783+17	0154' CD0000  	                call rdhxwd             ; Fetch length
 360: 1800+11	0157' F5      	                push af                 ; Save carry flag
 361: 1811+17	0158' CD0000  	                call skpspc             ; Skip spaces
 362:				; The next thing in the command buffer should be the terminator.
 363: 1828+4	015B' AF      	                xor a
 364: 1832+7	015C' BE      	                cp (hl)
 365: 1839+10	015D' C23400  	                jp nz, cmd_op_error
 366: 1849+10	0160' F1      	                pop af
 367: 1859+7+5	0161' 3003    	                jr nc, cdi_got_len
 368: 1866+10	0163' 111000  	cdi_def_len     ld de, 0x0010           ; Use default length
 369: 1876+10	0166' E1      	cdi_got_len     pop hl                  ; Put address in HL
 370:				; HL - address
 371:				; DE - length in bytes
 372:				; Calculate last address
 373: 1886+4	0167' EB      	                ex de, hl
 374: 1890+11	0168' 19      	                add hl, de
 375: 1901+4	0169' EB      	                ex de, hl
 376: 1905+6	016A' 13      	                inc de
 377:				; DE - last address to disassemble + 1
 378: 1911+17	016B' CD0000  	cdi_line_lp     call diproc             ; Disassemble instruction to intermediate form
 379: 1928+17	016E' CD0000  	                call diprnt             ; Print the result
 380: 1945+17	0171' CD0000  	                call cwnwln             ; New line
 381: 1962+11	0174' E5      	                push hl
 382: 1973+4	0175' A7      	                and a
 383: 1977+15	0176' ED52    	                sbc hl, de
 384: 1992+10	0178' E1      	                pop hl
 385: 2002+7+5	0179' 38F0    	                jr c, cdi_line_lp
 386: 2009+10	017B' C9      	                ret
 387:				;
 388:				;
 389:				; Write data to memory
 390:				; Command format:
 391:				; write <addr> <data1> [<data2> <data3> ...]
 392: 2019+17	017C' CD0000  	cmd_write       call rdhxwd             ; Fetch address
 393: 2036+10	017F' DA3400  	                jp c, cmd_op_error      ; Address is required              
 394: 2046+10	0182' 010000  	                ld bc, 0                ; Reset byte count
 395:				; HL - address in command buffer
 396:				; DE - memory address
 397:				; BC - byte counter
 398: 2056+11	0185' C5      	cwr_byte_lp     push bc                 ; Save byte count
 399: 2067+11	0186' D5      	                push de                 ; Save memory address
 400: 2078+17	0187' CD0000  	                call skpspc             ; Skip spaces
 401: 2095+17	018A' CD0000  	                call rdhxwd             ; Fetch byte
 402: 2112+7+5	018D' 3814    	                jr c, cwr_done          ; Exit it no valid number remains
 403: 2119+4	018F' 7A      	                ld a, d
 404: 2123+4	0190' A7      	                and a
 405: 2127+10	0191' C23400  	                jp nz, cmd_op_error     ; Error if value > 8 bits
 406: 2137+4	0194' 7B      	                ld a, e
 407: 2141+4	0195' EB      	                ex de, hl               ; Save command pointer to de
 408: 2145+10	0196' E1      	                pop hl                  ; Restore memory address
 409: 2155+17	0197' CD0000  	                call wusby              ; Write byte to user space
 410: 2172+10	019A' DA3D00  	                jp c, mcprot
 411: 2182+6	019D' 23      	                inc hl
 412:				; DE - address in command buffer
 413:				; HL - memory address
 414: 2188+4	019E' EB      	                ex de, hl               ; Swap pointers
 415: 2192+10	019F' C1      	                pop bc                  ; Restore byte count
 416: 2202+6	01A0' 03      	                inc bc                  ; Count bytes
 417: 2208+12	01A1' 18E2    	                jr cwr_byte_lp
 418:				; The next thing in the command buffer should be the terminator.
 419: 2220+17	01A3' CD0000  	cwr_done        call skpspc      ; Skip spaces
 420: 2237+4	01A6' AF      	                xor a
 421: 2241+7	01A7' BE      	                cp (hl)
 422: 2248+10	01A8' C23400  	                jp nz, cmd_op_error
 423:				; Write number of bytes written.
 424: 2258+6	01AB' 33      	                inc sp                  ; Discard memory address
 425: 2264+6	01AC' 33      	                inc sp
 426: 2270+10	01AD' E1      	                pop hl                  ; Restore byte count
 427: 2280+17	01AE' CD0000  	                call cwphwd             ; Print number of bytes written
 428: 2297+10	01B1' 21E40C  	                ld hl, cwr_bytes_msg
 429: 2307+17	01B4' CD0000  	                call conwms             ; Print message
 430: 2324+10	01B7' C9      	                ret
 431:				;
 432:				;
 433:				; Fill a block of memory with a byte value.
 434:				; Command format:
 435:				; fill <addr> <length> <data>
 436: 2334+17	01B8' CD0000  	cmd_fill        call rdhxwd             ; Fetch address
 437: 2351+10	01BB' DA3400  	                jp c, cmd_op_error      ; Address is required
 438: 2361+11	01BE' D5      	                push de
 439: 2372+17	01BF' CD0000  	                call skpspc             ; Skip spaces
 440: 2389+17	01C2' CD0000  	                call rdhxwd             ; Fetch data
 441: 2406+10	01C5' DA3400  	                jp c, cmd_op_error      ; Length is required
 442: 2416+11	01C8' D5      	                push de
 443: 2427+17	01C9' CD0000  	                call skpspc             ; Skip spaces
 444: 2444+17	01CC' CD0000  	                call rdhxwd             ; Fetch data
 445: 2461+10	01CF' DA3400  	                jp c, cmd_op_error      ; Address is required
 446: 2471+4	01D2' 7A      	                ld a, d
 447: 2475+4	01D3' A7      	                and a
 448: 2479+10	01D4' C23400  	                jp nz, cmd_op_error     ; Error if value > 8 bits
 449:				; The next thing in the command buffer should be the terminator.
 450: 2489+17	01D7' CD0000  	                call skpspc             ; Skip spaces
 451: 2506+4	01DA' AF      	                xor a
 452: 2510+7	01DB' BE      	                cp (hl)
 453: 2517+10	01DC' C23400  	                jp nz, cmd_op_error
 454: 2527+10	01DF' C1      	                pop bc
 455: 2537+10	01E0' E1      	                pop hl
 456:				; E - byte data
 457:				; BC - length
 458:				; HL - address
 459: 2547+4	01E1' 7B      	cf_loop         ld a, e
 460: 2551+17	01E2' CD0000  	                call wusby              ; Write byte to user space
 461: 2568+10	01E5' DA3D00  	                jp c, mcprot
 462: 2578+6	01E8' 23      	                inc hl
 463: 2584+6	01E9' 0B      	                dec bc
 464: 2590+4	01EA' 79      	                ld a, c
 465: 2594+4	01EB' B0      	                or b
 466: 2598+7+5	01EC' 20F3    	                jr nz, cf_loop
 467: 2605+10	01EE' C9      	                ret
 468:				;
 469:				;
 470:				; Read a single memory location
 471:				; Command format:
 472:				; read <addr>
 473: 2615+17	01EF' CD0000  	cmd_read        call rdhxwd             ; Fetch address
 474: 2632+10	01F2' DA3400  	                jp c, cmd_op_error      ; Address is required              
 475:				; HL - address in command buffer
 476:				; DE - memory address
 477:				; The next thing in the command buffer should be the terminator.
 478: 2642+17	01F5' CD0000  	                call skpspc             ; Skip spaces
 479: 2659+4	01F8' AF      	                xor a
 480: 2663+7	01F9' BE      	                cp (hl)
 481: 2670+10	01FA' C23400  	                jp nz, cmd_op_error
 482: 2680+4	01FD' EB      	                ex de, hl
 483:				; HL - memory address
 484: 2684+17	01FE' CD0000  	                call rusby              ; Read byte from user space
 485: 2701+17	0201' CD0000  	                call cwphby             ; Print result
 486: 2718+10	0204' C30000  	                jp cwnwln               ; New line and exit
 487:				;
 488:				;
 489:				; Read an I/O location
 490:				; Command format:
 491:				; in <addr>
 492: 2728+17	0207' CD0000  	cmd_in          call rdhxwd             ; Fetch address
 493: 2745+10	020A' DA3400  	                jp c, cmd_op_error      ; Address is required              
 494:				; HL - address in command buffer
 495:				; DE - I/O address
 496:				; The next thing in the command buffer should be the terminator.
 497: 2755+17	020D' CD0000  	                call skpspc             ; Skip spaces
 498: 2772+4	0210' AF      	                xor a
 499: 2776+7	0211' BE      	                cp (hl)
 500: 2783+10	0212' C23400  	                jp nz, cmd_op_error
 501: 2793+4	0215' 7A      	                ld a, d
 502: 2797+4	0216' A7      	                and a
 503: 2801+10	0217' C23400  	                jp nz, cmd_op_error     ; Error if not an 8-bit address
 504: 2811+4	021A' 4B      	                ld c, e
 505: 2815+12	021B' ED78    	                in a, (c)
 506: 2827+17	021D' CD0000  	                call cwphby             ; Print result
 507: 2844+10	0220' C30000  	                jp cwnwln               ; New line and exit
 508:				;
 509:				;
 510:				; Write data to I/O
 511:				; Command format:
 512:				; out <addr> <data1> [<data2> <data3> ...]
 513:				; Note that the I/O address is incremented for each byte written.
 514: 2854+17	0223' CD0000  	cmd_out         call rdhxwd             ; Fetch address
 515: 2871+10	0226' DA3400  	                jp c, cmd_op_error      ; Address is required
 516: 2881+4	0229' 7A      	                ld a, d
 517: 2885+4	022A' A7      	                and a
 518: 2889+10	022B' C23400  	                jp nz, cmd_op_error     ; Error if not an 8-bit address
 519: 2899+10	022E' 010000  	                ld bc, 0                ; Reset byte count
 520:				; HL - address in command buffer
 521:				; E - I/O address
 522:				; C - byte counter
 523: 2909+11	0231' C5      	cout_byte_lp    push bc                 ; Save byte count
 524: 2920+11	0232' D5      	                push de                 ; Save I/O address
 525: 2931+17	0233' CD0000  	                call skpspc             ; Skip spaces
 526: 2948+17	0236' CD0000  	                call rdhxwd             ; Fetch byte
 527: 2965+7+5	0239' 380F    	                jr c, cout_done         ; Exit it no valid number remains
 528: 2972+4	023B' 7A      	                ld a, d
 529: 2976+4	023C' A7      	                and a
 530: 2980+10	023D' C23400  	                jp nz, cmd_op_error     ; Error if value > 8 bits
 531: 2990+4	0240' 7B      	                ld a, e
 532: 2994+10	0241' D1      	                pop de                  ; Restore I/O address
 533: 3004+4	0242' 4B      	                ld c, e
 534: 3008+12	0243' ED79    	                out (c), a              ; Write data to I/O
 535: 3020+4	0245' 1C      	                inc e
 536: 3024+10	0246' C1      	                pop bc                  ; Restore byte count
 537: 3034+6	0247' 03      	                inc bc                  ; Count bytes
 538: 3040+12	0248' 18E7    	                jr cout_byte_lp
 539:				; The next thing in the command buffer should be the terminator.
 540: 3052+17	024A' CD0000  	cout_done       call skpspc             ; Skip spaces
 541: 3069+4	024D' AF      	                xor a
 542: 3073+7	024E' BE      	                cp (hl)
 543: 3080+10	024F' C23400  	                jp nz, cmd_op_error
 544:				; Write number of bytes written.
 545: 3090+6	0252' 33      	                inc sp                  ; Discard memory address
 546: 3096+6	0253' 33      	                inc sp
 547: 3102+10	0254' E1      	                pop hl                  ; Restore byte count
 548: 3112+17	0255' CD0000  	                call cwphwd             ; Print number of bytes written
 549: 3129+10	0258' 21E40C  	                ld hl, cwr_bytes_msg
 550: 3139+17	025B' CD0000  	                call conwms             ; Print message
 551: 3156+10	025E' C9      	                ret
 552:				;
 553:				;
 554:				; Display or change the user context memory mapping. With no operands, the
 555:				; command displays the current state, for example:
 556:				; 0 (0000 - 3fff): 3f [MONP] writeable supervisor
 557:				; 1 (4000 - 7fff): 00 [MOND] read only
 558:				; 2 (8000 - bfff): 01 [unallocated] read only
 559:				; 3 (c000 - ffff): 02 [unallocated] writeable
 560:				; To change the mapping, use:
 561:				; map <register> <page> [<prot>] [<super>]
 562: 3166+4	025F' AF      	cmd_map         xor a
 563: 3170+7	0260' BE      	                cp (hl)
 564: 3177+7+5	0261' 284D    	                jr z, cm_display        ; No operand, so display map
 565:				; Something follows the command. This should be a bank number
 566: 3184+17	0263' CD0000  	                call rdhxwd             ; Fetch bank number
 567: 3201+10	0266' DA3400  	                jp c, cmd_op_error
 568: 3211+4	0269' 7A      	                ld a, d
 569: 3215+4	026A' A7      	                and a
 570: 3219+10	026B' C23400  	                jp nz, cmd_op_error     ; MS byte should be zero
 571: 3229+4	026E' 7B      	                ld a, e
 572: 3233+7	026F' FE04    	                cp MMAP_BANKS
 573: 3240+10	0271' D23400  	                jp nc, cmd_op_error     ; Error if too big
 574: 3250+4	0274' 43      	                ld b, e                 ; Save for later
 575:				; Read page.
 576: 3254+17	0275' CD0000  	                call skpspc             ; Skip spaces
 577: 3271+17	0278' CD0000  	                call rdhxwd             ; Fetch page
 578: 3288+10	027B' DA3400  	                jp c, cmd_op_error
 579: 3298+4	027E' 7A      	                ld a, d
 580: 3302+4	027F' A7      	                and a
 581: 3306+10	0280' C23400  	                jp nz, cmd_op_error     ; MS byte should be zero
 582: 3316+4	0283' 7B      	                ld a, e
 583: 3320+7	0284' FE40    	                cp MMAP_PAGES
 584: 3327+10	0286' D23400  	                jp nc, cmd_op_error     ; Error if too big
 585:				; HL - address in command buffer
 586:				; E - new RAM page
 587:				; B - bank number
 588:				; Loop, reading operands and collating the options. Repeating options
 589:				; are permitted (though not useful).
 590: 3337+17	0289' CD0000  	cm_op_loop      call skpspc             ; Skip spaces
 591: 3354+4	028C' AF      	                xor a
 592: 3358+7	028D' BE      	                cp (hl)
 593: 3365+7+5	028E' 2814    	                jr z, cm_ops_done       ; Jump if no more operands
 594:				; Match next operand against list of options.
 595: 3372+11	0290' D5      	                push de                 ; Save page
 596: 3383+10	0291' 111C0D  	                ld de, cm_op_list
 597: 3393+7	0294' 3E03    	                ld a, MTWDLI_ABBREV_MASK | MTWDLI_ICASE_MASK
 598: 3400+17	0296' CD0000  	                call mtwdli             ; Match against list of options
 599: 3417+10	0299' D1      	                pop de
 600: 3427+4	029A' A7      	                and a
 601: 3431+10	029B' CA3400  	                jp z, cmd_op_error
 602:				; 1 = prot, 2 = super.
 603: 3441+4	029E' 0F      	                rrca                    ; Rotate to MS bits
 604: 3445+4	029F' 0F      	                rrca
 605: 3449+4	02A0' B3      	                or e                    ; Combine with page
 606: 3453+4	02A1' 5F      	                ld e, a
 607: 3457+12	02A2' 18E5    	                jr cm_op_loop
 608:				; All operands have been read.
 609:				; E - new RAM page with PROT and SUPER bits
 610:				; B - bank number
 611:				; Find the appropriate bank in the machine state.
 612: 3469+10	02A4' 210200  	cm_ops_done     ld hl, mstate + MST_MMAP0
 613: 3479+4	02A7' 78      	                ld a, b
 614: 3483+4	02A8' 85      	                add l
 615: 3487+4	02A9' 6F      	                ld l, a
 616: 3491+4	02AA' 7C      	                ld a, h
 617: 3495+7	02AB' CE00    	                adc 0
 618: 3502+4	02AD' 67      	                ld h, a
 619: 3506+7	02AE' 73      	                ld (hl), e              ; Set page
 620: 3513+10	02AF' C9      	                ret
 621:				;
 622:				; Display the current mapping.
 623:				; 0 (0000 - 3fff): 3f [MONP] writeable supervisor
 624:				; 1 (4000 - 7fff): 00 [MOND] read only
 625:				; 2 (8000 - bfff): 01 [unallocated] read only
 626:				; 3 (c000 - ffff): 02 [unallocated] writeable
 627: 3523+7	02B0' 0600    	cm_display      ld b, 0                 ; Bank count
 628: 3530+4	02B2' 78      	cm_regloop      ld a, b
 629: 3534+17	02B3' CD0000  	                call cwphnb             ; Print bank as a nibble
 630: 3551+17	02B6' CD0000  	                call cwpspc             ; Print a space
 631: 3568+7	02B9' 3E28    	                ld a, '('
 632: 3575+17	02BB' CD0000  	                call conwch
 633: 3592+4	02BE' 78      	                ld a, b                 ; Calculate start address
 634: 3596+4	02BF' 0F      	                rrca                    ; Rotate to MS bits
 635: 3600+4	02C0' 0F      	                rrca
 636: 3604+4	02C1' 67      	                ld h, a
 637: 3608+7	02C2' 2E00    	                ld l, 0
 638:				; Now hl is the base address as required.
 639: 3615+11	02C4' E5      	                push hl                 ; Save it
 640: 3626+17	02C5' CD0000  	                call cwphwd             ; Print address in hexadecimal
 641: 3643+10	02C8' 21F50C  	                ld hl, cm_range_msg     ; " - "
 642: 3653+17	02CB' CD0000  	                call conwms             ; Print message
 643: 3670+10	02CE' E1      	                pop hl                  ; Fetch base address
 644: 3680+10	02CF' 11FF3F  	                ld de, MMAP_PAGE_SIZE - 1
 645: 3690+11	02D2' 19      	                add hl, de
 646: 3701+17	02D3' CD0000  	                call cwphwd             ; Print address in hexadecimal
 647:				; Separator
 648: 3718+7	02D6' 3E29    	                ld a, ')'
 649: 3725+17	02D8' CD0000  	                call conwch
 650: 3742+7	02DB' 3E3A    	                ld a, ':'
 651: 3749+17	02DD' CD0000  	                call conwch
 652: 3766+17	02E0' CD0000  	                call cwpspc             ; Print a space
 653:				; Find the appropriate bank in the machine state.
 654: 3783+11	02E3' E5      	                push hl
 655: 3794+10	02E4' 210200  	                ld hl, mstate + MST_MMAP0
 656: 3804+4	02E7' 78      	                ld a, b
 657: 3808+4	02E8' 85      	                add l
 658: 3812+4	02E9' 6F      	                ld l, a
 659: 3816+4	02EA' 7C      	                ld a, h
 660: 3820+7	02EB' CE00    	                adc 0
 661: 3827+4	02ED' 67      	                ld h, a
 662: 3831+7	02EE' 7E      	                ld a, (hl)              ; Fetch page
 663: 3838+4	02EF' 4F      	                ld c, a                 ; Save it for later
 664: 3842+10	02F0' E1      	                pop hl
 665: 3852+7	02F1' E63F    	                and MMAP_PAGE_MASK      ; Isolate page bits
 666: 3859+17	02F3' CD0000  	                call cwphby             ; Print page number in hexadecimal
 667: 3876+17	02F6' CD0000  	                call cwpspc             ; Print a space
 668:				;
 669: 3893+4	02F9' 79      	                ld a, c
 670: 3897+7	02FA' E63F    	                and MMAP_PAGE_MASK      ; Isolate page bits
 671: 3904+17	02FC' CD2303  	                call prpnam             ; Print page name
 672: 3921+17	02FF' CD0000  	                call cwpspc             ; Print a space
 673:				;
 674:				; Write "writeable" or "read only" as appropriate.
 675: 3938+10	0302' 21F90C  	                ld hl, cm_write_msg     ; " writeable"
 676: 3948+8	0305' CB79    	                bit MMAP_PROT_BIT, c
 677: 3956+7+5	0307' 2803    	                jr z, cm_prot_pmsg
 678: 3963+10	0309' 21040D  	                ld hl, cm_ro_msg        ; " read only"
 679: 3973+17	030C' CD0000  	cm_prot_pmsg    call conwms             ; Print message
 680:				; Write "supervisor" if appropriate.
 681: 3990+8	030F' CB71    	                bit MMAP_SUPER_BIT, c
 682: 3998+7+5	0311' 2806    	                jr z, cm_regdn
 683: 4005+10	0313' 210F0D  	                ld hl, cm_super_msg     ; ", supervisor"
 684: 4015+17	0316' CD0000  	                call conwms             ; Print message
 685: 4032+17	0319' CD0000  	cm_regdn        call cwnwln             ; New line
 686: 4049+4	031C' 04      	                inc b
 687: 4053+4	031D' 78      	                ld a, b
 688: 4057+7	031E' FE04    	                cp MMAP_BANKS
 689: 4064+7+5	0320' 3890    	                jr c, cm_regloop        ; Loop for all banks
 690: 4071+10	0322' C9      	                ret
 691:				;
 692:				;
 693:				; Print page name, e.g. "[MONP] " or "[unallocated] ". Call with:
 694:				; A - page number
 695: 4081+11	0323' E5      	prpnam          push hl
 696: 4092+11	0324' F5      	                push af
 697: 4103+7	0325' 3E5B    	                ld a, '['
 698: 4110+17	0327' CD0000  	                call conwch
 699: 4127+10	032A' F1      	                pop af
 700: 4137+17	032B' CD0000  	                call mppnam             ; Print entry name
 701: 4154+7+5	032E' 3006    	                jr nc, prpn_name_dn
 702:				; Page is not allocated.
 703: 4161+10	0330' 21270D  	                ld hl, cm_unalloc_msg   ; "unallocated"
 704: 4171+17	0333' CD0000  	                call conwms             ; Print message
 705: 4188+7	0336' 3E5D    	prpn_name_dn    ld a, ']'
 706: 4195+17	0338' CD0000  	                call conwch
 707: 4212+17	033B' CD0000  	                call cwpspc             ; Print a space
 708: 4229+10	033E' E1      	                pop hl
 709: 4239+10	033F' C9      	                ret
 710:				;
 711:				;
 712:				; Display page allocations.
 713:				; The next thing in the command buffer should be the terminator.
 714: 4249+4	0340' AF      	cmd_pages       xor a
 715: 4253+7	0341' BE      	                cp (hl)
 716: 4260+10	0342' C23400  	                jp nz, cmd_op_error     ; No operands expected
 717: 4270+10	0345' C30000  	                jp mprpt                ; Report allocation status
 718:				;
 719:				;
 720:				; Perform a cold start. This reinitialises certain variables, such as the
 721:				; memory page allocations.
 722: 4280+4	0348' AF      	cmd_cold        xor a
 723: 4284+13	0349' 320000  	                ld (warm1), a           ; Overwrite warm start marker 1 
 724: 4297+11	034C' C7      	                rst 0                   ; This will force a cold start
 725:				;
 726:				;
 727:				; Display system information.
 728:				; The next thing in the command buffer should be the terminator.
 729: 4308+4	034D' AF      	cmd_info        xor a
 730: 4312+7	034E' BE      	                cp (hl)
 731: 4319+10	034F' C23400  	                jp nz, cmd_op_error
 732:				; FPGA firmware version
 733: 4329+10	0352' 21470D  	                ld hl, ci_fpga_rev_msg  ; "FPGA revision: "
 734: 4339+17	0355' CD0000  	                call conwms             ; Print message
 735: 4356+11	0358' DB00    	                in a, (IOA_FPGA_MAJREV) 
 736: 4367+17	035A' CD0000  	                call cwphby             ; Print byte in hexadecimal
 737: 4384+7	035D' 3E2E    	                ld a, '.'
 738: 4391+17	035F' CD0000  	                call conwch 
 739: 4408+11	0362' DB01    	                in a, (IOA_FPGA_MINREV) 
 740: 4419+17	0364' CD0000  	                call cwphby             ; Print byte in hexadecimal
 741:				; Total RAM in system
 742: 4436+10	0367' 21570D  	                ld hl, ci_ram_msg       ; "Total RAM: "
 743: 4446+17	036A' CD0000  	                call conwms             ; Print message
 744:				; Note - "+" is required to prevent this being misinterpreted as an indirect load.
 745: 4463+10	036D' 210004  	                ld hl, +((MMAP_PAGE_SIZE /1024) * MMAP_PAGES)
 746: 4473+17	0370' CD0000  	                call cwpdwd             ; Print size in decimal
 747:				; CPU speed
 748: 4490+10	0373' 21650D  	                ld hl, ci_cpuspd_msg    ; "CPU clock: "
 749: 4500+17	0376' CD0000  	                call conwms             ; Print message
 750: 4517+16	0379' 2A0000  	                ld hl, (mcspd)          ; Approximate CPU speed in KHz
 751: 4533+17	037C' CD0000  	                call cwpdwd             ; Print in decimal
 752: 4550+10	037F' 21760D  	                ld hl, ci_khz_msg       ; " KHz"
 753: 4560+17	0382' CD0000  	                call conwms             ; Print message
 754:				; Monitor start count
 755: 4577+10	0385' 217B0D  	                ld hl, ci_mon_cnt_msg   ; "Monitor starts: "
 756: 4587+17	0388' CD0000  	                call conwms             ; Print message
 757: 4604+16	038B' 2A0000  	                ld hl, (mscnt)          ; Monitor start count
 758: 4620+17	038E' CD0000  	                call cwpdwd             ; Print reset counter in decimal
 759:				; Current console port
 760: 4637+10	0391' 218E0D  	                ld hl, ci_con_port      ; "Console port: "
 761: 4647+17	0394' CD0000  	                call conwms             ; Print message
 762: 4664+10	0397' 217F0E  	                ld hl, prt_name_list    ; Port name list
 763: 4674+7	039A' 0E20    	                ld c, ' '               ; Separator
 764: 4681+13	039C' 3A0000  	                ld a, (coport)
 765: 4694+17	039F' CD0000  	                call conwmn             ; Print message <n> in a list
 766:				; Current data transfer port
 767: 4711+10	03A2' 219F0D  	                ld hl, ci_tran_port     ; "Data transfer port: "
 768: 4721+17	03A5' CD0000  	                call conwms             ; Print message
 769: 4738+10	03A8' 217F0E  	                ld hl, prt_name_list    ; Port name list
 770: 4748+7	03AB' 0E20    	                ld c, ' '               ; Separator
 771: 4755+13	03AD' 3A0000  	                ld a, (trport)
 772: 4768+17	03B0' CD0000  	                call conwmn             ; Print message <n> in a list
 773:				;
 774: 4785+17	03B3' CD0000  	                call cwnwln             ; New line
 775: 4802+10	03B6' C9      	                ret
 776:				;
 777:				;
 778:				; Display cache state.
 779:				; The next thing in the command buffer should be the terminator.
 780: 4812+4	03B7' AF      	cmd_cache       xor a
 781: 4816+7	03B8' BE      	                cp (hl)
 782: 4823+10	03B9' C23400  	                jp nz, cmd_op_error     ; No operands expected
 783: 4833+10	03BC' C30000  	                jp carpt                ; Report cache status
 784:				;
 785:				;
 786:				; Test all of memory apart from the two pages used for the monitor. This is a
 787:				; very destructive test. Use with caution!
 788: 4843+4	03BF' AF      	cmd_memtest     xor a
 789: 4847+7	03C0' BE      	                cp (hl)
 790: 4854+10	03C1' C23400  	                jp nz, cmd_op_error     ; No operands expected
 791: 4864+4	03C4' AF      	                xor a
 792: 4868+13	03C5' 320B00  	                ld (cm_err_flag), a     ; Reset error counter
 793:				;
 794:				; Ask for confirmation as the test is very destructive.
 795: 4881+10	03C8' 219C09  	                ld hl, cmd_conf_msg
 796: 4891+17	03CB' CD0000  	                call conwms             ; Print "Continue" message
 797: 4908+17	03CE' CD0000  	                call conrch             ; Fetch next character from user
 798: 4925+11	03D1' F5      	                push af
 799: 4936+17	03D2' CD0000  	                call conwch             ; Echo the response
 800: 4953+17	03D5' CD0000  	                call cwnwln             ; Write new line characters to console
 801: 4970+10	03D8' F1      	                pop af
 802: 4980+7	03D9' FE79    	                cp 'y'
 803: 4987+5+6	03DB' C0      	                ret nz                  ; Exit unless confirmed
 804:				; Pass / fail is reported by the test code, so no need to check the error code.
 805: 4992+10	03DC' C30000  	                jp  memtal
 806:				;
 807:				;
 808:				; Read or write to / from the real time clock.
 809: 5002+17	03DF' CD0000  	cmd_time        call skpspc             ; Skip spaces
 810: 5019+11	03E2' E5      	                push hl                 ; Save command line pointer
 811:				; We need to read the current time and date regardless of whether the intent is to
 812:				; read or set the time.
 813: 5030+17	03E3' CD0000  	                call tird               ; Read current time and date
 814: 5047+4	03E6' A7      	                and a
 815: 5051+7+5	03E7' 2810    	                jr z, ct_rtcreadok
 816: 5058+10	03E9' E1      	                pop hl                  ; Fix stack
 817:				; RTC read error
 818: 5068+4	03EA' 4F      	ct_rtc_err      ld c, a
 819: 5072+10	03EB' 21B60D  	                ld hl, ti_rtc_err_msg
 820: 5082+17	03EE' CD0000  	                call conwms             ; Print "RTC error " message
 821: 5099+4	03F1' 79      	                ld a, c
 822: 5103+17	03F2' CD0000  	                call cwphby             ; Print error code in hex
 823: 5120+17	03F5' CD0000  	                call cwnwln             ; New line
 824: 5137+10	03F8' C9      	                ret
 825:				;
 826:				; 32-bit time is in DEHL.
 827: 5147+14	03F9' DD210C00	ct_rtcreadok    ld ix, time_tm
 828: 5161+17	03FD' CD0000  	                call tiitos             ; Convert integer time to TM structure
 829:				; Read or set?
 830: 5178+10	0400' E1      	                pop hl                  ; Restore command line pointer
 831: 5188+4	0401' AF      	                xor a
 832: 5192+7	0402' BE      	                cp (hl)
 833: 5199+10	0403' C21104  	                jp nz, ct_set           ; Attempt set
 834:				; Nothing follows the command, so display the current time in this format:
 835:				; <hours>:<minutes>:<seconds> <day of week> <day>/<month>/<year>
 836: 5209+14	0406' DD210C00	                ld ix, time_tm
 837: 5223+17	040A' CD0000  	                call cwptm              ; Print time structure to console
 838: 5240+17	040D' CD0000  	                call cwnwln             ; New line
 839: 5257+10	0410' C9      	                ret
 840:				;
 841:				; Set time. This may be a time, or time and date:
 842:				; <hours>:<minutes>:<seconds> <day>/<month>/<year>
 843:				; <hours>:<minutes>:<seconds>
 844:				; <hours>:<minutes>
 845:				; A read has already been performed, so the current time and date is in time_tm.
 846: 5267+14	0411' DD210C00	ct_set          ld ix, time_tm
 847:				; Hours
 848: 5281+17	0415' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
 849: 5298+10	0418' DA3400  	                jp c, cmd_op_error
 850:				; DE - number
 851:				; HL - command line pointer
 852: 5308+19	041B' DD7302  	                ld (ix + TM_HOURS), e   ; Hours [0,23]
 853:				; Check range
 854: 5327+10	041E' 011800  	                ld bc, 24
 855: 5337+4	0421' EB      	                ex de, hl
 856: 5341+4	0422' A7      	                and a
 857: 5345+15	0423' ED42    	                sbc hl, bc
 858: 5360+10	0425' D23400  	                jp nc, cmd_op_error     ; Error if out of range
 859: 5370+4	0428' EB      	                ex de, hl
 860:				; Separator
 861: 5374+7	0429' 3E3A    	                ld a, ':'
 862: 5381+7	042B' BE      	                cp (hl)
 863: 5388+10	042C' C23400  	                jp nz, cmd_op_error     ; Error if no separator
 864: 5398+6	042F' 23      	                inc hl
 865:				; Minutes
 866: 5404+17	0430' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
 867: 5421+10	0433' DA3400  	                jp c, cmd_op_error
 868:				; DE - number
 869:				; HL - command line pointer
 870: 5431+19	0436' DD7301  	                ld (ix + TM_MINS), e    ; Minutes [0,59]
 871:				; Check range
 872: 5450+10	0439' 013C00  	                ld bc, 60
 873: 5460+4	043C' EB      	                ex de, hl
 874: 5464+4	043D' A7      	                and a
 875: 5468+15	043E' ED42    	                sbc hl, bc
 876: 5483+10	0440' D23400  	                jp nc, cmd_op_error     ; Error if out of range
 877: 5493+4	0443' EB      	                ex de, hl
 878:				; This may be the end of the line a terminator before the seconds or a space
 879:				; before the date.
 880: 5497+7	0444' 7E      	                ld a, (hl)
 881: 5504+4	0445' A7      	                and a
 882: 5508+7+5	0446' 287D    	                jr z, cts_parse_done    ; Jump if end of line (hours & minutes only)
 883: 5515+7	0448' FE3A    	                cp ':'
 884: 5522+10	044A' C26604  	                jp nz, cts_chk_date     ; Date may follow
 885: 5532+6	044D' 23      	                inc hl
 886:				; Seconds
 887: 5538+17	044E' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
 888: 5555+10	0451' DA3400  	                jp c, cmd_op_error
 889:				; DE - number
 890:				; HL - command line pointer
 891: 5565+19	0454' DD7300  	                ld (ix + TM_SECS), e    ; Seconds [0,59]
 892:				; Check range
 893: 5584+10	0457' 013C00  	                ld bc, 60
 894: 5594+4	045A' EB      	                ex de, hl
 895: 5598+4	045B' A7      	                and a
 896: 5602+15	045C' ED42    	                sbc hl, bc
 897: 5617+10	045E' D23400  	                jp nc, cmd_op_error     ; Error if out of range
 898: 5627+4	0461' EB      	                ex de, hl
 899:				; This may be the end of the line, or a space before the date.
 900: 5631+7	0462' 7E      	                ld a, (hl)
 901: 5638+4	0463' A7      	                and a
 902: 5642+7+5	0464' 285F    	                jr z, cts_parse_done    ; Jump if end of line (time only)
 903: 5649+7	0466' FE20    	cts_chk_date    cp ' '
 904: 5656+10	0468' C23400  	                jp nz, cmd_op_error     ; Error if no separator
 905: 5666+6	046B' 23      	                inc hl
 906:				;
 907:				; Day
 908: 5672+17	046C' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
 909: 5689+10	046F' DA3400  	                jp c, cmd_op_error
 910:				; DE - number
 911:				; HL - command line pointer
 912: 5699+19	0472' DD7303  	                ld (ix + TM_MDAY), e    ; Day of month [1,31]
 913:				; Check range. This is crude in that it will accept 31 days in any month.
 914: 5718+6	0475' 1B      	                dec de                  ; Make range 0 to 30
 915: 5724+10	0476' 011F00  	                ld bc, 31
 916: 5734+4	0479' EB      	                ex de, hl
 917: 5738+4	047A' A7      	                and a
 918: 5742+15	047B' ED42    	                sbc hl, bc
 919: 5757+10	047D' D23400  	                jp nc, cmd_op_error     ; Error if out of range
 920: 5767+4	0480' EB      	                ex de, hl
 921:				; Separator
 922: 5771+7	0481' 3E2F    	                ld a, '/'
 923: 5778+7	0483' BE      	                cp (hl)
 924: 5785+10	0484' C23400  	                jp nz, cmd_op_error     ; Error if no separator
 925: 5795+6	0487' 23      	                inc hl
 926:				; Month
 927: 5801+17	0488' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
 928: 5818+10	048B' DA3400  	                jp c, cmd_op_error
 929:				; DE - number
 930:				; HL - command line pointer
 931: 5828+19	048E' DD7304  	                ld (ix + TM_MON), e     ; Month of year [1,12]
 932:				; Check range.
 933: 5847+6	0491' 1B      	                dec de                  ; Make range 0 to 11
 934: 5853+10	0492' 010C00  	                ld bc, 12
 935: 5863+4	0495' EB      	                ex de, hl
 936: 5867+4	0496' A7      	                and a
 937: 5871+15	0497' ED42    	                sbc hl, bc
 938: 5886+10	0499' D23400  	                jp nc, cmd_op_error     ; Error if out of range
 939: 5896+4	049C' EB      	                ex de, hl
 940:				; Separator
 941: 5900+7	049D' 3E2F    	                ld a, '/'
 942: 5907+7	049F' BE      	                cp (hl)
 943: 5914+10	04A0' C23400  	                jp nz, cmd_op_error     ; Error if no separator
 944: 5924+6	04A3' 23      	                inc hl
 945:				; Year
 946: 5930+17	04A4' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
 947: 5947+10	04A7' DA3400  	                jp c, cmd_op_error
 948:				; DE - number
 949:				; HL - command line pointer
 950:				; Check and adjust range [70,255]
 951: 5957+10	04AA' 016C07  	                ld bc, 1900
 952: 5967+4	04AD' EB      	                ex de, hl
 953: 5971+4	04AE' A7      	                and a
 954: 5975+15	04AF' ED42    	                sbc hl, bc
 955: 5990+10	04B1' DA3400  	                jp c, cmd_op_error      ; Error if out of range
 956: 6000+4	04B4' EB      	                ex de, hl
 957: 6004+19	04B5' DD7305  	                ld (ix + TM_YEAR), e    ; Years since 1900 [70,255]
 958: 6023+4	04B8' AF      	                xor a
 959: 6027+4	04B9' BA      	                cp d
 960: 6031+10	04BA' C23400  	                jp nz, cmd_op_error     ; Error if out of range
 961:				; There should be nothing after this but the terminator.
 962: 6041+17	04BD' CD0000  	                call skpspc             ; Skip spaces
 963: 6058+4	04C0' AF      	                xor a
 964: 6062+7	04C1' BE      	                cp (hl)
 965: 6069+10	04C2' C23400  	                jp nz, cmd_op_error
 966:				;
 967:				; The command line has been passed, and relevant values written to time_tm. As
 968:				; things have changed, the daylight savings status is set to unknown.
 969: 6079+19	04C5' DD360900	cts_parse_done  ld (ix + TM_DST), TMDST_UNKNOWN ; Set daylight savings to unknown
 970: 6098+17	04C9' CD0000  	                call tistoi    ; Convert TM structure time to integer
 971:				; DEHL - 32-bit time. This represents the time as entered, which may or may not
 972:				; be DST.
 973: 6115+11	04CC' E5      	                push hl                 ; Save integer time
 974: 6126+11	04CD' D5      	                push de
 975: 6137+17	04CE' CD0000  	                call tiitos    ; Convert integer time to TM structure
 976:				; DST status has now been calculated.
 977: 6154+19	04D1' DD7E09  	                ld a, (ix + TM_DST)
 978: 6173+7	04D4' FE02    	                cp TMDST_DST
 979: 6180+7+5	04D6' 2014    	                jr nz, cts_dst_done
 980:				; DST has been applied during the conversion. This means the resulting time is one
 981:				; hour ahead of that required, as integer time should never include DST.
 982: 6187+10	04D8' D1      	                pop de                  ; Restore time
 983: 6197+10	04D9' E1      	                pop hl
 984:				; Subtract an hour.
 985: 6207+10	04DA' 01100E  	                ld bc, 3600             ; One hour in seconds
 986: 6217+4	04DD' A7      	                and a
 987: 6221+15	04DE' ED42    	                sbc hl, bc              ; Subtract from LSW
 988: 6236+10	04E0' 010000  	                ld bc, 0
 989: 6246+4	04E3' EB      	                ex de, hl
 990: 6250+15	04E4' ED42    	                sbc hl, bc              ; Propagate carry to DE
 991: 6265+4	04E6' EB      	                ex de, hl
 992:				; Do the conversion again.
 993: 6269+11	04E7' E5      	                push hl                 ; Save integer time
 994: 6280+11	04E8' D5      	                push de
 995: 6291+17	04E9' CD0000  	                call tiitos             ; Convert integer time to TM structure
 996:				;
 997:				; DST correction applied if it was required.
 998: 6308+17	04EC' CD0000  	cts_dst_done    call cwptm              ; Print time structure to console
 999: 6325+17	04EF' CD0000  	                call cwnwln             ; New line
1000: 6342+10	04F2' D1      	                pop de                  ; Restore time
1001: 6352+10	04F3' E1      	                pop hl
1002:				;
1003: 6362+17	04F4' CD0000  	                call tiwr               ; Set time and date
1004: 6379+4	04F7' A7      	                and a
1005: 6383+5+6	04F8' C8      	                ret z                   ; Return if write was OK
1006:				; Something went wrong.
1007: 6388+10	04F9' C3EA03  	                jp ct_rtc_err
1008:				;
1009:				;
1010:				; Runs code very similar to the stage 1 serial bootloader (the one normally
1011:				; entered from the front panel). This allows the monitor to be downloaded again.
1012:				; This is a simple binary download, with all received characters being written to
1013:				; RAM starting at address zero. There is no form of checksum or other
1014:				; verification. Termination is by reset from the front panel. The only functional
1015:				; difference between this and the stage 1 bootloader is that this allows the use
1016:				; of either serial port.
1017:				; The next thing in the command buffer should be the terminator.
1018: 6398+4	04FC' AF      	cmd_mon_dl      xor a
1019: 6402+7	04FD' BE      	                cp (hl)
1020: 6409+10	04FE' C23400  	                jp nz, cmd_op_error
1021:				; No operands, as expected.
1022: 6419+17	0501' CDB307  	                call disp_bin_dl_msg    ; Display prompt
1023:				; The code is run from bank 1 as this code will be overwritten as part of the
1024:				; download process.
1025: 6436+10	0504' 213105  	                ld hl, mdl_code_start
1026: 6446+10	0507' 111602  	                ld de, mdl_code_run
1027: 6456+11	050A' D5      	                push de                 ; Save start address for later
1028: 6467+10	050B' 010700  	                ld bc, mdl_code_end - mdl_code_start
1029: 6477+16+5	050E' EDB0    	                ldir
1030:				; Set the I/O port address according to the current data transfer port.
1031: 6493+13	0510' 3A0000  	                ld a, (trport)
1032:				; The following code is also used by the transfer port redirection code.
1033: 6506+7	0513' 0E11    	                ld c, IOA_SER1_DATA
1034: 6513+7	0515' FE00    	                cp PORT_SER1            ; Serial port 1
1035: 6520+7+5	0517' 280E    	                jr z, mdl_have_addr
1036: 6527+7	0519' 0E13    	                ld c, IOA_SER2_DATA
1037: 6534+7	051B' FE01    	                cp PORT_SER2            ; Serial port 2
1038: 6541+7+5	051D' 2808    	                jr z, mdl_have_addr
1039:				; If not valid, complain.
1040: 6548+10	051F' E1      	                pop hl                  ; Discard address
1041: 6558+10	0520' 21FB0D  	                ld hl, bad_port_msg     ; "Invalid port"
1042: 6568+17	0523' CD0000  	                call conwms             ; Print message
1043: 6585+10	0526' C9      	                ret
1044:				;
1045:				; Interrupts are disabled as the handler will be overwritten.
1046:				; C - I/O port address of the transfer data port.
1047:				; (SP) - start address of relocated download code.
1048: 6595+4	0527' F3      	mdl_have_addr   di
1049:				; Set bank 0 (0x0000 to 0x3fff) writeable.
1050: 6599+7	0528' 3E7F    	                ld a, MMAP_MON_B0_PAGE + MMAP_SUPER_MASK
1051: 6606+11	052A' D304    	                out (IOA_MMAP_0), a
1052:				; We need to allow I/O access from bank 1 (0x4000 to 0x7fff) as we will be running
1053:				; from there.
1054: 6617+7	052C' 3E7E    	                ld a, MMAP_MON_B1_PAGE + MMAP_SUPER_MASK
1055: 6624+11	052E' D305    	                out (IOA_MMAP_1), a
1056: 6635+10	0530' C9      	                ret                     ; "Return" to the copied code
1057:				;
1058:				; The actual download code. ZMAC's "phase" doesn't seem to be able to cope with
1059:				; relocatable code, so this code must not be dependent on its load address.
1060: 6645+10	0531' 210000  	mdl_code_start  ld hl, 0                ; Start address 
1061: 6655+16	0534' EDA2    	mdl_loop        ini
1062: 6671+12	0536' 18FC    	                jr mdl_loop             ; Load data until reset
1063:     -	0538'         	mdl_code_end
1064:				;
1065:				;
1066:				; Binary download from a serial port. This is useful for downloading raw binary
1067:				; files to the address specified. This is similar to the monitor download, but
1068:				; it allows an arbitrary address as destination in user address space. It is up
1069:				; to the user to make sure that the destination is writeable.
1070:				; Command format: bindownload <addr>
1071: 6683+17	0538' CD0000  	cmd_bin_dl      call rdhxwd             ; Fetch address
1072: 6700+10	053B' DA3400  	                jp c, cmd_op_error      ; Address is required              
1073: 6710+17	053E' CD0000  	                call skpspc             ; Skip spaces
1074:				; The next thing in the command buffer should be the terminator.
1075: 6727+4	0541' AF      	                xor a
1076: 6731+7	0542' BE      	                cp (hl)
1077: 6738+10	0543' C23400  	                jp nz, cmd_op_error
1078: 6748+17	0546' CDB307  	                call disp_bin_dl_msg    ; Display prompt
1079: 6765+4	0549' EB      	                ex de, hl
1080:				; HL - specified address
1081:				; The following code is similar to that of the stage 1 serial
1082:				; bootloader, with all of the restrictions that implies. Termination is by
1083:				; reset from the front panel.
1084: 6769+17	054A' CD0000  	cbd_loop        call trarch             ; Fetch next character from user
1085: 6786+17	054D' CD0000  	                call wusby              ; Write byte to user space
1086: 6803+10	0550' DA3D00  	                jp c, mcprot
1087: 6813+6	0553' 23      	                inc hl
1088: 6819+12	0554' 18F4    	                jr cbd_loop             ; Load data until reset or NMI
1089:				;
1090:				;
1091:				; Much as the bindownload command above, but downloads to the CP/M Transient
1092:				; Programme Area (TPA). Pages are allocated if CP/M memory is not initialised.
1093:				; There are no operands, so the next thing in the command buffer should be the
1094:				; terminator.
1095: 6831+4	0556' AF      	cmd_tpa_dl      xor a
1096: 6835+7	0557' BE      	                cp (hl)
1097: 6842+10	0558' C23400  	                jp nz, cmd_op_error
1098:				; Make sure that the pages are allocated. These are listed in cppags, one page
1099:				; for each bank. This will do nothing if the CP/M system has been run before,
1100:				; as is likely when using this command.
1101: 6852+17	055B' CD0000  	                call cpmem              ; Allocate CP/M pages
1102: 6869+17	055E' CDB307  	                call disp_bin_dl_msg    ; Display prompt
1103: 6886+10	0561' 210001  	                ld hl, TPA_START        ; Set starting address.
1104:				; The following code is similar to that of the stage 1 serial bootloader, with
1105:				; all of the restrictions that implies. Termination is by reset from the front
1106:				; panel.
1107:				; Map the appropriate page to bank 3 so we can access it.
1108: 6896+11	0564' E5      	tbd_loop        push hl                 ; Save address
1109: 6907+4	0565' 7C      	                ld a, h
1110: 6911+4	0566' 07      	                rlca
1111: 6915+4	0567' 07      	                rlca
1112:				; Address bits 15 and 14 are now in 1 and 0, so we have the required bank number.
1113: 6919+7	0568' E603    	                and 0x03                ; Ensure all other bits are reset
1114:				; Loop up the associated page number for this bank.
1115: 6926+10	056A' 210000  	                ld hl, cppags           ; Pointer to memory page numbers
1116: 6936+7	056D' 1600    	                ld d, 0
1117: 6943+4	056F' 5F      	                ld e, a
1118: 6947+11	0570' 19      	                add hl, de
1119: 6958+7	0571' 7E      	                ld a, (hl)
1120: 6965+11	0572' D307    	                out (IOA_MMAP_3), a     ; Map bank 3 to this page
1121: 6976+10	0574' E1      	                pop hl                  ; Fetch full (virtual) address
1122:				;
1123: 6986+11	0575' E5      	                push hl
1124: 6997+4	0576' 7C      	                ld a, h
1125: 7001+7	0577' E63F    	                and high (MMAP_PAGE_SIZE - 1)   ; Maintain only bits within bank
1126: 7008+7	0579' C6C0    	                add high MMAP_BANK3_START       ; Add base of bank 3
1127: 7015+4	057B' 67      	                ld h, a
1128:				; HL - address in bank 3
1129: 7019+17	057C' CD0000  	                call trarch             ; Fetch next character
1130: 7036+7	057F' 77      	                ld (hl), a
1131: 7043+10	0580' E1      	                pop hl                  ; Restore full address
1132: 7053+6	0581' 23      	                inc hl
1133: 7059+12	0582' 18E0    	                jr tbd_loop             ; Load data until reset or NMI
1134:				;
1135:				;
1136:				; Read sectors from memory card.
1137:				; readsec <start sec> <no. of 512-byte sectors> <address>
1138: 7071+17	0584' CD0000  	cmd_readsec     call rddulo             ; Read a 32-bit decimal number
1139: 7088+10	0587' DA3400  	                jp c, cmd_op_error      ; Start sector is required
1140:				; BCDE - start sector
1141:				; HL - address in command buffer
1142: 7098+4	058A' 78      	                ld a, b
1143: 7102+4	058B' A7      	                and a
1144: 7106+10	058C' C23400  	                jp nz, cmd_op_error     ; MS byte should be zero
1145:				; CDE - start sector
1146:				; HL - address in command buffer
1147: 7116+11	058F' D5      	                push de
1148: 7127+17	0590' CD0000  	                call skpspc             ; Skip spaces
1149: 7144+17	0593' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
1150: 7161+10	0596' DA3400  	                jp c, cmd_op_error      ; No. of sectors is required
1151:				; Note - cmd_op_error path will reset stack, so no need to tidy up here.
1152: 7171+4	0599' 7A      	                ld a, d
1153: 7175+4	059A' A7      	                and a
1154: 7179+10	059B' C23400  	                jp nz, cmd_op_error     ; MS byte should be zero
1155: 7189+4	059E' 7B      	                ld a, e
1156: 7193+4	059F' A7      	                and a
1157: 7197+10	05A0' CA3400  	                jp z, cmd_op_error      ; Zero length is not allowed either
1158: 7207+4	05A3' 43      	                ld b, e
1159:				; B - no. of 512-byte sectors
1160:				; C - start sector (MS byte)
1161:				; HL - address in command buffer
1162: 7211+17	05A4' CD0000  	                call skpspc             ; Skip spaces
1163: 7228+17	05A7' CD0000  	                call rdhxwd             ; Fetch address
1164: 7245+10	05AA' DA3400  	                jp c, cmd_op_error      ; Address is required
1165:				; DE - destination address
1166: 7255+17	05AD' CD0000  	                call skpspc             ; Skip spaces
1167:				; The next thing in the command buffer should be the terminator.
1168: 7272+4	05B0' AF      	                xor a
1169: 7276+7	05B1' BE      	                cp (hl)
1170: 7283+10	05B2' C23400  	                jp nz, cmd_op_error
1171: 7293+4	05B5' EB      	                ex de, hl
1172: 7297+10	05B6' D1      	                pop de                  ; Restore LSW of start sector
1173:				;
1174:				; B - no. of 512-byte sectors
1175:				; CDE - start sector (MS byte)
1176:				; HL - destination address
1177: 7307+11	05B7' E5      	crs_loop        push hl                 ; Save destination address
1178: 7318+11	05B8' C5      	                push bc                 ; Save sector number and counter
1179: 7329+11	05B9' D5      	                push de
1180: 7340+10	05BA' 21CF09  	                ld hl, crs_sec_msg      ; "Reading sector: "
1181: 7350+17	05BD' CD0000  	                call conwms             ; Print message
1182:				; Move CDE to DEHL
1183: 7367+4	05C0' EB      	                ex de, hl
1184: 7371+7	05C1' 1600    	                ld d, 0
1185: 7378+4	05C3' 59      	                ld e, c
1186: 7382+17	05C4' CD0000  	                call cwpdlo             ; Print DEHL in decimal
1187: 7399+17	05C7' CD0000  	                call cwnwln             ; Write new line characters to console
1188:				; Restore sector number.
1189: 7416+10	05CA' D1      	                pop de
1190: 7426+10	05CB' C1      	                pop bc
1191:				; Keep a copy on the stack.
1192: 7436+11	05CC' C5      	                push bc
1193: 7447+11	05CD' D5      	                push de
1194:				; Load data into the buffer.
1195: 7458+10	05CE' 211600  	                ld hl, sector_buff
1196: 7468+17	05D1' CD0000  	                call cars               ; Read the sector (use cache)
1197: 7485+10	05D4' D1      	                pop de
1198: 7495+10	05D5' C1      	                pop bc
1199: 7505+4	05D6' A7      	                and a
1200: 7509+7+5	05D7' 2028    	                jr nz, crs_error
1201: 7516+10	05D9' E1      	                pop hl                  ; Restore destination address
1202:				;
1203: 7526+11	05DA' C5      	                push bc                 ; Save sector number and counter
1204: 7537+11	05DB' D5      	                push de
1205:				; Copy the sector data into user space.
1206: 7548+10	05DC' 111600  	                ld de, sector_buff
1207: 7558+10	05DF' 010002  	                ld bc, MMC_SECTOR_SIZE
1208: 7568+7	05E2' 1A      	crs_copy_loop   ld a, (de)
1209: 7575+17	05E3' CD0000  	                call wusby              ; Write byte to user space
1210: 7592+10	05E6' DA3D00  	                jp c, mcprot
1211: 7602+6	05E9' 13      	                inc de
1212: 7608+6	05EA' 23      	                inc hl
1213: 7614+6	05EB' 0B      	                dec bc
1214: 7620+4	05EC' 78      	                ld a, b
1215: 7624+4	05ED' B1      	                or c
1216: 7628+7+5	05EE' 20F2    	                jr nz, crs_copy_loop
1217: 7635+10	05F0' D1      	                pop de
1218: 7645+10	05F1' C1      	                pop bc
1219:				;
1220:				; Increment sector number (CDE).
1221: 7655+7	05F2' 3E01    	                ld a, 1
1222: 7662+4	05F4' 83      	                add e
1223: 7666+4	05F5' 5F      	                ld e, a
1224: 7670+7	05F6' 3E00    	                ld a, 0
1225: 7677+4	05F8' 8A      	                adc d
1226: 7681+4	05F9' 57      	                ld d, a
1227: 7685+7	05FA' 3E00    	                ld a, 0
1228: 7692+4	05FC' 89      	                adc c
1229: 7696+4	05FD' 4F      	                ld c, a
1230:				; Overflows are unlikely due to range checks in mcrrs.
1231: 7700+8+5	05FE' 10B7    	                djnz crs_loop
1232: 7708+10	0600' C9      	                ret
1233:				;
1234:				; Print memory card error text, or nothing if no error (A = 0)
1235: 7718+17	0601' CD0000  	crs_error       call mcprer
1236: 7735+10	0604' C32800  	                jp cmd_done
1237:				;
1238:				;
1239:				; Write sectors to memory card.
1240:				; writesec <start sec> <no. of 512-byte sectors> <address>
1241: 7745+17	0607' CD0000  	cmd_writesec    call rddulo             ; Read a 32-bit decimal number
1242: 7762+10	060A' DA3400  	                jp c, cmd_op_error      ; Start sector is required
1243:				; BCDE - start sector
1244:				; HL - address in command buffer
1245: 7772+4	060D' 78      	                ld a, b
1246: 7776+4	060E' A7      	                and a
1247: 7780+10	060F' C23400  	                jp nz, cmd_op_error     ; MS byte should be zero
1248:				; CDE - start sector
1249:				; HL - address in command buffer
1250: 7790+11	0612' D5      	                push de
1251: 7801+17	0613' CD0000  	                call skpspc             ; Skip spaces
1252: 7818+17	0616' CD0000  	                call rdduwd             ; Read a 16-bit unsigned decimal
1253: 7835+10	0619' DA3400  	                jp c, cmd_op_error      ; No. of sectors is required
1254:				; Note - cmd_op_error path will reset stack, so no need to tidy up here.
1255: 7845+4	061C' 7A      	                ld a, d
1256: 7849+4	061D' A7      	                and a
1257: 7853+10	061E' C23400  	                jp nz, cmd_op_error     ; MS byte should be zero
1258: 7863+4	0621' 7B      	                ld a, e
1259: 7867+4	0622' A7      	                and a
1260: 7871+10	0623' CA3400  	                jp z, cmd_op_error      ; Zero length is not allowed either
1261: 7881+4	0626' 43      	                ld b, e
1262:				; B - no. of 512-byte sectors
1263:				; C - start sector (MS byte)
1264:				; HL - address in command buffer
1265: 7885+17	0627' CD0000  	                call skpspc             ; Skip spaces
1266: 7902+17	062A' CD0000  	                call rdhxwd             ; Fetch length
1267: 7919+10	062D' DA3400  	                jp c, cmd_op_error      ; Address is required
1268:				; DE - destination address
1269: 7929+17	0630' CD0000  	                call skpspc             ; Skip spaces
1270:				; The next thing in the command buffer should be the terminator.
1271: 7946+4	0633' AF      	                xor a
1272: 7950+7	0634' BE      	                cp (hl)
1273: 7957+10	0635' C23400  	                jp nz, cmd_op_error
1274: 7967+4	0638' EB      	                ex de, hl
1275: 7971+10	0639' D1      	                pop de                  ; Restore LSW of start sector
1276:				;
1277:				; B - no. of 512-byte sectors
1278:				; CDE - start sector (MS byte)
1279:				; HL - source address
1280: 7981+11	063A' C5      	cws_loop        push bc                 ; Save sector number and counter
1281: 7992+11	063B' D5      	                push de
1282:				;
1283: 8003+11	063C' E5      	                push hl                 ; Save source address
1284: 8014+10	063D' 21E009  	                ld hl, cws_sec_msg      ; "Writing sector: "
1285: 8024+17	0640' CD0000  	                call conwms       ; Print message
1286:				; Move CDE to DEHL
1287: 8041+4	0643' EB      	                ex de, hl
1288: 8045+7	0644' 1600    	                ld d, 0
1289: 8052+4	0646' 59      	                ld e, c
1290: 8056+17	0647' CD0000  	                call cwpdlo             ; Print DEHL in decimal
1291: 8073+17	064A' CD0000  	                call cwnwln             ; Write new line characters to console
1292:				; Restore sector number.
1293: 8090+10	064D' E1      	                pop hl                  ; Restore source address
1294:				;
1295:				; Copy the sector data from user space.
1296: 8100+10	064E' 111600  	                ld de, sector_buff
1297: 8110+10	0651' 010002  	                ld bc, MMC_SECTOR_SIZE
1298: 8120+17	0654' CD0000  	cws_copy_loop   call rusby              ; Read byte from user space
1299: 8137+7	0657' 12      	                ld (de), a
1300: 8144+6	0658' 13      	                inc de
1301: 8150+6	0659' 23      	                inc hl
1302: 8156+6	065A' 0B      	                dec bc
1303: 8162+4	065B' 78      	                ld a, b
1304: 8166+4	065C' B1      	                or c
1305: 8170+7+5	065D' 20F5    	                jr nz, cws_copy_loop
1306:				;
1307: 8177+10	065F' D1      	                pop de
1308: 8187+10	0660' C1      	                pop bc
1309:				;
1310:				; No registers are on the stack at this point.
1311: 8197+11	0661' E5      	                push hl                 ; Save source address
1312: 8208+11	0662' C5      	                push bc
1313: 8219+11	0663' D5      	                push de
1314: 8230+10	0664' 211600  	                ld hl, sector_buff
1315: 8240+17	0667' CD0000  	                call caws               ; Write sector buffer to memory card
1316: 8257+10	066A' D1      	                pop de
1317: 8267+10	066B' C1      	                pop bc
1318: 8277+10	066C' E1      	                pop hl
1319: 8287+4	066D' A7      	                and a
1320: 8291+7+5	066E' 200F    	                jr nz, cws_error
1321:				;
1322:				; Increment sector number (CDE).
1323: 8298+7	0670' 3E01    	                ld a, 1
1324: 8305+4	0672' 83      	                add e
1325: 8309+4	0673' 5F      	                ld e, a
1326: 8313+7	0674' 3E00    	                ld a, 0
1327: 8320+4	0676' 8A      	                adc d
1328: 8324+4	0677' 57      	                ld d, a
1329: 8328+7	0678' 3E00    	                ld a, 0
1330: 8335+4	067A' 89      	                adc c
1331: 8339+4	067B' 4F      	                ld c, a
1332:				; Overflows are unlikely due to range checks in sector write code.
1333: 8343+8+5	067C' 10BC    	                djnz cws_loop
1334: 8351+10	067E' C9      	                ret
1335:				;
1336:				; Print memory card error text, or nothing if no error (A = 0)
1337: 8361+17	067F' CD0000  	cws_error       call mcprer
1338: 8378+10	0682' C9      	                ret
1339:				;
1340:				;
1341:				; Load and start CP/M. Command syntax: cpm [""debug""] [""noints""]
1342:				; debug - enables BIOS debugging messages.
1343:				; noints - disables interrupts (use basic I/O mode).
1344:				; rawcon - disables console escape code translation.
1345: 8388+7	0683' 1E00    	cmd_cpm         ld e, 0                 ; Set initial options
1346:				; Loop, reading operands and collating the options. Repeating options
1347:				; are permitted (though not useful).
1348: 8395+17	0685' CD0000  	ccpm_op_loop    call skpspc             ; Skip spaces
1349: 8412+4	0688' AF      	                xor a
1350: 8416+7	0689' BE      	                cp (hl)
1351: 8423+7+5	068A' 2818    	                jr z, ccpm_ops_done     ; Jump if no more operands
1352:				; Match next operand against list of options.
1353: 8430+11	068C' D5      	                push de                 ; Save options
1354: 8441+10	068D' 11330D  	                ld de, ccpm_op_list
1355: 8451+7	0690' 3E03    	                ld a, MTWDLI_ABBREV_MASK | MTWDLI_ICASE_MASK
1356: 8458+17	0692' CD0000  	                call mtwdli             ; Match against list of options
1357: 8475+10	0695' D1      	                pop de
1358: 8485+4	0696' A7      	                and a
1359: 8489+10	0697' CA3400  	                jp z, cmd_op_error
1360:				; 1 = debug, 2 = noints, 3 = rawcon. Message order must match BIOS_OPT_xxx
1361:				; definitions in cpm.i.
1362:				; Convert message number to bit.
1363: 8499+4	069A' 47      	                ld b, a
1364: 8503+7	069B' 3E80    	                ld a, 0x80
1365: 8510+4	069D' 07      	ccpm_find_mask  rlca
1366: 8514+8+5	069E' 10FD    	                djnz ccpm_find_mask
1367: 8522+4	06A0' B3      	                or e                    ; Combine with previous options
1368: 8526+4	06A1' 5F      	                ld e, a
1369: 8530+12	06A2' 18E1    	                jr ccpm_op_loop
1370:				; All options have been read.
1371:				; E - options. See BIOS_OPT_xxx definitions.
1372: 8542+4	06A4' 7B      	ccpm_ops_done   ld a, e
1373: 8546+10	06A5' C30000  	                jp cpinit               ; Load with options in A.
1374:				;
1375:				;
1376:				; Set console port. Command format:
1377:				; cport <port>
1378: 8556+10	06A8' 117F0E  	cmd_cport       ld de, prt_name_list
1379: 8566+7	06AB' 3E03    	                ld a, MTWDLI_ABBREV_MASK | MTWDLI_ICASE_MASK
1380: 8573+17	06AD' CD0000  	                call mtwdli             ; Match against list of options
1381: 8590+4	06B0' A7      	                and a
1382: 8594+10	06B1' CA3400  	                jp z, cmd_op_error      ; Error if not one of the options
1383: 8604+4	06B4' 3D      	                dec a                   ; Make port zero based to match enum
1384:				; A - port number (PRN_xxx).
1385: 8608+11	06B5' F5      	                push af
1386: 8619+4	06B6' AF      	                xor a
1387: 8623+7	06B7' BE      	                cp (hl)
1388: 8630+10	06B8' C23400  	                jp nz, cmd_op_error     ; Error if there is more text
1389: 8640+10	06BB' F1      	                pop af
1390: 8650+13	06BC' 320000  	                ld (coport), a
1391: 8663+10	06BF' C9      	                ret
1392:				;
1393:				;
1394:				; Set data transfer port. Command format:
1395:				; tport <port>
1396: 8673+10	06C0' 117F0E  	cmd_tport       ld de, prt_name_list
1397: 8683+7	06C3' 3E03    	                ld a, MTWDLI_ABBREV_MASK | MTWDLI_ICASE_MASK
1398: 8690+17	06C5' CD0000  	                call mtwdli             ; Match against list of options
1399: 8707+4	06C8' A7      	                and a
1400: 8711+10	06C9' CA3400  	                jp z, cmd_op_error      ; Error if not one of the options
1401: 8721+4	06CC' 3D      	                dec a                   ; Make port zero based to match enum
1402:				; A - port number (PRN_xxx).
1403: 8725+11	06CD' F5      	                push af
1404: 8736+4	06CE' AF      	                xor a
1405: 8740+7	06CF' BE      	                cp (hl)
1406: 8747+10	06D0' C23400  	                jp nz, cmd_op_error     ; Error if there is more text
1407: 8757+10	06D3' F1      	                pop af
1408: 8767+13	06D4' 320000  	                ld (trport), a
1409: 8780+10	06D7' C9      	                ret
1410:				;
1411:				;
1412:				; Call user code, using the current PC or a specified address.
1413:				; Command format:
1414:				; go [<addr>]
1415: 8790+17	06D8' CD0000  	cmd_go          call rdhxwd             ; Fetch address
1416: 8807+11	06DB' F5      	                push af                 ; Save carry flag
1417: 8818+17	06DC' CD0000  	                call skpspc             ; Skip spaces
1418:				; The next thing in the command buffer should be the terminator.
1419: 8835+4	06DF' AF      	                xor a
1420: 8839+7	06E0' BE      	                cp (hl)
1421: 8846+10	06E1' C23400  	                jp nz, cmd_op_error
1422: 8856+10	06E4' F1      	                pop af
1423: 8866+7+5	06E5' 3806    	                jr c, cg_no_new_addr
1424:				; DE - new address
1425: 8873+19	06E7' DD7308  	                ld (ix + MST_PC), e
1426: 8892+19	06EA' DD7209  	                ld (ix + MST_PC + 1), d
1427:				;
1428:				; Some checks are made to warn the user if the interrupt configuration looks risky.
1429:				; This may help to avoid hard-to-debug crashes.
1430:				; Read saved interrupt enable state in advance.
1431:				; There may be a problem if the stored context has the interrupts enabled.
1432: 8911+19	06ED' DD7E00  	cg_no_new_addr  ld a, (ix + MST_IEN)    ; Non-zero if interrupts enabled
1433: 8930+4	06F0' A7      	                and a
1434: 8934+7+5	06F1' 281A    	                jr z, cg_ints_ok
1435:				;
1436:				; Warn "Interrupt configuration warning. "
1437: 8941+10	06F3' 21AD09  	                ld hl, int_cfg_msg
1438: 8951+17	06F6' CD0000  	                call conwms       ; Print message
1439:				;
1440:				; Ask for confirmation before continuing.
1441: 8968+10	06F9' 219C09  	                ld hl, cmd_conf_msg
1442: 8978+17	06FC' CD0000  	                call conwms             ; Print "Continue" message
1443: 8995+17	06FF' CD0000  	                call conrch             ; Fetch next character from user
1444: 9012+11	0702' F5      	                push af
1445: 9023+17	0703' CD0000  	                call conwch             ; Echo the response
1446: 9040+17	0706' CD0000  	                call cwnwln             ; Write new line characters to console
1447: 9057+10	0709' F1      	                pop af
1448: 9067+7	070A' FE79    	                cp 'y'
1449: 9074+5+6	070C' C0      	                ret nz                  ; Exit unless confirmed
1450:				;
1451:				; Run the user code.
1452: 9079+7	070D' 3E00    	cg_ints_ok      ld a, TRM_NONE          ; Flag normal run (not trace)
1453: 9086+10	070F' C30000  	                jp mcrun                ; Switch to user context
1454:				;
1455:				;
1456:				; Call user code for one instruction (single step). If an address is specified, the
1457:				; trace is repeated until that address is reached. Command format:
1458:				; trace [<addr>]
1459:				; t [<addr>]
1460: 9096+17	0712' CD0000  	cmd_trace       call rdhxwd             ; Fetch address
1461: 9113+11	0715' F5      	                push af                 ; Save carry flag
1462: 9124+17	0716' CD0000  	                call skpspc             ; Skip spaces
1463:				; The next thing in the command buffer should be the terminator.
1464: 9141+4	0719' AF      	                xor a
1465: 9145+7	071A' BE      	                cp (hl)
1466: 9152+10	071B' C23400  	                jp nz, cmd_op_error
1467: 9162+10	071E' F1      	                pop af
1468: 9172+7	071F' 3E01    	                ld a, TRM_SINGLE        ; Flag single trace required
1469: 9179+7+5	0721' 3802    	                jr c, ct_run
1470:				; DE - new address
1471: 9186+7	0723' 3E02    	                ld a, TRM_TO_ADDR       ; Flag trace to address required
1472: 9193+10	0725' C30000  	ct_run          jp mcrun                ; Switch to user context
1473:				;
1474:				;
1475:				; As trace, but if the current instruction is a CALL or RST, tracing continues
1476:				; until the call is complete. Command format:
1477:				; traceover
1478:				; o
1479:				; The next thing in the command buffer should be the terminator.
1480: 9203+4	0728' AF      	cmd_traceover   xor a
1481: 9207+7	0729' BE      	                cp (hl)
1482: 9214+10	072A' C23400  	                jp nz, cmd_op_error
1483:				; What we do next depends on the instruction.
1484: 9224+16	072D' 2A0800  	                ld hl, (mstate + MST_PC)
1485: 9240+17	0730' CD0000  	                call rusby              ; Read byte from user space
1486: 9257+4	0733' 4F      	                ld c, a                 ; Save it for later
1487: 9261+7	0734' FECD    	                cp call
1488: 9268+7+5	0736' 2812    	                jr z, cto_call          ; Jump if straightforward CALL
1489: 9275+7	0738' E6C7    	                and 11000111b
1490: 9282+7	073A' FEC4    	                cp 11000100b
1491: 9289+7+5	073C' 280C    	                jr z, cto_call          ; Jump if conditional CALL
1492: 9296+4	073E' 79      	                ld a, c
1493: 9300+7	073F' E6C7    	                and 11000111b
1494: 9307+7	0741' FEC7    	                cp 11000111b            ; RST p
1495: 9314+7+5	0743' 2807    	                jr z, cto_rst
1496:				; Not a CALL or RST, so trace the instruction and stop.
1497: 9321+7	0745' 3E01    	                ld a, TRM_SINGLE        ; Flag single trace required
1498: 9328+10	0747' C30000  	                jp mcrun                ; Switch to user context
1499:				;
1500: 9338+6	074A' 23      	cto_call        inc hl                  ; CALL or conditional CALL entry point
1501: 9344+6	074B' 23      	                inc hl
1502: 9350+6	074C' 23      	cto_rst         inc hl                  ; Other RST entry point
1503: 9356+4	074D' EB      	                ex de, hl
1504:				; DE - points to instruction after the call.
1505: 9360+7	074E' 3E02    	                ld a, TRM_TO_ADDR       ; Flag trace to address required
1506: 9367+10	0750' C30000  	                jp mcrun                ; Switch to user context
1507:				;
1508:				;
1509:				; Set register to supplied value. Command format:
1510:				; set <reg> <value>
1511:				; "ien" and "mmap" aren't actually registers, but are used here to control the
1512:				; interrupt enable and memory mapping respectively.
1513:				; Match operand against list of options.
1514: 9377+10	0753' 110B0E  	cmd_set         ld de, reg_names
1515: 9387+7	0756' 3E03    	                ld a, MTWDLI_ABBREV_MASK | MTWDLI_ICASE_MASK
1516: 9394+17	0758' CD0000  	                call mtwdli             ; Match against list of options
1517: 9411+4	075B' A7      	                and a
1518: 9415+10	075C' CA3400  	                jp z, cmd_op_error      ; Jump if unknown register
1519: 9425+4	075F' 3D      	                dec a                   ; Start index from zero
1520: 9429+4	0760' 4F      	                ld c, a                 ; Save index
1521:				; Read value
1522: 9433+17	0761' CD0000  	                call skpspc             ; Skip spaces
1523: 9450+17	0764' CD0000  	                call rdhxwd             ; Fetch value
1524: 9467+11	0767' F5      	                push af                 ; Save carry flag
1525: 9478+17	0768' CD0000  	                call skpspc             ; Skip spaces
1526:				; The next thing in the command buffer should be the terminator.
1527: 9495+4	076B' AF      	                xor a
1528: 9499+7	076C' BE      	                cp (hl)
1529: 9506+10	076D' C23400  	                jp nz, cmd_op_error
1530: 9516+10	0770' F1      	                pop af
1531: 9526+10	0771' DA3400  	                jp c, cmd_op_error
1532:				; C - register name index
1533:				; DE - value
1534: 9536+4	0774' 79      	                ld a, c
1535:				; Some registers require special processing.
1536: 9540+7	0775' FE12    	                cp 18
1537: 9547+7+5	0777' 200F    	                jr nz, cs_not_ien
1538:				; Set interrupt enable. Only 0 and 1 is valid in this case.
1539: 9554+4	0779' 7A      	                ld a, d
1540: 9558+4	077A' A7      	                and a
1541: 9562+10	077B' C23400  	                jp nz, cmd_op_error     ; Error if value was too big
1542: 9572+4	077E' 7B      	                ld a, e
1543: 9576+7	077F' FE02    	                cp 2
1544: 9583+10	0781' D23400  	                jp nc, cmd_op_error     ; Error if value was too big
1545: 9593+19	0784' DD7700  	                ld (ix + MST_IEN), a
1546: 9612+10	0787' C9      	                ret
1547:				; For all other registers, index a table to find the offsets and length.
1548: 9622+10	0788' 21610E  	cs_not_ien      ld hl, reg_offsets
1549: 9632+7	078B' 0600    	                ld b, 0
1550: 9639+11	078D' 09      	                add hl, bc
1551: 9650+7	078E' 7E      	                ld a, (hl)
1552: 9657+11	078F' F5      	                push af
1553:				; Find the address for the register.
1554: 9668+7	0790' E67F    	                and 0x7f                ; Remove 16-bit flag
1555: 9675+15	0792' DDE5    	                push ix                 ; Point to machine state
1556: 9690+10	0794' E1      	                pop hl
1557: 9700+4	0795' 85      	                add a, l
1558: 9704+4	0796' 6F      	                ld l, a
1559: 9708+4	0797' 7C      	                ld a, h
1560: 9712+7	0798' CE00    	                adc 0
1561: 9719+4	079A' 67      	                ld h, a
1562: 9723+10	079B' F1      	                pop af
1563:				; A (bit 7) - 16-bit value flag
1564:				; C - register name index
1565:				; DE - value
1566:				; HL - pointer to register in exception stack
1567: 9733+7	079C' E680    	                and 0x80
1568: 9740+7+5	079E' 2007    	                jr nz, cs_16bit
1569: 9747+4	07A0' 7A      	                ld a, d
1570: 9751+4	07A1' A7      	                and a
1571: 9755+10	07A2' C23400  	                jp nz, cmd_op_error     ; Error if value was too big
1572: 9765+7	07A5' 73      	                ld (hl), e
1573: 9772+10	07A6' C9      	                ret                     ; Command complete
1574:				; 16-bit register set.
1575: 9782+7	07A7' 73      	cs_16bit        ld (hl), e
1576: 9789+6	07A8' 23      	                inc hl
1577: 9795+7	07A9' 72      	                ld (hl), d
1578: 9802+10	07AA' C9      	                ret                     ; Command complete
1579:				;
1580:				;
1581:				; Display saved registers (user context)
1582:				; The next thing in the command buffer should be the terminator.
1583: 9812+4	07AB' AF      	cmd_registers   xor a
1584: 9816+7	07AC' BE      	                cp (hl)
1585: 9823+10	07AD' C23400  	                jp nz, cmd_op_error
1586:				; No operands, as expected.
1587: 9833+10	07B0' C30000  	                jp mdisrg               ; Display registers and return
1588:				;
1589:				;
1590:				; Display a prompt describing the binary download and which port is selected.
1591:				; This avoids confusion caused by the selected port not be as expected.
1592: 9843+11	07B3' E5      	disp_bin_dl_msg push hl
1593:				;
1594: 9854+10	07B4' 21C30D  	                ld hl, bin_dl_pre_msg   ; "Send binary data on port "
1595: 9864+17	07B7' CD0000  	                call conwms             ; Print message
1596:				; Display current data transfer port
1597: 9881+10	07BA' 217F0E  	                ld hl, prt_name_list    ; Port name list
1598: 9891+7	07BD' 0E20    	                ld c, ' '               ; Separator
1599: 9898+13	07BF' 3A0000  	                ld a, (trport)
1600: 9911+17	07C2' CD0000  	                call conwmn             ; Print message <n> in a list
1601:				;
1602: 9928+10	07C5' 21DD0D  	                ld hl, bin_dl_post_msg  ; ". Press RESET to terminate."
1603: 9938+17	07C8' CD0000  	                call conwms             ; Print message
1604:				;
1605: 9955+10	07CB' E1      	                pop hl
1606: 9965+10	07CC' C9      	                ret
1607:				;
1608:				;
1609:				;
1610:				; *************
1611:				; * Constants *
1612:				; *************
1613:				;
1614:				
1615:     -	07CD' 5F5F5F5F	zarc_msg        byte "____  __  ___   ___", 0x0d, 0x0a
	              20205F5F
	              20205F5F
	              5F202020
	              5F5F5F0D
	              0A
1616:     -	07E2' 2020202F	                byte "   / /  \ |  \ /", 0x0d, 0x0a
	              202F2020
	              5C207C20
	              205C202F
	              0D0A
1617:     -	07F4' 20202F20	                byte "  /  |__| |__/ |", 0x0d, 0x0a
	              207C5F5F
	              7C207C5F
	              5F2F207C
	              0D0A
1618:     -	0806' 202F2020	                byte " /   |  | |  \ |", 0x0d, 0x0a
	              207C2020
	              7C207C20
	              205C207C
	              0D0A
1619:     -	0818' 2F5F5F5F	                byte "/___ |  | |  | \___", 0x0d, 0x0a, 0x0d, 0x0a, 0
	              207C2020
	              7C207C20
	              207C205C
	              5F5F5F0D
	              0A0D0A00
1620:     -	0830' 5A415243	signon_msg      byte "ZARC Monitor V1.0", 0x0d, 0x0a, 0
	              204D6F6E
	              69746F72
	              2056312E
	              300D0A00
1621:     -	0844' 0D0A2A2A	cold_start_msg  byte 0x0d, 0x0a, "*** Cold start ***", 0
	              2A20436F
	              6C642073
	              74617274
	              202A2A2A
	              00
1622:     -	0859' 3E2000  	cmd_prompt      byte "> ", 0
1623:				; The ordered list of commands in cmd_list corresponds to the list of vectors
1624:				; in cmd_vectors.
1625:     -	085C' 68656C70	cmd_list        byte "help dump read write "
	              2064756D
	              70207265
	              61642077
	              72697465
	              20
1626:     -	0871' 696E206F	                byte "in out map info "
	              7574206D
	              61702069
	              6E666F20
1627:     -	0881' 6D656D74	                byte "memtest mondownload bindownload tpadownload "
	              65737420
	              6D6F6E64
	              6F776E6C
	              6F616420
	              62696E64
	              6F776E6C
	              6F616420
	              74706164
	              6F776E6C
	              6F616420
1628:     -	08AD' 74696D65	                byte "time go trace t "
	              20676F20
	              74726163
	              65207420
1629:     -	08BD' 74726163	                byte "traceover o set registers "
	              656F7665
	              72206F20
	              73657420
	              72656769
	              73746572
	              7320
1630:     -	08D7' 64697361	                byte "disassemble readsec writesec cpm "
	              7373656D
	              626C6520
	              72656164
	              73656320
	              77726974
	              65736563
	              2063706D
	              20
1631:     -	08F8' 66696C6C	                byte "fill cport tport cache "
	              2063706F
	              72742074
	              706F7274
	              20636163
	              686520
1632:     -	090F' 70616765	                byte "pages cold", 0
	              7320636F
	              6C6400
1633:     -	091A' 4E005500	cmd_vectors     word cmd_help, cmd_dump, cmd_read, cmd_write
	              EF017C01
1634:     -	0922' 07022302	                word cmd_in, cmd_out, cmd_map, cmd_info
	              5F024D03
1635:     -	092A' BF03FC04	                word cmd_memtest, cmd_mon_dl, cmd_bin_dl, cmd_tpa_dl
	              38055605
1636:     -	0932' DF03D806	                word cmd_time, cmd_go, cmd_trace, cmd_trace
	              12071207
1637:     -	093A' 28072807	                word cmd_traceover, cmd_traceover, cmd_set, cmd_registers
	              5307AB07
1638:     -	0942' 3A018405	                word cmd_disassemble, cmd_readsec, cmd_writesec, cmd_cpm
	              07068306
1639:     -	094A' B801A806	                word cmd_fill, cmd_cport, cmd_tport, cmd_cache
	              C006B703
1640:     -	0952' 40034803	                word cmd_pages, cmd_cold
1641:     -	0956' 42616420	cmd_bad_msg     byte "Bad command", 0x0d, 0x0a, 0
	              636F6D6D
	              616E640D
	              0A00
1642:     -	0964' 4F706572	op_err_msg      byte "Operand error", 0x0d, 0x0a, 0
	              616E6420
	              6572726F
	              720D0A00
1643:     -	0974' 0D0A5772	wr_prot_msg     byte 0x0d, 0x0a, "Write protection violation, address: ", 0
	              69746520
	              70726F74
	              65637469
	              6F6E2076
	              696F6C61
	              74696F6E
	              2C206164
	              64726573
	              733A2000
1644:     -	099C' 436F6E74	cmd_conf_msg    byte "Continue (y/n): ", 0
	              696E7565
	              2028792F
	              6E293A20
	              00
1645:     -	09AD' 496E7465	int_cfg_msg     byte "Interrupt configuration warning. ", 0
	              72727570
	              7420636F
	              6E666967
	              75726174
	              696F6E20
	              7761726E
	              696E672E
	              2000
1646:     -	09CF' 52656164	crs_sec_msg     byte "Reading sector: ", 0
	              696E6720
	              73656374
	              6F723A20
	              00
1647:     -	09E0' 57726974	cws_sec_msg     byte "Writing sector: ", 0
	              696E6720
	              73656374
	              6F723A20
	              00
1648:				;
1649:     -	09F1' 68656C70	help_msg        byte "help", 0x0d, 0x0a
	              0D0A
1650:     -	09F7' 64756D70	                byte "dump <start addr> [<length>]", 0x0d, 0x0a
	              203C7374
	              61727420
	              61646472
	              3E205B3C
	              6C656E67
	              74683E5D
	              0D0A
1651:     -	0A15' 64697361	                byte "disassemble [<start addr>] [<length>]", 0x0d, 0x0a
	              7373656D
	              626C6520
	              5B3C7374
	              61727420
	              61646472
	              3E5D205B
	              3C6C656E
	              6774683E
	              5D0D0A
1652:     -	0A3C' 72656164	                byte "read <addr>", 0x0d, 0x0a
	              203C6164
	              64723E0D
	              0A
1653:     -	0A49' 77726974	                byte "write <addr> <data1> [<data2> <data3> ...]", 0x0d, 0x0a
	              65203C61
	              6464723E
	              203C6461
	              7461313E
	              205B3C64
	              61746132
	              3E203C64
	              61746133
	              3E202E2E
	              2E5D0D0A
1654:     -	0A75' 66696C6C	                byte "fill <addr> <length> <data>", 0x0d, 0x0a
	              203C6164
	              64723E20
	              3C6C656E
	              6774683E
	              203C6461
	              74613E0D
	              0A
1655:     -	0A92' 696E203C	                byte "in <addr>", 0x0d, 0x0a
	              61646472
	              3E0D0A
1656:     -	0A9D' 6F757420	                byte "out <addr> <data1> [<data2> <data3> ...]", 0x0d, 0x0a
	              3C616464
	              723E203C
	              64617461
	              313E205B
	              3C646174
	              61323E20
	              3C646174
	              61333E20
	              2E2E2E5D
	              0D0A
1657:     -	0AC7' 6D617020	                byte "map [<bank> <page> [""prot""] [""super""]]", 0x0d, 0x0a
	              5B3C6261
	              6E6B3E20
	              3C706167
	              653E205B
	              2270726F
	              74225D20
	              5B227375
	              70657222
	              5D5D0D0A
1658:     -	0AEF' 70616765	                byte "pages", 0x0d, 0x0a
	              730D0A
1659:     -	0AF6' 696E666F	                byte "info", 0x0d, 0x0a
	              0D0A
1660:     -	0AFC' 6D656D74	                byte "memtest", 0x0d, 0x0a
	              6573740D
	              0A
1661:     -	0B05' 6D6F6E64	                byte "mondownload", 0x0d, 0x0a
	              6F776E6C
	              6F61640D
	              0A
1662:     -	0B12' 62696E64	                byte "bindownload <addr>", 0x0d, 0x0a
	              6F776E6C
	              6F616420
	              3C616464
	              723E0D0A
1663:     -	0B26' 74706164	                byte "tpadownload", 0x0d, 0x0a
	              6F776E6C
	              6F61640D
	              0A
1664:     -	0B33' 74696D65	                byte "time [<h>:<m>[:s>] [<d>/<m>/<y>]]", 0x0d, 0x0a
	              205B3C68
	              3E3A3C6D
	              3E5B3A73
	              3E5D205B
	              3C643E2F
	              3C6D3E2F
	              3C793E5D
	              5D0D0A
1665:     -	0B56' 676F205B	                byte "go [<addr>]", 0x0d, 0x0a
	              3C616464
	              723E5D0D
	              0A
1666:     -	0B63' 74726163	                byte "trace | t [<addr>]", 0x0d, 0x0a
	              65207C20
	              74205B3C
	              61646472
	              3E5D0D0A
1667:     -	0B77' 74726163	                byte "traceover | o", 0x0d, 0x0a
	              656F7665
	              72207C20
	              6F0D0A
1668:     -	0B86' 73657420	                byte "set <reg> <value>", 0x0d, 0x0a
	              3C726567
	              3E203C76
	              616C7565
	              3E0D0A
1669:     -	0B99' 72656769	                byte "registers", 0x0d, 0x0a
	              73746572
	              730D0A
1670:     -	0BA4' 72656164	                byte "readsec <start sec> <no. of 512-byte sectors> <address>", 0x0d, 0x0a
	              73656320
	              3C737461
	              72742073
	              65633E20
	              3C6E6F2E
	              206F6620
	              3531322D
	              62797465
	              20736563
	              746F7273
	              3E203C61
	              64647265
	              73733E0D
	              0A
1671:     -	0BDD' 77726974	                byte "writesec <start sec> <no. of 512-byte sectors> <address>", 0x0d, 0x0a
	              65736563
	              203C7374
	              61727420
	              7365633E
	              203C6E6F
	              2E206F66
	              20353132
	              2D627974
	              65207365
	              63746F72
	              733E203C
	              61646472
	              6573733E
	              0D0A
1672:     -	0C17' 63616368	                byte "cache", 0x0d, 0x0a
	              650D0A
1673:     -	0C1E' 63706D20	                byte "cpm [""debug""] [""noints""] [""rawcon""]", 0x0d, 0x0a
	              5B226465
	              62756722
	              5D205B22
	              6E6F696E
	              7473225D
	              205B2272
	              6177636F
	              6E225D0D
	              0A
1674:     -	0C43' 63706F72	                byte "cport <port>", 0x0d, 0x0a
	              74203C70
	              6F72743E
	              0D0A
1675:     -	0C51' 74706F72	                byte "tport <port>", 0x0d, 0x0a
	              74203C70
	              6F72743E
	              0D0A
1676:     -	0C5F' 636F6C64	                byte 'cold (perform a cold start)"', 0x0d, 0x0a
	              20287065
	              72666F72
	              6D206120
	              636F6C64
	              20737461
	              72742922
	              0D0A
1677:     -	0C7D' 41626272	                byte "Abbreviate commands with '.'.", 0x0d, 0x0a
	              65766961
	              74652063
	              6F6D6D61
	              6E647320
	              77697468
	              20272E27
	              2E0D0A
1678:     -	0C9C' 5E50202F	                byte "^P / ^N - recall previous / next command.", 0x0d, 0x0a
	              205E4E20
	              2D207265
	              63616C6C
	              20707265
	              76696F75
	              73202F20
	              6E657874
	              20636F6D
	              6D616E64
	              2E0D0A
1679:     -	0CC7' 3C706F72	                byte '<port> ::= "ser1" | "ser2"', 0x0d, 0x0a
	              743E203A
	              3A3D2022
	              73657231
	              22207C20
	              22736572
	              32220D0A
1680:     -	0CE3' 00      	                byte 0
1681:				;
1682:     -	0CE4' 20627974	cwr_bytes_msg   byte " bytes written", 0x0d, 0x0a, 0
	              65732077
	              72697474
	              656E0D0A
	              00
1683:     -	0CF5' 202D2000	cm_range_msg    byte " - ", 0
1684:     -	0CF9' 20777269	cm_write_msg    byte " writeable", 0
	              74656162
	              6C6500
1685:     -	0D04' 20726561	cm_ro_msg       byte " read only", 0
	              64206F6E
	              6C7900
1686:     -	0D0F' 2C207375	cm_super_msg    byte ", supervisor", 0
	              70657276
	              69736F72
	              00
1687:     -	0D1C' 73757065	cm_op_list      byte "super prot", 0
	              72207072
	              6F7400
1688:     -	0D27' 756E616C	cm_unalloc_msg  byte "unallocated", 0
	              6C6F6361
	              74656400
1689:     -	0D33' 64656275	ccpm_op_list    byte "debug noints rawcon", 0
	              67206E6F
	              696E7473
	              20726177
	              636F6E00
1690:     -	0D47' 46504741	ci_fpga_rev_msg byte "FPGA revision: ", 0
	              20726576
	              6973696F
	              6E3A2000
1691:     -	0D57' 0D0A546F	ci_ram_msg      byte 0x0d, 0x0a, "Total RAM: ", 0
	              74616C20
	              52414D3A
	              2000
1692:     -	0D65' 204B420D	ci_cpuspd_msg   byte " KB", 0x0d, 0x0a, "CPU clock: ", 0
	              0A435055
	              20636C6F
	              636B3A20
	              00
1693:     -	0D76' 204B487A	ci_khz_msg      byte " KHz", 0
	              00
1694:     -	0D7B' 0D0A4D6F	ci_mon_cnt_msg  byte 0x0d, 0x0a, "Monitor starts: ", 0
	              6E69746F
	              72207374
	              61727473
	              3A2000
1695:     -	0D8E' 0D0A436F	ci_con_port     byte 0x0d, 0x0a, "Console port: ", 0
	              6E736F6C
	              6520706F
	              72743A20
	              00
1696:     -	0D9F' 0D0A4461	ci_tran_port    byte 0x0d, 0x0a, "Data transfer port: ", 0
	              74612074
	              72616E73
	              66657220
	              706F7274
	              3A2000
1697:     -	0DB6' 0D0A5254	ti_rtc_err_msg  byte 0x0d, 0x0a, "RTC error ", 0
	              43206572
	              726F7220
	              00
1698:     -	0DC3' 53656E64	bin_dl_pre_msg  byte "Send binary data on port ", 0
	              2062696E
	              61727920
	              64617461
	              206F6E20
	              706F7274
	              2000
1699:     -	0DDD' 2E205072	bin_dl_post_msg byte ". Press RESET to terminate.", 0x0d, 0x0a, 0
	              65737320
	              52455345
	              5420746F
	              20746572
	              6D696E61
	              74652E0D
	              0A00
1700:     -	0DFB' 496E7661	bad_port_msg    byte "Invalid port.", 0x0d, 0x0a, 0
	              6C696420
	              706F7274
	              2E0D0A00
1701:				;
1702:				; 8-bit registers for set command.
1703:     -	0E0B' 61206620	reg_names       byte "a f b c d e h l "             ; Index 0 to 7
	              62206320
	              64206520
	              68206C20
1704:     -	0E1B' 61272066	                byte "a' f' b' c' d' e' h' l' "     ; Index 8 to 15
	              27206227
	              20632720
	              64272065
	              27206827
	              206C2720
1705:     -	0E33' 69207220	                byte "i r ien mmap "                ; Index 16 to 19
	              69656E20
	              6D6D6170
	              20
1706:     -	0E40' 62632064	                byte "bc de hl "                    ; Index 20 to 22
	              6520686C
	              20
1707:     -	0E49' 62632720	                byte "bc' de' hl' "                 ; Index 23 to 25
	              64652720
	              686C2720
1708:				; Special registers (no alternates)
1709:     -	0E55' 70632073	                byte "pc sp ix iy", 0               ; Index 26 to 29
	              70206978
	              20697900
1710:				;
1711:				; A list of offsets into the exception stack for each register. The order must
1712:				; match that of reg_names. Bit 7 is set to identify a 16-bit value (rather than
1713:				; an 8-bit one).
1714:     -	0E61' 1D1C    	reg_offsets     byte MST_AF + 1, MST_AF             ; Index 0 to 7
1715:     -	0E63' 1B1A    	                byte MST_BC + 1, MST_BC
1716:     -	0E65' 1918    	                byte MST_DE + 1, MST_DE
1717:     -	0E67' 1716    	                byte MST_HL + 1, MST_HL
1718:     -	0E69' 1514    	                byte MST_AF_P + 1, MST_AF_P         ; Index 8 to 15
1719:     -	0E6B' 1312    	                byte MST_BC_P + 1, MST_BC_P
1720:     -	0E6D' 1110    	                byte MST_DE_P + 1, MST_DE_P
1721:     -	0E6F' 0F0E    	                byte MST_HL_P + 1, MST_HL_P
1722:     -	0E71' 1E1F0001	                byte MST_I, MST_R, MST_IEN, MST_MMAP_EN ; Index 16 to 19
1723:     -	0E75' 9A98    	                byte MST_BC + 0x80, MST_DE + 0x80   ; Index 20 to 22
1724:     -	0E77' 96      	                byte MST_HL + 0x80
1725:     -	0E78' 9290    	                byte MST_BC_P + 0x80, MST_DE_P+ 0x80 ; Index 23 to 25
1726:     -	0E7A' 8E      	                byte MST_HL_P + 0x80
1727:				; Special registers (no alternates)
1728:     -	0E7B' 8886    	                byte MST_PC + 0x80, MST_SP + 0x80   ; Index 26 to 29
1729:     -	0E7D' 8C8A    	                byte MST_IX + 0x80, MST_IY + 0x80
1730:				;
1731:				; Names must match definitions in io.i
1732:     -	0E7F' 73657231	prt_name_list   byte "ser1 ser2", 0
	              20736572
	              3200
1733:				;
1734:				;
1735:				;
1736:				; *************
1737:				; * Variables *
1738:				; *************
1739:				;
1740:				; Private monitor variables located in bank 1.
1741:				; Note: linker "-c" option is used, so no data is initialised here.
1742:				                dseg                ; Data segment
1743:				;
1744:     -	0000"         	cmd_sp          defs 2              ; mcexec stack pointer
1745:     -	0002"         	cd_line_bytes   defs CD_BYTESPERLINE    ; Dump cmd. data for current line
1746:     -	000A"         	cd_disp_flag    defs 1              ; Dump cmd. ellipsis state
1747:     -	000B"         	cm_err_flag     defs 1              ; Memory test error flag
1748:     -	000C"         	time_tm         defs TM_SIZE        ; Date / time structure
1749:     -	0016"         	sector_buff     defs MMC_SECTOR_SIZE
1750:				; Space for relocated monitor download code. The linker is understandably not
1751:				; clever enough to cope with a calculated defs.
1752:     -	0001"         	                assert MON_DL_MAXLEN >= (mdl_code_end - mdl_code_start)
1753:     -	0216"         	mdl_code_run    defs MON_DL_MAXLEN
1754:				;
1755:     -	021E"         	                end



Statistics:

     4	passes
     0	jr promotions
   748	symbols
  3721	bytes

   311	macro calls
  1320	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
CCP_START      =D600      54784
CDISK          =04        4
CD_BYTESPERLINE=08        8
CD_DISP_ELDN   =02        2
CD_DISP_PRN    =00        0
CD_DISP_SAME   =01        1
CD_DISP_STATES =03        3
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DIS_BUF_SIZE   =10        16
DIS_MAX_INSTLEN=04        4
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
HEAP_TOP       =7FFF      32767
I2C_CSR_ACKN_BIT=00        0
I2C_CSR_ACKN_MASK=01        1
I2C_CSR_BUSY_BIT=07        7
I2C_CSR_BUSY_MASK=80        128
I2C_CSR_START_BIT=01        1
I2C_CSR_START_MASK=02        2
I2C_CSR_STOP_BIT=02        2
I2C_CSR_STOP_MASK=04        4
INTS_NUM       =08        8
INT_SER1_RX_BIT=01        1
INT_SER1_RX_MASK=02        2
INT_SER1_RX_VEC=01        1
INT_SER1_TX_BIT=00        0
INT_SER1_TX_MASK=01        1
INT_SER1_TX_VEC=00        0
INT_SER2_RX_BIT=03        3
INT_SER2_RX_MASK=08        8
INT_SER2_RX_VEC=03        3
INT_SER2_TX_BIT=02        2
INT_SER2_TX_MASK=04        4
INT_SER2_TX_VEC=02        2
INT_TICK_BIT   =04        4
INT_TICK_MASK  =10        16
INT_TICK_VEC   =04        4
INT_VEC_TABLE  =FFE0      65504
IOA_CONTROL    =02        2
IOA_CRC_0      =24        36
IOA_CRC_1      =25        37
IOA_CRC_DATA   =26        38
IOA_FPGA_MAJREV=00        0
IOA_FPGA_MINREV=01        1
IOA_FP_SW      =03        3
IOA_I2C_CSR    =18        24
IOA_I2C_DATA   =19        25
IOA_INT_EN     =08        8
IOA_INT_PEND   =0A        10
IOA_MMAP_0     =04        4
IOA_MMAP_1     =05        5
IOA_MMAP_2     =06        6
IOA_MMAP_3     =07        7
IOA_NMI_REASONS=0C        12
IOA_SER1_CSR   =10        16
IOA_SER1_DATA  =11        17
IOA_SER2_CSR   =12        18
IOA_SER2_DATA  =13        19
IOA_SPI_CSR    =20        32
IOA_SPI_DATA   =21        33
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MCCAS_CSUM     =04        4
MCCAS_DATA     =06        6
MCCAS_SECTOR   =01        1
MCCAS_SIZE     = 206      518
MCCAS_STATUS   =00        0
MCCAS_STAT_CPM0_BIT=00        0
MCCAS_STAT_CPM0_MASK=01        1
MCCAS_STAT_CPM1_BIT=01        1
MCCAS_STAT_CPM1_MASK=02        2
MCCAS_STAT_CPM2_BIT=02        2
MCCAS_STAT_CPM2_MASK=04        4
MCCAS_STAT_CPM3_BIT=03        3
MCCAS_STAT_CPM3_MASK=08        8
MCCAS_STAT_DIRT_MASK=0F        15
MCCAS_STAT_VALID_BIT=04        4
MCCAS_STAT_VALID_MASK=10        16
MCCA_BUFFERS   =10        16
MCCA_DIRT_THRES=08        8
MC_STATES      =02        2
MMAP_BANK0_END =3FFF      16383
MMAP_BANK0_START=00        0
MMAP_BANK1_END =7FFF      32767
MMAP_BANK1_START=4000      16384
MMAP_BANK2_END =BFFF      49151
MMAP_BANK2_START=8000      32768
MMAP_BANK3_END =FFFF      65535
MMAP_BANK3_START=C000      49152
MMAP_BANKS     =04        4
MMAP_CPM_PAGES =04        4
MMAP_MON_B0_PAGE=3F        63
MMAP_MON_B1_PAGE=3E        62
MMAP_PAGES     =40        64
MMAP_PAGE_MASK =3F        63
MMAP_PAGE_SIZE =4000      16384
MMAP_PROT_BIT  =07        7
MMAP_PROT_MASK =80        128
MMAP_SUPER_BIT =06        6
MMAP_SUPER_MASK=40        64
MMC_ACMD_MC_SEND_OP_COND=29        41
MMC_ARG1       =01        1
MMC_ARG2       =02        2
MMC_ARG3       =03        3
MMC_ARG4       =04        4
MMC_CID_CRC    =0F        15
MMC_CID_MDT    =0E        14
MMC_CID_MID    =00        0
MMC_CID_OID    =01        1
MMC_CID_PNM    =03        3
MMC_CID_PNM_SIZE=06        6
MMC_CID_PRV    =09        9
MMC_CID_PSN    =0A        10
MMC_CID_SIZE   =10        16
MMC_CMD        =00        0
MMC_CMD_APP_CMD=37        55
MMC_CMD_CRC_ON_OFF=3B        59
MMC_CMD_GO_IDLE_STATE=00        0
MMC_CMD_READ_SINGLE_BLOCK=11        17
MMC_CMD_SEND_CID=0A        10
MMC_CMD_SEND_CSD=09        9
MMC_CMD_SEND_OP_COND=01        1
MMC_CMD_SEND_STATUS=0D        13
MMC_CMD_SET_BLOCKLEN=10        16
MMC_CMD_START  =40        64
MMC_CMD_STOP   =01        1
MMC_CMD_WRITE_BLOCK=18        24
MMC_CRC        =05        5
MMC_CSD_15_8   =0E        14
MMC_CSD_23_16  =0D        13
MMC_CSD_31_24  =0C        12
MMC_CSD_39_32  =0B        11
MMC_CSD_47_40  =0A        10
MMC_CSD_55_48  =09        9
MMC_CSD_63_56  =08        8
MMC_CSD_71_64  =07        7
MMC_CSD_79_72  =06        6
MMC_CSD_87_80  =05        5
MMC_CSD_95_88  =04        4
MMC_CSD_CRC    =0F        15
MMC_CSD_NSAC   =02        2
MMC_CSD_SIZE   =10        16
MMC_CSD_TAAC   =01        1
MMC_CSD_TR_SPD =03        3
MMC_CSD_VERSION=00        0
MMC_LOG2_SEC_SIZE=09        9
MMC_R1_ADDR_ERR_BIT=05        5
MMC_R1_ADDR_ERR_MASK=20        32
MMC_R1_CMD_CRC_ERR_BIT=03        3
MMC_R1_CMD_CRC_ERR_MASK=08        8
MMC_R1_ERA_RST_BIT=01        1
MMC_R1_ERA_RST_MASK=02        2
MMC_R1_ERA_SEQ_ERR_BIT=04        4
MMC_R1_ERA_SEQ_ERR_MASK=10        16
MMC_R1_IDLE_BIT=00        0
MMC_R1_IDLE_MASK=01        1
MMC_R1_ILL_CMD_BIT=02        2
MMC_R1_ILL_CMD_MASK=04        4
MMC_R1_PAR_ERR_BIT=06        6
MMC_R1_PAR_ERR_MASK=40        64
MMC_R1_START_BIT=07        7
MMC_R1_START_MASK=80        128
MMC_SECTOR_SIZE= 200      512
MMC_SIZE       =06        6
MMC_STAT_IDLE  =00        0
MMC_STAT_INIT  =01        1
MON_DL_MAXLEN  =08        8
MPA_NAME_LEN   =04        4
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MS_PER_TICK    =64        100
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NMI_PROT_VIOL_BIT=01        1
NMI_PROT_VIOL_MASK=02        2
NMI_REASONS_ALL=0F        15
NMI_REASONS_NUM=04        4
NMI_SUPER_VIOL_BIT=02        2
NMI_SUPER_VIOL_MASK=04        4
NMI_SWITCH_BIT =00        0
NMI_SWITCH_MASK=01        1
NMI_TRACE_BIT  =03        3
NMI_TRACE_MASK =08        8
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
PORT_SER1      =00        0
PORT_SER2      =01        1
PORT_STATES    =02        2
SER_CSR_FRAME_ERR_BIT=03        3
SER_CSR_FRAME_ERR_MASK=08        8
SER_CSR_RX_ALHALF_BIT=01        1
SER_CSR_RX_ALHALF_MASK=02        2
SER_CSR_RX_EMPTY_BIT=00        0
SER_CSR_RX_EMPTY_MASK=01        1
SER_CSR_RX_FULL_BIT=02        2
SER_CSR_RX_FULL_MASK=04        4
SER_CSR_TX_ALHALF_BIT=05        5
SER_CSR_TX_ALHALF_MASK=20        32
SER_CSR_TX_EMPTY_BIT=04        4
SER_CSR_TX_EMPTY_MASK=10        16
SER_CSR_TX_FULL_BIT=06        6
SER_CSR_TX_FULL_MASK=40        64
SPI_CSR_BUSY_BIT=07        7
SPI_CSR_BUSY_MASK=80        128
SPI_CSR_FAST_BIT=00        0
SPI_CSR_FAST_MASK=01        1
SPI_CSR_MC_SS_BIT=01        1
SPI_CSR_MC_SS_MASK=02        2
SPI_ERR_BADCRC =04        4
SPI_ERR_BADINIT=03        3
SPI_ERR_BADSEC =05        5
SPI_ERR_BAD_R1 =08        8
SPI_ERR_BAD_R2 =09        9
SPI_ERR_BUSY   =01        1
SPI_ERR_DATAERR=07        7
SPI_ERR_HEAP   =0A        10
SPI_ERR_NORESP =02        2
SPI_ERR_NUM    =0E        14
SPI_ERR_OK     =00        0
SPI_ERR_RANGE  =06        6
SPI_ERR_TIMEOUT=0B        11
SPI_ERR_UNKN   =0D        13
SPI_ERR_WRITE  =0C        12
STACKS_SIZE    =40        64
SYSCTRL_MAPARM_BIT=03        3
SYSCTRL_MAPARM_MASK=08        8
SYSCTRL_MMAPN_BIT=04        4
SYSCTRL_MMAPN_MASK=10        16
SYSCTRL_MMAP_BIT=01        1
SYSCTRL_MMAP_MASK=02        2
SYSCTRL_NMCLR_BIT=02        2
SYSCTRL_NMCLR_MASK=04        4
SYSCTRL_RESERVED_BIT=07        7
SYSCTRL_RESERVED_MASK=80        128
SYSCTRL_TRARM_BIT=00        0
SYSCTRL_TRARM_MASK=01        1
SYSCTRL_TRPRE0_BIT=05        5
SYSCTRL_TRPRE0_MASK=20        32
SYSCTRL_TRPRE1_BIT=06        6
SYSCTRL_TRPRE1_MASK=40        64
TICK_FREQ      =0A        10
TIM_EPOCH_YEAR =46        70
TMDST_DST      =02        2
TMDST_GMT      =01        1
TMDST_NUM      =03        3
TMDST_UNKNOWN  =00        0
TM_DST         =09        9
TM_HOURS       =02        2
TM_MDAY        =03        3
TM_MINS        =01        1
TM_MON         =04        4
TM_SECS        =00        0
TM_SIZE        =0A        10
TM_WDAY        =06        6
TM_YDAY        =07        7
TM_YEAR        =05        5
TPA_START      = 100      256
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
bad_port_msg     DFB'     3579
bin_dl_post_msg  DDD'     3549
bin_dl_pre_msg   DC3'     3523
cacold          00        0 (extern)
cacrs           00        0 (extern)
cacws           00        0 (extern)
caflus          00        0 (extern)
carpt           00        0 (extern)
cars            00        0 (extern)
cawarm          00        0 (extern)
caws            00        0 (extern)
cbd_loop         54A'     1354
ccpm_find_mask   69D'     1693
ccpm_op_list     D33'     3379
ccpm_op_loop     685'     1669
ccpm_ops_done    6A4'     1700
cd_asc_bydn      116'     278
cd_asc_gotdata   10D'     269
cd_asc_lp        104'     260
cd_disp_flag    0A"       10
cd_done          138'     312
cd_ellips_loop  C1'       193
cd_ellspc_loop  BA'       186
cd_fetch_fldn   A1'       161
cd_fetch_loop   91'       145
cd_got_len      71'       113
cd_hex_bydn     F1'       241
cd_hex_gotdata  EC'       236
cd_hex_lp       E0'       224
cd_line_bytes   02"       2
cd_line_done     127'     295
cd_line_lp      77'       119
cd_line_st      84'       132
cd_print_line   D3'       211
cdi_def_len      163'     355
cdi_got_len      166'     358
cdi_line_lp      16B'     363
cdi_operands     150'     336
cf_loop          1E1'     481
cg_ints_ok       70D'     1805
cg_no_new_addr   6ED'     1773
ci_con_port      D8E'     3470
ci_cpuspd_msg    D65'     3429
ci_fpga_rev_msg  D47'     3399
ci_khz_msg       D76'     3446
ci_mon_cnt_msg   D7B'     3451
ci_ram_msg       D57'     3415
ci_tran_port     D9F'     3487
cm_display       2B0'     688
cm_err_flag     0B"       11
cm_op_list       D1C'     3356
cm_op_loop       289'     649
cm_ops_done      2A4'     676
cm_prot_pmsg     30C'     780
cm_range_msg     CF5'     3317
cm_regdn         319'     793
cm_regloop       2B2'     690
cm_ro_msg        D04'     3332
cm_super_msg     D0F'     3343
cm_unalloc_msg   D27'     3367
cm_write_msg     CF9'     3321
cmd_bad         2D'       45
cmd_bad_msg      956'     2390
cmd_bin_dl       538'     1336
cmd_cache        3B7'     951
cmd_cold         348'     840
cmd_conf_msg     99C'     2460
cmd_cpm          683'     1667
cmd_cport        6A8'     1704
cmd_disassemble  13A'     314
cmd_done        28'       40
cmd_dump        55'       85
cmd_fill         1B8'     440
cmd_go           6D8'     1752
cmd_help        4E'       78
cmd_in           207'     519
cmd_info         34D'     845
cmd_list         85C'     2140
cmd_map          25F'     607
cmd_memtest      3BF'     959
cmd_mon_dl       4FC'     1276
cmd_op_error    34'       52
cmd_out          223'     547
cmd_pages        340'     832
cmd_prompt       859'     2137
cmd_read         1EF'     495
cmd_readsec      584'     1412
cmd_registers    7AB'     1963
cmd_set          753'     1875
cmd_sp          00"       0
cmd_time         3DF'     991
cmd_tpa_dl       556'     1366
cmd_tport        6C0'     1728
cmd_trace        712'     1810
cmd_traceover    728'     1832
cmd_vectors      91A'     2330
cmd_write        17C'     380
cmd_writesec     607'     1543
cold_start_msg   844'     2116
commands       =01        1
conrch          00        0 (extern)
consta          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
coport          00        0 (extern)
cout_byte_lp     231'     561
cout_done        24A'     586
cpinit          00        0 (extern)
cpmem           00        0 (extern)
cppags          00        0 (extern)
cpuspd          00        0 (extern)
crc16x          00        0 (extern)
crs_copy_loop    5E2'     1506
crs_error        601'     1537
crs_loop         5B7'     1463
crs_sec_msg      9CF'     2511
cs_16bit         7A7'     1959
cs_not_ien       788'     1928
ct_rtc_err       3EA'     1002
ct_rtcreadok     3F9'     1017
ct_run           725'     1829
ct_set           411'     1041
cto_call         74A'     1866
cto_rst          74C'     1868
cts_chk_date     466'     1126
cts_dst_done     4EC'     1260
cts_parse_done   4C5'     1221
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwptm           00        0 (extern)
cwr_byte_lp      185'     389
cwr_bytes_msg    CE4'     3300
cwr_done         1A3'     419
cws_copy_loop    654'     1620
cws_error        67F'     1663
cws_loop         63A'     1594
cws_sec_msg      9E0'     2528
cwvich          00        0 (extern)
diprnt          00        0 (extern)
diproc          00        0 (extern)
disp_bin_dl_msg  7B3'     1971
enum_counter   =03        3
halloc          00        0 (extern)
help_msg         9F1'     2545
hinit           00        0 (extern)
i2crd           00        0 (extern)
i2cwr           00        0 (extern)
int_cfg_msg      9AD'     2477
itdis           00        0 (extern)
itdsct          00        0 (extern)
itena           00        0 (extern)
itenfl          00        0 (extern)
itinit          00        0 (extern)
itstrt          00        0 (extern)
itsvec          00        0 (extern)
jptbl_addr     =7E        126
madbbu          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
mcexec          00'       0 (public)
mcinit          00        0 (extern)
mcprer          00        0 (extern)
mcprot          3D'       61 (public)
mcrrs           00        0 (extern)
mcrun           00        0 (extern)
mcrws           00        0 (extern)
mcspd           00        0 (extern)
mcstat          00        0 (extern)
mdisrg          00        0 (extern)
mdl_code_end     538'     1336
mdl_code_run     216"     534
mdl_code_start   531'     1329
mdl_have_addr    527'     1319
mdl_loop         534'     1332
memtal          00        0 (extern)
memtst          00        0 (extern)
monitor        =01        1
mpall           00        0 (extern)
mpfree          00        0 (extern)
mpinit          00        0 (extern)
mppnam          00        0 (extern)
mprpt           00        0 (extern)
mpstat          00        0 (extern)
mscnt           00        0 (extern)
mstate          00        0 (extern)
mtwdli          00        0 (extern)
op_err_msg       964'     2404
panic           00        0 (extern)
prpn_name_dn     336'     822
prpnam           323'     803 (public)
prt_name_list    E7F'     3711
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
reg_names        E0B'     3595
reg_offsets      E61'     3681
rusby           00        0 (extern)
ruswd           00        0 (extern)
s1rch           00        0 (extern)
s1sta           00        0 (extern)
s1wch           00        0 (extern)
s2rch           00        0 (extern)
s2sta           00        0 (extern)
s2wch           00        0 (extern)
sector_buff     16"       22
signon_msg       830'     2096
skpspc          00        0 (extern)
spiini          00        0 (extern)
spiss           00        0 (extern)
spitr           00        0 (extern)
str_offset     = 206      518
tbd_loop         564'     1380
ti_rtc_err_msg   DB6'     3510
tiitos          00        0 (extern)
tikcnt          00        0 (extern)
time_tm         0C"       12
tird            00        0 (extern)
tistoi          00        0 (extern)
tiwr            00        0 (extern)
toloca          00        0 (extern)
toupca          00        0 (extern)
trarch          00        0 (extern)
trawch          00        0 (extern)
trport          00        0 (extern)
warm1           00        0 (extern)
wr_prot_msg      974'     2420
wusby           00        0 (extern)
wuswd           00        0 (extern)
zarc_msg         7CD'     1997
