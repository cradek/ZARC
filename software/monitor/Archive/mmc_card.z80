; *******************************************************
; * Memory Card Routines for ZARC Z80 Computer          *
; * Written by: Merlin Skinner                          *
; * Date Started: 7/8/2020                              *
; *******************************************************
;
; Routines associated with the MMC memory card.
;
; The interface uses the SPI mode of communication described in these references:
; 1) file:///tmp/mozilla_merlin0/MMC-System-Spec-v3.31.pdf
; 2) http://alumni.cs.ucr.edu/~amitra/sdcard/Additional/sdcard_appnote_foust.pdf
; 3) https://openlabpro.com/guide/interfacing-microcontrollers-with-sd-card/
;
; Routines preserve all registers not required as operands or return values except
; AF unless otherwise stated below. These routines are normally called through the
; RST 08 (mcall) mechanism, but may be called directly by the monitor if required.
;
;
monitor         equ 1                   ; Flag part of monitor build
mmc             equ 1                   ; Flag module for includes
;
;
;
; ************
; * Includes *
; ************
;
                include "macros.i"
                include "z80.i"
                include "monitor.i"
                include "zarc.i"        ; Hardware definitions
                include "io_map.i"      ; I/O addresses mapping
                include "terminal.i"    ; Terminal constants
                include "io.i"          ; I/O routines
                include "maths.i"       ; Mathematical functions
                include "spi.i"         ; SPI master interface
                include "mmc.i"         ; Memory card
;
;
; *************
; * Externals *
; *************
;
; Routines
                public mcinit   ; Initialise memory card
                public mcprer   ; Print memory card error text
;
; Variables
;                public tinow    ; Current time and date
;                extern itenfl   ; Int. enable flag (0 = basic, 1 = normal I/O mode)
;
;
; *************
; * Constants *
; *************
;
; None
;
;
; *************
; * Main Code *
; *************
;
                cseg                ; Code segment
;
;
; Initialise card.
; Returns with:
; A - zero (OK) or SPI error code (SPI_ERR_xxx)
mcinit          push bc
; At least 74 clocks must be issued (with SS inactive) by the master before any
; attempt is made to communicate with the card (reference 1 section 6.4.1.1).
                xor a               ; Set slow mode
                call spiini         ; Initialise SPI interface and set speed
                ld b, 10            ; 10 bytes generate 80 clocks
mci_initloop    ld a, 0xff
                call spitr          ; Send / receive byte
                and a
                jr nz, mci_err      ; Jump on error
                djnz mci_initloop
;
; Send a reset command (CMD0)
                ld ix, mc_cmd_buff  ; Point to command buffer
                ld iy, mc_resp_buff ; Point to response buffer
                call clr_cmd_buff   ; Clear command buffer
                ld (ix + MMC_CMD), MC_CMD_GO_IDLE_STATE
                call mc_command
                and a
                jr nz, mci_err      ; Jump on error

                ld a, (iy + 0)      ; Fetch response (R1)
                mcall MC_CONW_HNBY  ; Print in hex


; The card is continuously polled with the commands CMD55 and ACMD41 until the idle
; bit becomes clear, indicating that the card is fully initialized and ready to
; respond to general commands.




; The command CMD58 is used to determine if the card supports the available
; operating voltage. CMD58 returns a bit field containing the allowed operating voltage
; ranges, typically between 2.7 V and 3.6 V. For ZARC, the supply is 3.3 V. Finally,
; the SPI clock is increased for normal use.


                pop bc
                xor a
                ret                 ; Return with success code
;
; SPI error
mci_err         push af             ; Save error code
                xor a               ; Remove slave select
                call spiss          ; Set SPI slave select(s)
                pop af
                pop bc
                ret                 ; Return with code in A




; sd_send_command(sdc,CMD0,CMD0_R,response,argument)

;
;
; Send a command to the memory card and receive the response. Start and stop bits are
; inserted before transmission.
; Call with;
; IX - pointer to command structure (SDC)
; IY - pointer to response buffer
; Returns with:
; A - zero (OK) or error code (SPI_ERR_xxx)
; IX and IY are preserved by this routine.
mc_command      push bc
                push hl
; Insert start bits
                ld a, MC_CMD_START
                or (ix + MMC_CMD)
                ld (ix + MMC_CMD), a
;
; Set CRC. This is required for first command. but ignored thereafter unless we
; explicitly enable it.
                ld c, 0                 ; Set initial CRC
                ld b, MMC_SIZE - 1      ; Set length excluding CRC
                push ix
                pop hl
mcc_crc_loop    ld a, (hl)
                call crc7
                inc hl
                djnz mcc_crc_loop
                ld a, c
; Insert CRC and end bit.
                scf                     ; End bit
                rla                     ; Move CRC to bits 1 to 7
                ld (ix + MMC_CRC), a
; Result should be 0x95 for CMD0
;
; Set slave select
                ld a, SPI_CSR_MC_SS_MASK    ; Set slave select
                call spiss          ; Set SPI slave select(s)
; Send the command
                ld b, MMC_SIZE      ; Command sequence size in bytes
                push ix
                pop hl
mcc_byteloop    ld a, (hl)
                call spitr          ; Send / receive byte
                and a
                jr nz, mcc_err      ; Jump on error
                inc hl
                djnz mcc_byteloop
;
; Await R1 response. 
                ld b, 0             ; Crude timeout
mcc_waitresp    ld a, 0xff
                call spitr          ; Send / receive byte
                and a
                jr nz, mcc_err      ; Jump on error
                bit MC_R1_START_BIT, c
                jr z, mcc_resp      ; Jump if response received
                djnz mcc_waitresp
; No response found - timed out
                xor a               ; Remove slave select
                call spiss          ; Set SPI slave select(s)
                pop hl
                pop bc
                ld a, SPI_ERR_NORESP
                ret
; C - response received
mcc_resp        push iy
                pop hl
                ld (hl), c
;
; Normal completion
                xor a               ; Remove slave select
                call spiss          ; Set SPI slave select(s)
                pop hl
                pop bc
                xor a
                ret                 ; Return with success code

; SPI interface error (code in A).
mcc_err         push af             ; Save error code
                xor a               ; Remove slave select
                call spiss          ; Set SPI slave select(s)
                pop af
                pop hl
                pop bc
                ret                 ; Return with error code in A
;
;
; Clear buffer
; Call with;
; IX - pointer to command structure (SDC)
; Note - IX is preserved
clr_cmd_buff    push bc
                push hl
                push ix             ; Move IX to HL
                pop hl
                ld b, MMC_SIZE
                xor a
; HL - buffer pointer
; B - loop counter
ccb_loop        ld (hl), a
                inc hl
                djnz ccb_loop
                pop hl
                pop bc
                ret
;
;
; Print memory card error text, or nothing if no error (A = 0)
; Call with:
; A - zero (OK) or SPI error code (SPI_ERR_xxx)
mcprer          and a
                ret z               ; Return if no error
                push bc
                push hl
                push af
                ld hl, err_pre_msg
                mcall MC_CONW_STR   ; Print "*** MMC error: " message
                ld hl, err_msgs
                pop af
                dec a               ; Errors start from 1
                ld c, "|"           ; Separator
                mcall MC_CONW_MSGN  ; Print message <n> in a list
                ld hl, err_post_msg
                mcall MC_CONW_STR   ; Print " *** " message
                pop hl
                pop bc
                ret
;
;
; Print R1 response error bits. Nothing is printed if there are no errors.
; The idle and start bits are ignored, as they are not errors.
; Call with:
; A - memory card R1 response
mcpr1           push bc
                push de
                push hl
; Discard non-error bits
                and low not (MC_R1_START_MASK + MC_R1_IDLE_MASK)
                jr z, pr1_exit      ; Jump if nothing to report
                ld c, a
                ld hl, r1_err_pre_msg
                mcall MC_CONW_STR   ; Print "*** MMC R1 errors: " message
                ld d, 0
                ld b, 6
; B - loop counter
; C - R1 bits
; D - report count
; Loop for each error bit, writing the corresponding message if appropriate.
pr1_loop        rl c
                bit 7, c
                jr z, pr1_nomsg
; Print a separator if not the first report
                ld a, d
                and a
                jr z, pr1_sep_done
                ld a, ','
                mcall MC_CONW_CH    ; Print separator 
                mcall MC_CONW_SPC   ; Print a space
pr1_sep_done    ld hl, r1_err_msgs
                ld a, b
                dec a               ; Adjust counter to range 5 to 0
                push bc
                ld c, "|"           ; Separator
                mcall MC_CONW_MSGN  ; Print message <n> in a list
                pop bc
                inc d               ; Count reports
pr1_nomsg       djnz pr1_loop
                ld hl, err_post_msg
                mcall MC_CONW_STR   ; Print " *** " message
pr1_exit        pop hl
                pop de
                pop bc
                ret
;
;
; Update CRC according to the MultiMediaCard CRC7 algorithm (reference 1 section
; 8.2). This is unlikely to find other uses, so is included in this code rather
; than in utilities.
; Call with:
; A - byte to be included
; C - CRC
; Returns with:
; C - updated CRC
crc7            push bc
                push de
                ld d, a
                ld b, 8             ; Bit count
; B - bit count
; C - CRC
; D - data to include
c7_bit_loop     rlc d               ; Rotate next bit to bit 0
                ld a, c
                rlca
                rlca
; CRC bit 6 is now in bit 0
                xor d
                ld e, a
; E bit 0 = <CRC bit 6> xor <new bit> = <new CRC bit 0>
                ld a, c
                rrca
                rrca
; CRC bit 2 is now in bit 0
                xor e
; Bit 0 = <CRC bit 6> xor <new bit> xor <CRC bit 2> = <new CRC bit 3>
                push af
                ld a, e
                rrca                ; Rotate new bit into carry
                rl c                ; Rotate into CRC
; We need to replace CRC bit 3 with the newly calculated bit.
                ld a, c
                and 0x77            ; Reset bits 3 and 7
                ld c, a
                pop af              ; Restore new bit 3
                rlca
                rlca
                rlca
                and 0x08            ; Isolate bit 3
                or c
                ld c, a
; Bit processing complete.
                djnz c7_bit_loop
                ld a, c
                pop de
                pop bc
                ld c, a
                ret





;
;
;
; *************
; * Constants *
; *************
;
err_pre_msg     byte "*** MMC error: ", 0
err_msgs        byte "SPI busy|no response from MMC card", 0
err_post_msg    byte " ***", 0x0d, 0x0a, 0
r1_err_pre_msg  byte "*** MMC R1 errors: ", 0
r1_err_msgs     byte "erase reset|illegal command|bad command CRC|erase sequence error|bad address|bad parameter", 0
;
;
;
; *************
; * Variables *
; *************
;
;
; Note: linker "-c" option is used, so no data is initialised here.
                dseg                ; Data segment
;
mc_cmd_buff     defs MMC_SIZE       ; Command buffer
mc_resp_buff    defs 1              ; Response buffer (TEMP size)
;
                end

