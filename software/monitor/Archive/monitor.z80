; *******************************************************
; * Monitor for ZARC Z80 Computer                       *
; * (Serial boot version).                              *
; * Version: V0.0                                       *
; * Merlin Skinner, 14/5/2020                           *
; *******************************************************
;
; This code will be loaded from the console serial port by the stage 1 bootloader.
; This is entered manually from the front panel:
;
; 3FE0                          .ORG   0x3fe0   ; Use top of page
; 3FE0   3E 7F                  LD   a,0x7f   ; Page 0x3f with SUPER=1 and PROT=0
; 3FE2   D3 04                  OUT   0x04,a   ; Page and protection for 0x0000 to 0x3fff
; 3FE4   3E 01                  LD   a,0x01   
; 3FE6   D3 02                  OUT   0x02,a   ; Enable memory mapping
; 3FE8   0E 11                  LD   c,0x11    ; Select console input port
; 3FEA   21 00 00               LD   hl,0x0000    ; Start address 
; 3FED                LOOP:     
; 3FED   ED A2                  INI   
; 3FEF   18 FC                  JR   loop   ; Load data until reset
;
; The above was assembled with the online assembler at:
; https://www.asm80.com/onepage/asmz80.html
;
; This loads raw binary data from the serial port into memory starting at location zero.
; Press reset to stop the loader and run the newly downloaded code.
;
;
; Memory Map
; 
; 0 (0000 - 3FFF): 3f read only, supervisor - monitor program
; 1 (4000 - 7FFF): (not used)
; 2 (8000 - BFFF): (not used)
; 3 (C000 - FFFF): 3e writeable - variables, stack etc.
;
; The monitor will provide I/O and support routines for other programs, such as CP/M.
; Pages are mapped into bank 1 (4000 - 7FFF) and bank 2 (8000 - BFFF) as required to
; support this. Page 0x3f is selected in hardware when memory mapping is not active, so
; on reset the monitor (page 0x3f at address 0) is entered.
;
;
                title ZARC Monitor
;
monitor         equ 1                   ; Flag module for includes
;
;
; ************
; * Includes *
; ************
;
                include "macros.i"
                include "z80.i"
                include "zarc.i"        ; Hardware definitions
                include "monitor.i"
                include "io_map.i"      ; I/O addresses mapping
                include "terminal.i"    ; Terminal constants
                include "io.i"          ; I/O routines
                include "utility.i"     ; Utility functions
                include "maths.i"       ; Mathematical functions
                include "interrupts.i"  ; Interrupts
                include "time.i"        ; Routines associated with time
                include "diags.i"       ; Diagnostics
                include "spi.i"         ; SPI master interface
                include "mmc.i"         ; Memory card
                include "disass.i"      ; Z80 disassembler
;
;
; *************
; * Externals *
; *************
;
                public tikdiv       ; Tick divider
                public panic        ; System error exception
;
;
; *************
; * Constants *
; *************
;
CMD_BUF_SIZE    equ 80              ; Command buffer length
CD_BYTESPERLINE equ 8               ; Number of bytes per line for dump command
WARM_MAGIC_1    equ 0x55            ; Warm start magic numbers
WARM_MAGIC_2    equ 0xaa
;
;
; *************
; * Main Code *
; *************
;
                cseg                ; Code segment
;
; Linker -P option sets start address (0x0000).
                di
                jp init
;
; Make space to allow RST and interrupt vectors to be inserted if we are running
; at 0x0000.
                defs 0x65           ; Skip end of NMI vector allowing for a jump
;
init            di                  ; Required if coming from exception handler
;
; We should use the monitor stack location in mon_sp, but it may be corrupt, or
; simply not initialised. The default monitor stack space is from MON_STACK_TOP
; to MON_STACK_BOT. Anything in the range MON_STACK_TOP + 1 to MON_STACK_BOT +
; STACKS_SIZE + 1 is OK.
                ld hl, (mon_sp)
                dec hl              ; Find address of first stacked byte
                ld de, MON_STACK_TOP + 1
                and a
                sbc hl, de
; This will carry if the first item on the stack will be at MON_STACK_TOP or lower.
                jr nc, init_defstk  ; Jump if mon_sp is bad
                ld hl, (mon_sp)
                dec hl              ; Find address of first stacked byte
                ld de, MON_STACK_BOT + STACKS_SIZE
                and a
                sbc hl, de
; If this carries, there is not sufficient space for the monitor stack if we start
; from this location.
                jr nc, init_set_sp
;
; Use the default stack location.
init_defstk     ld hl, MON_STACK_TOP + 1    ; Use default stack
                ld (mon_sp), hl
; Stack pointer validation complete
init_set_sp     ld sp, (mon_sp)
;
; Set initial memory map. Page 0 is made writeable initially to allow vectors to be
; initialised.
; Note - can't call mmap_page0_rw here as we have no writeable stack yet.
                ld a, MMAP_MON_PAGE0 + MMAP_SUPER_MASK ; Set bank 0 to read / write mode
                out (IOA_MMAP_0), a
; Set unused banks to arbitrary values so the FPGA shadow registers reflect the
; real bank registers.
                ld a, 0 + MMAP_PROT_MASK
                out (IOA_MMAP_1), a	; Bank 1 (0x4000 to 0x7fff) not used
                ld a, 0 + MMAP_PROT_MASK
                out (IOA_MMAP_2), a	; Bank 2 (0x8000 to 0xbfff) not used
                ld a, MMAP_MON_PAGE3
                out (IOA_MMAP_3), a	; Bank 3 (0xc000 to 0xffff) writeable
; Enable memory mapping so we can write.
                ld a, SYSCTRL_MMAP_MASK
                out (IOA_CONTROL), a 
;
; Write vectors to locations in the monitor. These may be overwitten as required.
; RST 0 already points to the initialisation code.
                ld a, 0x08
                ld de, mcall_entry  ; Monitor function entry point
                call utrivc
                call c, panic       ; Panic on error
;
                ld a, 0x10
                ld de, default_rst10    ; Point to default handler
                call utrivc
                call c, panic       ; Panic on error
;
                ld a, 0x18
                ld de, default_rst18    ; Point to default handler
                call utrivc
                call c, panic       ; Panic on error
;
                ld a, 0x20
                ld de, default_rst20    ; Point to default handler
                call utrivc
                call c, panic       ; Panic on error
;
                ld a, 0x28
                ld de, default_rst28    ; Point to default handler
                call utrivc
                call c, panic       ; Panic on error
;
                ld a, 0x30
                ld de, default_rst30    ; Point to default handler
                call utrivc
                call c, panic       ; Panic on error
;
                ld a, 0x38
                ld de, default_rst38    ; Point to default handler
                call utrivc
                call c, panic       ; Panic on error
;
; NMI vector
                ld de, default_nmi  ; Point to default handler
                ld hl, Z80_NMI_VEC
                ld (hl), 0xc3       ; Jump instruction
                inc hl
                ld (hl), e          ; LS byte of address
                inc hl
                ld (hl), d          ; MS byte of address
;
                call mmap_page0_ro  ; Set page 0 to read only
;
; Interrupt (mode 2) vectors are stored in page 3 to allow access when running
; CP/M.
                ld b, 0             ; Vector number
; Loop for all vectors.
init_int_loop   ld a, b
                ld de, default_int  ; Point to default handler
                call itsvec         ; Set interrupt vector
                inc b
                ld a, b
                cp INTS_NUM
                jr c, init_int_loop
;
                call con_init_basic ; Initialise console I/O in basic mode
;
                call cpuspd         ; Measure approximate CPU clock speed
                ld (cpu_speed_khz), bc
;
; Is this a cold or warm start? Markers are placed at the beginning and the
; end of the variables area. If these are set appropriately, we must have run
; before so this is a warm start.
                ld a, (warm_mark1)
                cp WARM_MAGIC_1
                jr nz, init_cold
                ld a, (warm_mark2)
                cp WARM_MAGIC_2
                jr nz, init_cold
                jr init_warm        ; Do warm start
;
; Cold start initialisation.
init_cold       ld hl, cold_start_msg   ; Announce cold start
                mcall MC_CONW_STR   ; Print message
                ld hl, 0
                ld (mon_start_count), hl    ; Reset reset counter
; Initialise user registers. Most significantly, this will set up a stack and ensure
; that interrupts are disabled. First set an initial PC.
                ld hl, USR_STACK_TOP + 1
                xor a
                dec hl
                ld (hl), a
                dec hl
                ld (hl), a
                ld (user_sp), hl
; Zero the exception stack area, thereby clearling all registers.
                ld hl, XPT_STACK_TOP
                ld b, STACKS_SIZE
                xor a
ic_zero_lp      ld (hl), a
                dec hl
                djnz ic_zero_lp
; The only exception is the I register, which is set to the value used by the
; monitor. This will avoid one cause of unpleasant crashes if the user code enables
; interrupts.
                ld hl, XPT_STACK_TOP - 20
                ld (hl), high (INT_VEC_TABLE)
;
; Set warm start markers
                ld a, WARM_MAGIC_1
                ld (warm_mark1), a
                ld a, WARM_MAGIC_2
                ld (warm_mark2), a
;
; Warm start (may be after cold start code).
; Increment the restart counter. This includes resets and exceptions
; that cause the monitor to be entered.
init_warm       ld hl, mon_start_count
                inc (hl)
                jr nz, init_signon
                inc hl
                inc (hl)
;
; Sign on
init_signon     ld hl, signon_msg
                mcall MC_CONW_STR   ; Print message
;
; Command loop
get_cmd         ld sp, (mon_sp)     ; Reset stack
                ld hl, cmd_prompt   ; Display prompt
                mcall MC_CONW_STR   ; Print message
                ld hl, cmd_buf      ; Point to start of buffer
                xor a               ; Clear length
                ld (cmd_len), a
; Character loop
gc_loop         mcall MC_CONR_CH    ; Fetch next character from user
; Process command on CR.
                cp ascii_cr
                jr z, gc_cr
; DEL or BS deletes the last character.
                cp ascii_del
                jr z, gc_delete
                cp ascii_bs
                jr z, gc_delete
                cp 0x20
                jr c, gc_loop       ; Ignore all other control characters
                bit 7, a
                jr nz, gc_loop      ; Ignore any 8-bit character (non-printable)
; This is a printable character.
                ld b,a              ; Save character
                ld a, (cmd_len)
                inc a               ; Allow space for terminator
                cp CMD_BUF_SIZE
                jr nc, gc_loop      ; Ignore if no space
                ld (cmd_len), a     ; Store updated length
                ld a, b             ; Restore character
                ld (hl), a          ; Store in buffer
                inc hl
                mcall MC_CONW_CH    ; Echo it
                jr gc_loop
;
; Delete the last character.
gc_delete       ld a, (cmd_len)
                and a
                jr z, gc_loop       ; Ignore if buffer is empty
                dec a
                ld (cmd_len), a     ; Store updated length
                dec hl
; Delete on terminal.
                ld a, ascii_bs
                mcall MC_CONW_CH
                mcall MC_CONW_SPC   ; Print a space
                ld a, ascii_bs
                mcall MC_CONW_CH
                jr gc_loop
;
; End of command.
gc_cr           xor a
                ld (hl), a          ; Add terminator
; The command is now a null-terminated string in cmd_buf with cmd_len characters.
                mcall MC_CONW_NLN ; Write new line characters to console
;
; Process the command.
                ld hl, cmd_buf      ; Point to start of buffer
                mcall MC_SKIP_SPCS  ; Skip any leading spaces
;
                ld a, (hl)
                and a
                jr z, get_cmd       ; Ignore null commands
;
; Match against list of commands.
                ld de, cmd_list
                mcall MC_MAT_WORD
                and a
                jr z, cmd_bad
;
; Find address of command code
                push hl             ; Save command buffer pointer
                ld hl, cmd_vectors
                dec a               ; Start index from zero
                add a               ; Convert index to a word offset
                add l               ; Add low byte
                ld l,a
                ld a, 0
                adc a, h            ; Add carry to high byte
                ld h, a
; HL is cmd_vectors + 2 * index
                ld e, (hl)          ; Read address
                inc hl
                ld d, (hl)
                pop hl              ; Restore command buffer pointer
; Pre-load stack with return address for use when the command is complete.
                ld bc, get_cmd
                push bc
                push de
; HL points to the separator after the command word or the terminator.
                ret                 ; Go to command routine
;                
; Can't match command against any of the valid ones.
cmd_bad         ld hl, cmd_bad_msg
                mcall MC_CONW_STR   ; Print message
                jp get_cmd
;
; Operand error
cmd_op_error    ld hl, cmd_op_err_msg
                mcall MC_CONW_STR   ; Print message
                jp get_cmd
;
;
; Print terse help text.
cmd_help        ld hl, help_msg
                mcall MC_CONW_STR   ; Print message
                ret
;
;
; Display an area of memory in hex and ASCII. The format is similar to
; Linux's hexdump -C:
; 1234  00 11 22 33 44 55 66 77  |abcdefgh|
; Command format:
; dump <start addr> [<length>]
; length defaults to 0x0040 if not specified.
cmd_dump        mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                jp c, cmd_op_error  ; Address is required
                push de             ; Save starting address
                mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch length
                push af             ; Save carry flag
                mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                pop af
                jr nc, cd_got_len
                ld de, 0x0040       ; Use default length
cd_got_len      pop hl              ; Put address in HL
cd_line_lp      push hl             ; Save address
; Calculate how many bytes to display in this line.
                ld c, CD_BYTESPERLINE   ; Assume maximum initially
                ld a,d
                and a
                jnz cd_line_st
; 0xff bytes or fewer.
                ld a,e
                cp c
                jnc cd_line_st      ; Jump if >= maximum remaining
                ld c, e             ; Use remaining byte count
cd_line_st      ld b, CD_BYTESPERLINE   ; Bytes per line
; Display bytes.
; HL - pointer to data
; B - byte counter
; C - number of bytes to display (allows for partial final lines)
                ld a, c
                and a
                jr z, cd_done       ; Exit if no bytes to display
                mcall MC_CONW_HNWD  ; Print address in hexadecimal
; Print spaces to separate address from data.
                mcall MC_CONW_SPC
                mcall MC_CONW_SPC
; Write data in hex.                
                pop hl              ; Fetch address
                push hl
                push bc             ; Save counters
; For each byte, display either data or spaces according to the number
; of bytes left.
cd_hex_lp       ld a, c
                and a
                jr nz, cd_hex_gotdata
; No data left. Print spaces instead.
                mcall MC_CONW_SPC
                mcall MC_CONW_SPC
                jr cd_hex_bydn
; Display byte
cd_hex_gotdata  ld a, (hl)
                mcall MC_CONW_HNBY  ; Print in hex
                dec c               ; Reduce displayed data counter
; Spaces or hex printed. Display a separator.
cd_hex_bydn     mcall MC_CONW_SPC
                inc hl
                djnz cd_hex_lp      ; Loop for all bytes in a row
; Hex-ASCII separator
                mcall MC_CONW_SPC
                ld a, '|'
                mcall MC_CONW_CH
; Write data in ASCII.
                pop bc              ; Restore counters
                pop hl              ; Restore address
; For each byte, display either the character or a space according to the
; number of bytes left.
cd_asc_lp       ld a, c
                and a
                jr nz, cd_asc_gotdata
; No data left. Print a space instead.
                mcall MC_CONW_SPC
                jr cd_asc_bydn
; Display byte      
cd_asc_gotdata  ld a, (hl)
                push bc             ; Save counters
                ld c, '.'           ; Substitution character
                mcall MC_CONW_VIS ; Print visible characters only
                pop bc              ; Restore counters
                dec c               ; Reduce displayed data counter
                dec de              ; Count bytes displayed overall
cd_asc_bydn     inc hl
                djnz cd_asc_lp
; Separator
                ld a, '|'
                mcall MC_CONW_CH
                mcall MC_CONW_NLN ; End of line
                jr cd_line_lp       ; Do next line
;               
cd_done         pop hl              ; Discard address
                ret
;
;
; Disassemble an area of memory.
; Command format:
; disassemble [<start addr>] [<length>]
; start addr defaults to the current PC if not specified.
; length defaults to 0x0010 if not specified.
cmd_disassemble mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                jr nc, cdi_operands
; No operands, so the next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
; Set default address (PC) and length.
                ld hl, (user_sp)
                ld e, (hl)
                inc hl
                ld d, (hl)
                push de             ; Save starting address
                jr cdi_def_len      ; Use default length
;
; We have at least one operand (the address).
cdi_operands    push de             ; Save starting address
                mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch length
                push af             ; Save carry flag
                mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                pop af
                jr nc, cdi_got_len
cdi_def_len     ld de, 0x0010       ; Use default length
cdi_got_len     pop hl              ; Put address in HL
; HL - address
; DE - length
cdi_line_lp     call diproc         ; Disassemble instruction to intermediate form
                call diprnt         ; Print the result
                mcall MC_CONW_NLN   ; New line
                dec de
                ld a, d
                or e
                jr nz, cdi_line_lp
                ret
;
;
; Write data to memory
; Command format:
; write <addr> <data1> [<data2> <data3> ...]
cmd_write       mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                jp c, cmd_op_error  ; Address is required              
                ld bc, 0            ; Reset byte count
; HL - address in command buffer
; DE - memory address
; BC - byte counter
cwr_byte_lp     push bc             ; Save byte count
                push de             ; Save memory address
                mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch byte
                jr c, cwr_done      ; Exit it no valid number remains
                ld a, d
                and a
                jp nz, cmd_op_error ; Error if value > 8 bits
                ld a, e
                ex de, hl           ; Save command pointer to de
                pop hl              ; Restore memory address
                ld (hl), a          ; Write data to memory
                inc hl
; DE - address in command buffer
; HL - memory address
                ex de, hl           ; Swap pointers
                pop bc              ; Restore byte count
                inc bc              ; Count bytes
                jr cwr_byte_lp
; The next thing in the command buffer should be the terminator.
cwr_done        mcall MC_SKIP_SPCS  ; Skip spaces
                xor a
                cp (hl)
                jp nz, cmd_op_error
; Write number of bytes written.
                inc sp              ; Discard memory address
                inc sp
                pop hl              ; Restore byte count
                mcall MC_CONW_HNWD    ; Print number of bytes written
                ld hl, cwr_bytes_msg
                mcall MC_CONW_STR   ; Print message
                ret
;
;
; Read a single memory location
; Command format:
; read <addr>
cmd_read        mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                jp c, cmd_op_error  ; Address is required              
; HL - address in command buffer
; DE - memory address
; The next thing in the command buffer should be the terminator.
                mcall MC_SKIP_SPCS  ; Skip spaces
                xor a
                cp (hl)
                jp nz, cmd_op_error
                ex de, hl
; HL - memory address
                ld a, (hl)          ; Do the fetch
                mcall MC_CONW_HNBY    ; Print result
                jp cwnwln           ; New line and exit
;
;
; Read an I/O location
; Command format:
; in <addr>
cmd_in          mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                jp c, cmd_op_error  ; Address is required              
; HL - address in command buffer
; DE - I/O address
; The next thing in the command buffer should be the terminator.
                mcall MC_SKIP_SPCS  ; Skip spaces
                xor a
                cp (hl)
                jp nz, cmd_op_error
                ld a, d
                and a
                jp nz, cmd_op_error ; Error if not an 8-bit address
                ld c, e
                in a, (c)
                mcall MC_CONW_HNBY    ; Print result
                jp cwnwln           ; New line and exit
;
;
; Write data to I/O
; Command format:
; out <addr> <data1> [<data2> <data3> ...]
cmd_out         mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                jp c, cmd_op_error  ; Address is required              
                ld a, d
                and a
                jp nz, cmd_op_error ; Error if not an 8-bit address
                ld bc, 0            ; Reset byte count
; HL - address in command buffer
; E - I/O address
; C - byte counter
cout_byte_lp    push bc             ; Save byte count
                push de             ; Save I/O address
                mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch byte
                jr c, cout_done     ; Exit it no valid number remains
                ld a, d
                and a
                jp nz, cmd_op_error ; Error if value > 8 bits
                ld a, e
                pop de              ; Restore I/O address
                ld c, e
                out (c), a          ; Write data to I/O
                inc e
                pop bc              ; Restore byte count
                inc bc              ; Count bytes
                jr cout_byte_lp
; The next thing in the command buffer should be the terminator.
cout_done       mcall MC_SKIP_SPCS  ; Skip spaces
                xor a
                cp (hl)
                jp nz, cmd_op_error
; Write number of bytes written.
                inc sp              ; Discard memory address
                inc sp
                pop hl              ; Restore byte count
                mcall MC_CONW_HNWD    ; Print number of bytes written
                ld hl, cwr_bytes_msg
                mcall MC_CONW_STR   ; Print message
                ret
;
;
; Display or change the memory mapping. With no operands, the command
; displays the current state, for example:
; 0 (0000 - 3fff): 3f writeable supervisor
; 1 (4000 - 7fff): 00 read only
; 2 (8000 - bfff): 01 read only
; 3 (c000 - ffff): 02 writeable
; To change the mapping, use:
; map <register> <page> [<prot>] [<super>]
cmd_map         mcall MC_SKIP_SPCS  ; Skip spaces
                xor a
                cp (hl)
                jr z, cm_display    ; No operand, so display map
; Something follows the command. This should be a bank number
                mcall MC_READ_HWD   ; Fetch bank number
                jp c, cmd_op_error
                ld a, d
                and a
                jp nz, cmd_op_error ; MS byte should be zero
                ld a, e
                cp MMAP_BANKS
                jp nc, cmd_op_error ; Error if too big
                ld b, e             ; Save for later
; Read page.
                mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch page
                jp c, cmd_op_error
                ld a, d
                and a
                jp nz, cmd_op_error ; MS byte should be zero
                ld a, e
                cp MMAP_PAGES
                jp nc, cmd_op_error ; Error if too big
; HL - address in command buffer
; E - new RAM page
; B - bank number
; Loop, reading operands and collating the options. Repeating options
; is permitted (though not useful).
cm_op_loop      mcall MC_SKIP_SPCS  ; Skip spaces
                xor a
                cp (hl)
                jr z, cm_ops_done   ; Jump if no more operands
; Match next operand against list of options.
                push de             ; Save page
                ld de, cm_op_list
                mcall MC_MAT_WORD
                pop de
                and a
                jp z, cmd_op_error
; 1 = prot, 2 = super.
                rrca                ; Rotate to MS bits
                rrca
                or e                ; Combine with page
                ld e, a
                jr cm_op_loop
; All operands have been read.
; E - new RAM page with PROT and SUPER bits
; B - bank number
; Now calculate I/O address
cm_ops_done     ld a, b
                add IOA_MMAP_0
                ld c, a
                ld a, e
                out (c), a          ; Set mapping
                ret
;
; Display the current mapping. 
cm_display      ld b, 0             ; Bank count
cm_regloop      ld a, b
                mcall MC_CONW_HNIB  ; Print bank as a nibble
                mcall MC_CONW_SPC   ; Print a space
                ld a, '('
                mcall MC_CONW_CH
                ld a, b             ; Calculate start address
                rrca                ; Rotate to MS bits
                rrca
                ld h, a
                ld l, 0
; Now hl is the base address as required.
                push hl             ; Save it
                mcall MC_CONW_HNWD  ; Print address in hexadecimal
                ld hl, cm_range_msg ; Indicate range
                mcall MC_CONW_STR   ; Print message
                pop hl              ; Fetch base address
                ld de, MMAP_PAGE_SIZE - 1
                add hl, de
                mcall MC_CONW_HNWD  ; Print address in hexadecimal
; Separator
                ld a, ')'
                mcall MC_CONW_CH
                ld a, ':'
                mcall MC_CONW_CH
                mcall MC_CONW_SPC
; Calculate I/O address
                ld a, b
                add IOA_MMAP_0
                ld c, a
                in a, (c)           ; Fetch
; This data actually comes from the shadow registers in the FPGA as the 74ls670
; register arrays are not readable in ZARC.
                ld c, a             ; Save it for later
                and 0x3f            ; Isolate address
                mcall MC_CONW_HNBY    ; Print page number in hexadecimal
; Write "writeable" or "read only" as appropriate.
                ld hl, cm_write_msg
                bit MMAP_PROT_BIT, c
                jr z, cm_prot_pmsg
                ld hl, cm_ro_msg
cm_prot_pmsg    mcall MC_CONW_STR   ; Print message
; Write "supervisor" if appropriate.
                bit MMAP_SUPER_BIT, c
                jr z, cm_regdn
                ld hl, cm_super_msg
                mcall MC_CONW_STR   ; Print message
cm_regdn        mcall MC_CONW_NLN   ; New line
                inc b
                ld a, b
                cp MMAP_BANKS
                jr c, cm_regloop    ; Loop for all banks
                ret
;
;
; Enable interrupts. This has the following effects:
; 1) Changes the way console I/O works, ensuring interrupts can run while waiting
;    for I/O.
; 2) Allows the tick interrupt to maintain the current time, which speeds up reading
;    the time emormously.
cmd_ei          mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                call itstrt         ; Start monitor interrupts
                ret
;
;
; Display system information.
cmd_info        mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
; FPGA firmware version
                ld hl, ci_fpga_rev_msg  ; "FPGA revision: "
                mcall MC_CONW_STR   ; Print message
                in a, (IOA_FPGA_MAJREV) 
                mcall MC_CONW_HNBY      ; Print byte in hexadecimal
                ld a, '.'
                mcall MC_CONW_CH 
                in a, (IOA_FPGA_MINREV) 
                mcall MC_CONW_HNBY      ; Print byte in hexadecimal
; Total RAM in system
                ld hl, ci_ram_msg       ; "Total RAM: "
                mcall MC_CONW_STR       ; Print message
; Note - "+" is required to prevent this being misinterpreted as an indirect load.
                ld hl, +((MMAP_PAGE_SIZE /1024) * MMAP_PAGES)
                mcall MC_CONW_DNWD      ; Print size in decimal
; CPU speed
                ld hl, ci_cpuspd_msg    ; "CPU clock: "
                mcall MC_CONW_STR       ; Print message
                ld hl, (cpu_speed_khz)
                mcall MC_CONW_DNWD      ; Print size in decimal
                ld hl, ci_khz_msg       ; " KHz"
                mcall MC_CONW_STR       ; Print message
; Monitor start count
                ld hl, ci_mon_cnt_msg   ; "Monitor starts: "
                mcall MC_CONW_STR       ; Print message
                ld hl, (mon_start_count)
                mcall MC_CONW_DNWD      ; Print reset counter in decimal
;
                mcall MC_CONW_NLN ; New line
                ret
;
;
; Test an area of memory, or all of it if the operand is "all".
; The test itself uses mapping register 1 (4000 - 7fff) to address
; each page in turn. The two pages used for the monitor are not tested.
; This is a very distructive test, as it writes over all but the monitor
; pages (32 kB in all).
cmd_memtest     xor a
                ld (cm_err_flag), a ; Reset error counter
                mcall MC_SKIP_SPCS  ; Skip spaces
                ld a, 'a'
                cp (hl)
                jr z, cm_test_all   ; Jump if test all
; Not "all", so look for address and length.
                mcall MC_READ_HWD   ; Fetch address
                jp c, cmd_op_error  ; Address is required
                push de             ; Save starting address
                mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch length
                jp c, cmd_op_error  ; Address is required
                mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                ld b, d             ; Move length to BC
                ld c, e
                pop hl
; HL - start address
; BC - length
; Pass / fail is reported by the test code, so no need to check the error code.
                jp memtst
;
; Test all memory.
; First check the operand is really "all".
cm_test_all     inc hl
                ld a, 'l'
                cp (hl)
                jp nz, cmd_op_error
                inc hl
                cp (hl)
                jp nz, cmd_op_error
                inc hl
                xor a
                cp (hl)
                jp nz, cmd_op_error
; Ask for confirmation as the test is very destructive.
                ld hl, cmd_conf_msg
                mcall MC_CONW_STR   ; Print "Confirm" message
                mcall MC_CONR_CH    ; Fetch next character from user
                push af
                mcall MC_CONW_CH    ; Echo the response
                mcall MC_CONW_NLN   ; Write new line characters to console
                pop af
                cp 'y'
                ret nz              ; Exit unless confirmed
; Pass / fail is reported by the test code, so no need to check the error code.
                jp  memtal
;
;
;
; Read or write to / from the real time clock.
cmd_time        mcall MC_SKIP_SPCS      ; Skip spaces
                ld a, 's'
                cp (hl)
                jp z, ct_set            ; Jump if set time
; Not "set", so display current time.
temp_loop       mcall MC_TIM_READ       ; Read current time and date
                and a
                jr z, ct_rtcreadok
; RTC read error
                mcall MC_CONW_HNBY      ; Print error code in hex
                mcall MC_CONW_NLN       ; New line
                ret
;
; 32-bit time is in DEHL.
ct_rtcreadok    ld ix, time_tm
                mcall MC_TIM_INTTOTM    ; Convert integer time to TM structure
;
; Display the structure in the form:
; <day of week> <day>/<month>/<year> <hours>:<minutes>:<seconds>
                ld ix, time_tm
                mcall MC_TIM_CONWRTM    ; Print time structure to console
;
                mcall MC_CONW_NLN       ; New line
                ret
;
; Set time
ct_set          ld b, 0x5F
                ld c, 0x24
                ld d, 0x0E
                ld e, 0xC8
                mcall MC_TIM_SET        ; Set time and date
                and a
                ret z                   ; Return if write was OK
; Something went wrong.
                mcall MC_CONW_HNBY      ; Print error code in hex
                mcall MC_CONW_NLN       ; New line
                ret
;
;
; Run the stage 1 serial bootloader (the one normally entered from the front
; panel. This allows the monitor to be downloaded again. A crude check is
; made to verify that the bootloader has not been overwritten. This is a
; simple binary download, with all received characters being written to RAM
; starting at address zero. There is no form of checksum or other verification.
; Termination is by reset from the front panel.
cmd_mon_dl      mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
; No operands, as expected.
                di                  ; Interrupts may confuse things
                ld hl, 0x3fe0       ; Boot loader start address
                ld a, (hl)
                cp 0x3e
                ret nz              ; Ignore if corrupt (crude check)
                jp (hl)
;
;
; Binary download from the console port. This is useful for downloading
; raw binary files to the address specified. This is similar to the monitor
; download, but it allows an arbrary address as destination. It is up to the
; user to make sure that the destination is writeable. Command format:
; bindownload <addr>
cmd_bin_dl      mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                jp c, cmd_op_error  ; Address is required              
                mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                ex de, hl
; HL - specified address
; The following code is similar to that of the stage 1 serial
; bootloader, with all of the restrictions that implies. Termination is by
; reset or NMI from the front panel.
cbd_loop        mcall MC_CONR_CH    ; Fetch next character from user
                ld (hl), a
                inc hl
                jr cbd_loop         ; Load data until reset or NMI
;
; Initialise console I/O in basic (no interrupts) mode.
con_init_basic  call itinit         ; Initialise and set basic I/O mode
;
; Write some nulls to initialise console output.
                ld b, 10
init_null_lp    xor a
                mcall MC_CONW_CH
                djnz init_null_lp
                ret
;
; Set bank 0 to read/write mode to vectors etc. can be changed.
mmap_page0_rw   ld a, MMAP_MON_PAGE0 + MMAP_SUPER_MASK
                out (IOA_MMAP_0), a
                ret
;
; Set bank 0 to read only mode to prevent accidental writes.
mmap_page0_ro   ld a, MMAP_MON_PAGE0 + MMAP_PROT_MASK + MMAP_SUPER_MASK
                out (IOA_MMAP_0), a
                ret
;
;
; Initialise memory card.
cmd_mc          mcall MC_SKIP_SPCS  ; Skip spaces
                xor a
                cp (hl)
                jp nz, cmd_op_error
;
                call mcinit
                and a
                ret z
; Print error code
                call mcprer         ; Print memory card error text
                ret
;
;
; Call user code, using the current PC or a specified address.
; Command format:
; go [<addr>]
cmd_go          mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                push af             ; Save carry flag
                mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                pop af
                jr c, cg_no_new_addr
; DE - new address
                ld hl, (user_sp)
                ld (hl), e
                inc hl
                ld (hl), d
cg_no_new_addr  xor a               ; Flag normal run (not trace)
                jp run_user_code
;
;
; Call user code for one instruction (single step). If an address is specified, the
; trace is repeated until that address is reached. Command format:
; trace [<addr>]
cmd_trace       mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch address
                push af             ; Save carry flag
                mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                pop af
                jr c, ct_no_addr
; DE - new address
                ld a, 2             ; Flag trace to address required
                jp run_user_code
ct_no_addr      ld a, 1             ; Flag single trace required
                jp run_user_code
;
;
; Set register to supplied. Command format:
; set <reg> <value>
; "ien" isn't actually a register, but is used here to control the interrupt enable.
cmd_set         mcall MC_SKIP_SPCS  ; Skip spaces
; Match operand against list of options.
                ld de, reg_names
                mcall MC_MAT_WORD
                and a
                jp z, cmd_op_error  ; Jump if unknown register
                dec a               ; Start index from zero
                ld c, a             ; Save index
; Read value
                mcall MC_SKIP_SPCS  ; Skip spaces
                mcall MC_READ_HWD   ; Fetch value
                push af             ; Save carry flag
                mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
                pop af
                jp c, cmd_op_error
; C - register name index
; DE - value
                ld a, c
; Some registers require special processing.
                cp 18
                jr nz, cs_not_ien
; Set interrupt enable. Only 0 and 1 is valid in this case.
                ld a, d
                and a
                jp nz, cmd_op_error ; Error if value was too big
                ld a, e
                cp 2
                jp nc, cmd_op_error ; Error if value was too big
; Move to bit 2 (P/V flag).
                add a
                add a
                ld hl, XPT_STACK_TOP - 23
                ld (hl), a
                ret
cs_not_ien      cp 25
                jr nz, cs_not_pc
; Set PC
                ld hl, (user_sp)
                ld (hl), e
                inc hl
                ld (hl), d
                ret
cs_not_pc       cp 26
                jr nz, cs_not_sp
; Set stack pointer.
                ld (user_sp), de
                ret
; For all other registers, index a table to find the offsets and length.
cs_not_sp       ld hl, reg_offsets
                ld b, 0
                add hl, bc
                ld a, (hl)
                push af
; Find the address for the register.
                and 0x7f            ; Remove 16-bit flag
                ld hl, XPT_STACK_TOP - 23   ; Point to last entry of saved context
                add a, l
                ld l, a
                ld a, h
                adc 0
                ld h, a
                pop af
; A (bit 7) - 16-bit value flag
; C - register name index
; DE - value
; HL - pointer to register in exception stack
                and 0x80
                jr nz, cs_16bit
                ld a, d
                and a
                jp nz, cmd_op_error ; Error if value was too big
                ld (hl), e
                ret                 ; Command complete
; 16-bit register set.
cs_16bit        ld (hl), e
                inc hl
                ld (hl), d
                ret                 ; Command complete
;
;
; Display saved registers (user context)
cmd_registers   mcall MC_SKIP_SPCS  ; Skip spaces
; The next thing in the command buffer should be the terminator.
                xor a
                cp (hl)
                jp nz, cmd_op_error
; No operands, as expected.
                jp disp_regs        ; Display registers and return
;
;
; Switch context to user code. Call with:
; A - trace mode (0 - none, 1 - single, 2 - trace to DE)
; DE - trace until address (relevant when A = 2 only)
run_user_code   ld (trace_mode), a
                ld (trace_addr), de
ru_keep_going   ld sp, XPT_STACK_TOP - 23   ; Point to last entry of saved context
                pop af
                ld r, a             ; R isn't really useful as it will have changed.
                pop af
                ld i, a
; Enable interrupts if the saved IEn (in P/V flag) is set.
                di
                jp po, ru_int_done
                ei
ru_int_done     pop iy
                pop ix
                pop hl              ; Alternate registers
                pop de
                pop bc
                pop af
                ex af, af'
                exx
                pop hl              ; Conventional registers
                pop de
                pop bc
                pop af
                ld sp, (user_sp)    ; Store user SP
; Set trace interrupt if requested.
                push af
                ld a, (trace_mode)
                and a
                jr z, ru_tr_done
; Arm the trace NMI (and keep memory mapping enabled).
                ld a, SYSCTRL_MMAP_MASK + SYSCTRL_TRARM_MASK
                out (IOA_CONTROL), a
ru_tr_done      pop af
                ret
;
;
; Set RST vector to point to a new service routine.
; Call with:
; A - RST number of vector to change (0x08, 0x10, 0x18 ... 0x38)
; DE - points to the new service routine
; Returns with:
; C flag - set on error (invalid vector number)
utrivc          push hl
                ld l, a             ; Save vector number
                and 0xc7
                jr nz, srvec_err
                ld a, l
; Calculate vector address
                ld hl, Z80_RST00_VEC
                add l
                ld l, a
; HL - vector address
                ld (hl), 0xc3       ; Jump instruction
                inc hl
                ld (hl), e          ; LS byte of address
                inc hl
                ld (hl), d          ; MS byte of address
; Successful return
                pop hl
                and a
                ret                 ; Return with carry flag reset (OK)
; Error
srvec_err       pop hl
                scf
                ret                 ; Return with carry flag set (error)
;
;               
; Default RST handlers. RST 08 is used by the monitor, so has no entry here.
default_rst10   push af
                ld a, 0
                jr def_except_hdlr
;
default_rst18   push af
                ld a, 1
                jr def_except_hdlr
;
default_rst20   push af
                ld a, 2
                jr def_except_hdlr
;
default_rst28   push af
                ld a, 3
                jr def_except_hdlr
;
default_rst30   push af
                ld a, 4
                jr def_except_hdlr
;
default_rst38   push af
                ld a, 5
                jr def_except_hdlr
;
default_nmi     push af
                ld a, 6
                jr def_except_hdlr
;
default_int     push af
                ld a, 7
                jr def_except_hdlr
;
;
; System error! Halt the system to prevent further damage. Call this routine
; in case of a serious error. This is treated as any other exception, the
; stack looks the same in any case. Note: call is preferred (rather than jump)
; as it preserves the PC.
panic           push af
                ld a, 8
                jr def_except_hdlr
;
;
; Default exception handler. Care is taken to preserve the registers.
; AF is on the stack, and A contains the exception ID number.
; A separate stack space is used for exceptions. The reason is that
; the exception may have occurred in the monitor, in which case the
; PC will be on the monitor stack and hence overwritten by the stacking
; operations below.
def_except_hdlr ld (xpt_id), a      ; Store exception ID
                pop af
                ld (user_sp), sp    ; Store user SP
                ld sp, XPT_STACK_TOP + 1    ; Use exception stack space
                push af
                push bc
                push de
                push hl
                ex af, af'
                exx
                push af             ; Alternate registers
                push bc
                push de
                push hl
                push ix
                push iy
                ld a, i
                push af             ; Save I and IEn (in P/V flag)
                ld a, r
                push af             ; Save R and IEn (in P/V flag)
; R isn't really useful as it will have changed. Note that this method of
; determining the interrupt enable status is not completely reliable for
; NMOS Z80s. However, it is good for CMOS ones, such as that used in ZARC.
; Switch to the monitor's operating environment.
                di                  ; IEn state is saved, so we can DI here.
; There is a potential issue when an exception occurs when the monitor is running.
; The monitor stack must take care not to overwrite the stack in use when the
; exception occurred. The default monitor stack space is from MON_STACK_TOP to
; MON_STACK_BOT. This is larger than the space normally allocated to stacks to
; ensure space can always be found for the monitor stack.
                ld hl, (user_sp)
                ld de, MON_STACK_TOP
                and a
                sbc hl, de
; We will have no carry if user_sp >= MON_STACK_TOP. This means the address of the
; item on the top of the stack is actually outside of the monitor stack space.
                jr nc, xpt_defstk   ; Jump if user_sp >= MON_STACK_TOP
; user_sp < MON_STACK_TOP
                ld hl, (user_sp)
                inc hl              ; Find address of top item
                ld de, MON_STACK_BOT
                and a
                sbc hl, de
; If this carries, the top item on the user stack is outside of the monitor stack
; space. There may or may not be data on the user stack inside of this space,
; however. In any case, we can use the top of the monitor stack space for the
; monitor.
                jr c, xpt_defstk    ; Jump if user_sp < MON_STACK_BOT
; HL - user stack data offset into monitor stack space.
; The user stack is within the monitor's stack space. Calculate a location that
; won't overwrite it.
                ld de, STACKS_SIZE
                and a
                sbc hl, de
; If this carries, user_sp is close the the bottom of the monitor stack space. In
; this case, we can use the top (the default location).
                jr c, xpt_defstk
; There is space for a stack below user_sp in the monitor's stack space.
                ld hl, (user_sp)
                jr xpt_set_sp
;
; The user stack is not in the default stack space, so we are safe to use that.
xpt_defstk      ld hl, MON_STACK_TOP + 1    ; Use default stack
xpt_set_sp      ld (mon_sp), hl
                ld sp, hl
; Is this a trace interrupt? If so, the behaviour is different.
                ld a, (xpt_id)      ; Fetch exception ID
                cp 6
                jr nz, xpt_disp_reason
; The exception is an NMI, so it could be a trace.
                in a, (IOA_NMI_REASONS)
                and NMI_REASONS_ALL
                cp NMI_TRACE_MASK
                jr nz, xpt_disp_reason
; Trace interrupt (only). If we are in "trace to address" mode, we should keep going
; unless we are at the required address.
                ld a, (trace_mode)
                cp 2
                jr nz, xpt_disp_reason  ; Jump unless "trace to address" mode
                ld de, (trace_addr)
                ld hl, (user_sp)
                ld a, e
                cp (hl)
                jp nz, xpt_tr_notyet
                inc hl
                ld a, d
                cp (hl)
                jp nz, xpt_tr_notyet
; Display the reason for the exception.
xpt_disp_reason call con_init_basic ; Initialise console I/O in basic mode
                ld hl, xpt_pre_msg
                mcall MC_CONW_STR   ; Print "*** " message
                ld hl, xpt_desc_msgs
                ld a, (xpt_id)      ; Fetch exception ID
                ld c, "|"           ; Separator
                mcall MC_CONW_MSGN  ; Print message <n> in a list
                ld a, (xpt_id)      ; Fetch exception ID
                cp 6
                jr nz, xpt_notnmi
; Display reason(s) for the NMI. There may be more than one reason, for example
; a trace with a front panel switch operation.
                in a, (IOA_NMI_REASONS)
                ld c, a
                ld hl, xpt_sw_msg   ; "(front panel)" message
                bit NMI_SWITCH_BIT, c
                call nz, conwms
                ld hl, xpt_prot_msg ; "(write protection)" message
                bit NMI_PROT_VIOL_BIT, c
                call nz, conwms
                ld hl, xpt_super_msg ; "(not supervisor)" message
                bit NMI_SUPER_VIOL_BIT, c
                call nz, conwms
                ld hl, xpt_trace_msg ; "(trace [single step])" message
                bit NMI_TRACE_BIT, c
                call nz, conwms
; Reset all reason bits. This will release the NMI signal and hence turn off the
; NMI LED on the front panel.
                ld a, NMI_REASONS_ALL
                out (IOA_NMI_REASONS)
xpt_notnmi      ld hl, xpt_post_msg
                mcall MC_CONW_STR   ; Print " ***" message
                call disp_regs
                jp init             ; Initialise monitor, stack etc.
;
; Go here if in trace to address mode, and this isn't the required address.
xpt_tr_notyet   ld a, NMI_REASONS_ALL
                out (IOA_NMI_REASONS)   ; Reset NMI reasons to release NMI signal
                jp ru_keep_going
;
;
; Display all registers. The result will look something like this:
; A: xx, F: SZ.H.VNC, BC: xxxx, DE: xxxx, HL: xxxx,
; A': xx, F': SZ.H.VNC, BC': xxxx, DE': xxxx, HL': xxxx,
; PC: xxxx, SP: xxxx, IX: xxxx, IY: xxxx, I: xx, R: xx, IEn: x
; Note that this routine does not preserve any registers.
disp_regs       ld de, XPT_STACK_TOP + 1    ; Point to first saved entry
                ld hl, xpt_regs_msg ; Associated text
                call dr_reg_set     ; Display AF, BC, DE and HL
                call dr_reg_set     ; Display alternate set
; PC
                push de
                ld de, (user_sp)
                inc de              ; Point to high byte of PC
                inc de
                call dr_16          ; Display and update pointers  
; SP
                mcall MC_CONW_STR   ; Print next part of text
                push hl
                ld hl, (user_sp)
                mcall MC_CONW_HNWD  ; Print word
                pop hl
                inc hl              ; Skip terminator
                pop de              ; Restore pointer to stacked registers
; IX
                call dr_16          ; Display and update pointers
; IY
                call dr_16          ; Display and update pointers
; I
                call dr_8           ; Display and update pointers
                dec de              ; Step past flags
; R - actually pretty meaningless, but for completeness.
                call dr_8           ; Display and update pointers
; The flags associated with this contain P/V, and hence the interrupt enable
; state.
                mcall MC_CONW_STR   ; Print next part of text
                dec de
                ld a, (de)
                rrca                ; Move P/V to bit 0
                rrca
                and 1               ; Remove extraneous bits
                mcall MC_CONW_HNIB  ; Print as a nibble
                mcall MC_CONW_NLN   ; Write new line characters to console
                ret
;
; Display AF, BC, DE and HL. This is called by the exception handling code
; for both normal and alternate register sets.
; Call with:
; HL - points to next message text
; DE - points to next register on stack
; Returns with:
; HL - points to next message text
; DE - points to next register on stack
; A register
; BC register is not preserved.
dr_reg_set      call dr_8           ; Display A register
; Flags
                mcall MC_CONW_STR   ; Print next part of text
                dec de              ; Point to next item on stack
                ex de, hl
                ld a, (hl)
                and 11010111b       ; Mask out "not used" flags
                ld c, a
; Write flags state.
                ld b, 8
                push hl             ; Save register data pointer
                ld hl, dr_flg_names ; Point to list of flag names (letters)
; B - bit counter
; C - flags register
; HL - pointer to names
; DE - pointer to message text
dr_flg_loop     rl c                ; Rotate next bit into carry
                jr nc, dr_flg_done
; Flag is set, so write its name
                ld a, (hl)
                mcall MC_CONW_CH    ; Write character
dr_flg_done    inc hl
                djnz dr_flg_loop
; Flags written
                pop hl              ; Restore register data pointer
                ex de, hl
                inc hl              ; Step past message terminator
; Now do BC, DE and HL.
                ld b, 3
dr_lp           call dr_16
                djnz dr_lp
                ret
;
; Display an 8-bit register in hexadecimal with associated text.
; This is called by the exception handling code.
; Call with:
; HL - points to next message text
; DE - points to next register on stack
; Returns with:
; HL - updated message pointer (i.e. incremented)
; DE - updated register pointer (i.e. decremented)
dr_8            mcall MC_CONW_STR   ; Print next part of text
                dec de              ; Point to next item on stack
                ex de, hl
                ld a, (hl)
                mcall MC_CONW_HNBY  ; Print byte
                ex de, hl
                inc hl              ; Step past message terminator
                ret
;
; Display a 16-bit register in hexadecimal with associated text.
; This is called by the exception handling code.
; Call with:
; HL - points to next message text
; DE - points to next register on stack
; Returns with:
; HL - updated message pointer (i.e. incremented)
; DE - updated register pointer (i.e. decremented twice)
dr_16           mcall MC_CONW_STR   ; Print next part of text
                dec de              ; Point to next item on stack
                ex de, hl
                ld a, (hl)          ; High byte
                mcall MC_CONW_HNBY  ; Print byte
                dec hl
                ld a, (hl)          ; Low byte
                mcall MC_CONW_HNBY  ; Print byte
                ex de, hl
                inc hl              ; Step past message terminator
                ret
;
;
; The monitor uses RST 08 to call some functions. The byte following identifies
; the function required. This provides a standardised entry point for use by other
; programs. All registers are preserved except IX.
mcall_entry     ex (sp), hl
; HL points to the function code.
                ld (cm_a), a        ; Save A without disturbing SP   
; Fetch function code and fix stack
                ld a, (hl)
                inc hl
                ex (sp), hl         ; Update return address on stack
                cp MCALL_FUNC_CNT
                call nc, panic      ; System panic on illegal function
; Save more registers without disturbing SP
                ld (cm_bc), bc
                ld (cm_hl), hl
; Index the table to find the function address.
                ld hl, mcall_table  ; Table of function addresses
                add a               ; Table entries are two bytes long
; Add offset to base address in hl.
                add l
                ld l, a
                ld a, 0             ; Zero A without resetting carry
                adc a, h            ; Propagate carry to high byte
                ld h, a
; HL points to the required table entry.
                ld c, (hl)          ; Fetch entry point
                inc hl
                ld b, (hl)
; BC contains the address of the service routine.
                push bc             ; Set as "return" address
                ld a, (cm_a)        ; Restore registers
                ld bc, (cm_bc)
                ld hl, (cm_hl)
                ret
;
;
; *************
; * Constants *
; *************
;
signon_msg      byte 0x0d, 0x0a, 0x0d, 0x0a, "ZARC Monitor V0.1", 0x0d, 0x0a, 0
cold_start_msg  byte 0x0d, 0x0a, "*** Cold start ***", 0
cmd_prompt      byte "> ", 0
; The ordered list of commands in cmd_list corresponds to the list of vectors
; in cmd_vectors.
cmd_list        byte "help dump read write in out map ei info memtest mondownload "
                byte "bindownload time mc go trace set registers disassemble", 0
cmd_vectors     word cmd_help, cmd_dump, cmd_read, cmd_write, cmd_in, cmd_out, cmd_map
                word cmd_ei, cmd_info, cmd_memtest, cmd_mon_dl, cmd_bin_dl, cmd_time
                word cmd_mc, cmd_go, cmd_trace, cmd_set, cmd_registers, cmd_disassemble
cmd_bad_msg     byte "Bad command", 0x0d, 0x0a, 0
cmd_op_err_msg  byte "Operand error", 0x0d, 0x0a, 0
cmd_conf_msg    byte "Confirm (y/n): ", 0
;
; Default exception handler messages
xpt_pre_msg     byte 0x0d, 0x0a, "*** ", 0
xpt_desc_msgs   byte "RST10|RST18|RST20|RST28|RST30|RST38|"
                byte "NMI|Uninitialised INT|System panic", 0
xpt_sw_msg      byte " (front panel)", 0
xpt_prot_msg    byte " (write protection)", 0
xpt_super_msg   byte " (not supervisor)", 0
xpt_trace_msg   byte " (trace [single step])", 0
xpt_post_msg    byte " ***", 0x0d, 0x0a, 0
xpt_regs_msg    byte "A: ", 0
                byte ", F: (", 0
                byte "), BC: ", 0
                byte ", DE: ", 0
                byte ", HL: ", 0
                byte 0x0d, 0x0a, "A': ", 0
                byte ", F': (", 0
                byte "), BC': ", 0
                byte ", DE': ", 0
                byte ", HL': ", 0
                byte 0x0d, 0x0a, "PC: ", 0
                byte ", SP: ", 0
                byte ", IX: ", 0
                byte ", IY: ", 0
                byte ", I: ", 0
                byte ", R: ", 0
                byte ", IEn: ", 0
dr_flg_names   byte "SZ.H.VNC"
;
help_msg        byte "help", 0x0d, 0x0a
                byte "dump <start addr> [<length>]", 0x0d, 0x0a
                byte "disassemble [<start addr>] [<length>]", 0x0d, 0x0a
                byte "read <addr>", 0x0d, 0x0a
                byte "write <addr> <data1> [<data2> <data3> ...]", 0x0d, 0x0a
                byte "in <addr>", 0x0d, 0x0a
                byte "out <addr> <data1> [<data2> <data3> ...]", 0x0d, 0x0a
                byte "map [<bank> <page> [<prot>] [<super>]]", 0x0d, 0x0a
                byte "ei", 0x0d, 0x0a
                byte "info", 0x0d, 0x0a
                byte "memtest [<all>] | [<addr> <len>]", 0x0d, 0x0a
                byte "mondownload", 0x0d, 0x0a
                byte "bindownload <addr>", 0x0d, 0x0a
                byte "time <TBD>", 0x0d, 0x0a
                byte "mc <TBD>", 0x0d, 0x0a
                byte "go [<addr>]", 0x0d, 0x0a
                byte "trace [<addr>]", 0x0d, 0x0a
                byte "set <reg> <value>", 0x0d, 0x0a
                byte "registers", 0x0d, 0x0a
                byte 0
;
cwr_bytes_msg   byte " bytes written", 0x0d, 0x0a, 0
cm_range_msg    byte " - ", 0
cm_write_msg    byte " writeable", 0
cm_ro_msg       byte " read only", 0
cm_super_msg    byte ", supervisor", 0
cm_op_list      byte "super prot", 0
ci_fpga_rev_msg byte "FPGA revision: ", 0
ci_ram_msg      byte 0x0d, 0x0a, "Total RAM: ", 0
ci_cpuspd_msg   byte " KB", 0x0d, 0x0a, "CPU clock: ", 0
ci_khz_msg      byte " KHz", 0
ci_mon_cnt_msg  byte 0x0d, 0x0a, "Monitor starts: ", 0
;
; 8-bit registers for set command. "ien" controls interrupt enable.
reg_names       byte "a f b c d e h l "             ; Index 0 to 7
                byte "a' f' b' c' d' e' h' l' "     ; Index 8 to 15
                byte "i r ien "                     ; Index 16 to 18
                byte "bc de hl "                    ; Index 19 to 21
                byte "bc' de' hl' "                 ; Index 22 to 24
; Special registers (no alternates)
                byte "pc sp ix iy",0                ; Index 25 to 28
;
; A list of offsets into the exception stack for each register. The order must
; match that of reg_names. Bit 7 is set to identify a 16-bit value (rather than
; an 8-bit one). ien, pc and sp entries are placeholders as these are trapped before
; this table is indexed.
reg_offsets     byte 23, 22, 21, 20, 19, 18, 17, 16 ; Index 0 to 7
                byte 15, 14, 13, 12, 11, 10, 9, 8   ; Index 8 to 15
                byte 3, 1, 0                        ; Index 16 to 18
                byte 20 + 0x80, 18 + 0x80, 16 + 0x80    ; Index 19 to 21
                byte 12 + 0x80 , 10 + 0x80, 8 + 0x80    ; Index 22 to 24
                byte 0, 0, 6 + 0x80, 4 + 0x80       ; Index 25 to 28
;
; Table of RST 08 (MCALL) function addresses. This must match the MC_xxx definitions
; in zarc.i.
mcall_table
; From io.z80
                word conwch     ; Write character in A to the console
                word conrch     ; Read character from the console and return it in A
                word i2cwr      ; Write to I2C device
                word i2crd      ; Read from I2C device
; From utility.z80
                word cwnwln     ; Write new line characters to console
                word conwms     ; Print null-terminated string to the console
                word conwmn     ; Print message <n> in a list
                word skpspc     ; Step hl past spaces
                word toupca     ; Convert character in A to upper case
                word cwvich     ; Print only visible 7-bit characters
                word cwpspc     ; Print a space
                word mtwdli     ; Match word in a string against list of options
                word cwphnb     ; Print least-significant nibble in A in hexadecimal
                word cwphby     ; Print A in hexadecimal
                word cwphwd     ; Print HL in hexadecimal
                word cwpdby     ; Print A in decimal. Leading zeros are suppressed.
                word cwpdwd     ; Print HL in decimal. Leading zeros are suppressed.
                word rdhxwd     ; Read a 16-bit hexadecimal number from a string
; From maths.z80
                word mad328u    ; 32-bit / 8-bit unsigned divide
                word mad168u    ; 16-bit / 8-bit unsigned divide
                word mad88u     ; 8-bit / 8-bit unsigned divide
; From interrupts.z80
                word itena      ; Enable interrupts if safe
                word itdis      ; Disable interrupts and keep count
; From time.z80
                word tird       ; Read current time and date
                word tiwr       ; Set time and date
                word tiitos     ; Convert integer time to structure
                word tistoi     ; Convert structure time to integer
                word cwptm      ; Print time structure to console
; Check we have the correct number of entries above.
                 assert ($ - mcall_table) = (MCALL_FUNC_CNT * 2)
;
;
;
; *************
; * Variables *
; *************
;
; Note: linker "-c" option is used, so no data is initialised here.
                dseg                ; Data segment
;
warm_mark1      defs 1              ; Warm start marker 1
;
mon_start_count defs 2              ; Reset counter
cmd_buf         defs CMD_BUF_SIZE   ; Command buffer
cmd_len         defs 1              ; Current command length
cm_err_flag     defs 1              ; Memory test error flag
tikdiv          defs 1              ; Tick divider
cm_a            defs 1              ; Temporary registers store for mcall_entry
cm_bc           defs 2
cm_hl           defs 2
xpt_id          defs 1              ; Exception ID
user_sp         defs 2              ; Exception stack pointer
time_tm         defs TM_SIZE        ; Date / time structure
cpu_speed_khz   defs 2              ; Approximate CPU speed in KHz
trace_mode      defs 1              ; Trace mode (0 - none, 1 - single, 2 - trace to address)
trace_addr      defs 2              ; Trace to address
mon_sp          defs 2              ; Monitor SP
warm_mark2      defs 1              ; Warm start marker 2
;
                end
