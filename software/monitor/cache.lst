   1:				; *******************************************************
   2:				; * Memory Card Cache Routines for ZARC Z80 Computer    *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 23/11/2020                            *
   5:				; *******************************************************
   6:				;
   7:				; Routines associated with the MMC memory card sector cache. The need for this
   8:				; is primarily from the CP/M system, which uses 128-byte sectors. The required
   9:				; blocking and deblocking needs some form of cache. For reading, a single sector
  10:				; would suffice, but writing is more tricky to avoid excess wear on the MMC.
  11:				;
  12:				; This cache uses a number of MMC sector buffers for both read and write.
  13:				; Routines are provided for both MMC and CP/M sized sector reads and writes.
  14:				;
  15:				;
  16:     -	0001'         	monitor         equ 1                   ; Flag part of monitor build
  17:     -	0001'         	cache           equ 1                   ; Flag module for includes
  18:				;
  19:				;
  20:				;
  21:				; ************
  22:				; * Includes *
  23:				; ************
  24:				;
  25:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				
**** cache.z80 ****
  26:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** cache.z80 ****
  27:				                include "zarc.i"        ; Hardware definitions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//zarc.i ****
   1:				; ***********************************
   2:				; * ZARC Definitions                *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 26/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the ZARC system.
   8:				;
   9:				;
  10:				; ************
  11:				; * Hardware *
  12:				; ************
  13:				;
  14:				; Interrupt vector numbers in INT_VEC_TABLE.
  15:				; Address is INT_VEC_TABLE + 2 * vector number).
  16:     -	0000'         	INT_SER1_TX_VEC     equ INT_SER1_TX_BIT ; Serial port 1 transmitter buffer is half full or less
  17:     -	0001'         	INT_SER1_RX_VEC     equ INT_SER1_RX_BIT ; Serial port 1 receiver has data
  18:     -	0002'         	INT_SER2_TX_VEC     equ INT_SER2_TX_BIT ; Serial port 2 transmitter buffer is half full or less
  19:     -	0003'         	INT_SER2_RX_VEC     equ INT_SER2_RX_BIT ; Serial port 2 receiver has data
  20:     -	0004'         	INT_TICK_VEC        equ INT_TICK_BIT    ; Regular timekeeping
  21:				;
  22:     -	0064'         	MS_PER_TICK         equ 100             ; ms per tick
  23:     -	000A'         	TICK_FREQ           equ 10              ; Tick rate in Hz
  24:				;
  25:				
**** cache.z80 ****
  28:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  18:     -	0001'         	                ifndef main         ; Inhibit for this module
  19:				; Constants
  20:				;
  21:				; Variables 
  22:				                extern tikcnt       ; Tick counter
  23:				;
  24:				; Functions
  25:				                extern panic        ; System error exception
  26:				                extern rusby        ; Read byte from user space
  27:				                extern ruswd        ; Read 16-bit word from user space
  28:				                extern wusby        ; Write byte to user space
  29:				                extern wuswd        ; Write 16-bit word to user space
  30:				;
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** cache.z80 ****
  29:				                include "io_map.i"      ; I/O addresses mapping
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io_map.i ****
   1:				; ***********************************
   2:				; * ZARC I/O Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 3/9/2019          *
   5:				; ***********************************
   6:				
   7:				; *** I/O register address mapping ***
   8:				
   9:				; This should be kept in sync with the Definitions.vhd package file.
  10:     -	0000'         	IOA_FPGA_MAJREV equ 0x00        ; FPGA major revision
  11:     -	0001'         	IOA_FPGA_MINREV equ 0x01        ; FPGA minor revision
  12:     -	0002'         	IOA_CONTROL     equ 0x02        ; System control register
  13:     -	0003'         	IOA_FP_SW       equ 0x03        ; Front panel data switches
  14:				
  15:				; Paging
  16:     -	0004'         	IOA_MMAP_0      equ 0x04        ; Page, supervisor and protection for bank 0 (0x0000 to 0x3fff)
  17:     -	0005'         	IOA_MMAP_1      equ 0x05        ; Page, supervisor and protection for bank 1 (0x4000 to 0x7fff)
  18:     -	0006'         	IOA_MMAP_2      equ 0x06        ; Page, supervisor and protection for bank 2 (0x8000 to 0xbfff)
  19:     -	0007'         	IOA_MMAP_3      equ 0x07        ; Page, supervisor and protection for bank 3 (0xc000 to 0xffff)
  20:				
  21:				; Interrupts
  22:				; Note: Up to eight interrupts are supported. IM 2 is anticipated, and the
  23:				; fixed vector associated with each interrupt is supplied when the interrupt
  24:				; is serviced. Routine address is “I*256+databus”. Vector supplied is
  25:				; 0xe0 + 2 * interrupt number (0 to 7).
  26:				; Note: addresses 0x09 and 0x0b reserved for use if more than eight interrupt
  27:				; sources are required.
  28:     -	0008'         	IOA_INT_EN      equ 0x08        ; Enables
  29:     -	000A'         	IOA_INT_PEND    equ 0x0a        ; Pending interrupts
  30:				;
  31:				;NMI
  32:     -	000C'         	IOA_NMI_REASONS equ 0x0c        ; NMI reasons flags
  33:				;
  34:				; Serial.
  35:     -	0010'         	IOA_SER1_CSR    equ 0x10        ; Port 1 control / status
  36:     -	0011'         	IOA_SER1_DATA   equ 0x11        ; Port 1 data
  37:     -	0012'         	IOA_SER2_CSR    equ 0x12        ; Port 2 serial control / status
  38:     -	0013'         	IOA_SER2_DATA   equ 0x13        ; Port 2 serial data
  39:				
  40:				; RTC (DS1672)
  41:				; I2C, implemented using a byte interface to the CPU. Writing to the data port
  42:				; shifts out a byte. Input puts are shifted into the “other end” of the same
  43:				; register.
  44:     -	0018'         	IOA_I2C_CSR     equ 0x18        ; Control
  45:     -	0019'         	IOA_I2C_DATA    equ 0x19        ; Data
  46:				;
  47:				; SD Card
  48:				; Uses SPI mode, with a generally similar interface to that of the I2C.
  49:     -	0020'         	IOA_SPI_CSR     equ 0x20        ; Control
  50:     -	0021'         	IOA_SPI_DATA    equ 0x21        ; Data
  51:				
  52:				; CRC16 / XMODEM and MultiMediaCard CRC16
  53:				; Write to the CRC register to set the initial value. Writing to the input
  54:				; data register updates the CRC.
  55:     -	0024'         	IOA_CRC_0       equ 0x24        ; CRC register (low)
  56:     -	0025'         	IOA_CRC_1       equ 0x25        ; CRC register (high)
  57:     -	0026'         	IOA_CRC_DATA    equ 0x26        ; Input data
  58:				
  59:				; *** Proposed features ***
  60:				; Video
  61:				;IOA_VID_CTRL    equ 0x30;       ; Control (cursor on/off ...)
  62:				;IOA_VID_DATA    equ 0x31;       ; Data
  63:				;IOA_VID_CUR_X   equ 0x32;       ; Cursor X (0 to 127)
  64:				;IOA_VID_CUR_Y   equ 0x33;       ; Cursor Y (0 to 63)
  65:				;IOA_VID_START_L equ 0x34        ; Display start address (low byte)
  66:				;IOA_VID_START_H equ 0x35        ; Display start address (high byte)
  67:				
  68:				; Video palette
  69:				; Each entry consists of 6 bits of colour data. Foreground and background
  70:				; colour pairs are selected from the above palette using eight of the 22
  71:				; control codes in the display character set. This leaves codes for
  72:				; double-height, double-width etc.
  73:				;IOA_VID_PALBG0  equ 0x40        ; Background colour 0
  74:				;IOA_VID_PALFG0  equ 0x41        ; Foreground colour 0
  75:				;IOA_VID_PALBG1  equ 0x42        ; Background colour 1
  76:				;IOA_VID_PALFG1  equ 0x43        ; Foreground colour 1
  77:				;IOA_VID_PALBG2  equ 0x44        ; Background colour 2
  78:				;IOA_VID_PALFG2  equ 0x45        ; Foreground colour 2
  79:				;IOA_VID_PALBG3  equ 0x46        ; Background colour 3
  80:				;IOA_VID_PALFG3  equ 0x47        ; Foreground colour 3
  81:				;IOA_VID_PALBG4  equ 0x48        ; Background colour 4
  82:				;IOA_VID_PALFG4  equ 0x49        ; Foreground colour 4
  83:				;IOA_VID_PALBG5  equ 0x4a        ; Background colour 5
  84:				;IOA_VID_PALFG5  equ 0x4b        ; Foreground colour 5
  85:				;IOA_VID_PALBG6  equ 0x4c        ; Background colour 6
  86:				;IOA_VID_PALFG6  equ 0x4d        ; Foreground colour 6
  87:				;IOA_VID_PALBG7  equ 0x4e        ; Background colour 7
  88:				;IOA_VID_PALFG7  equ 0x4f        ; Foreground colour 7
  89:				
  90:				; Arithmetic
  91:				; Multiply, divide … based on 68000 DIV, DIVU, MUL, MULU.
  92:				; Multiply does A[16] * B[16] => C[32].
  93:				; Divide does A[32] / B[16] => C[32] (16-bit remainder [high bits] and
  94:				; 16-bit quotient [low bits]).
  95:				; Status bits include “complete” and “overflow”.
  96:				;IOA_ARITH_A_L   equ 0x50        ; A register (low)
  97:				;IOA_ARITH_A_H   equ 0x51        ; A register (high)
  98:				;IOA_ARITH_B_L   equ 0x54        ; B register (low)
  99:				;IOA_ARITH_B_H   equ 0x57        ; B register (high)
 100:				;IOA_ARITH_C_0   equ 0x58        ; C register (low)
 101:				;IOA_ARITH_C_1   equ 0x59 
 102:				;IOA_ARITH_C_2   equ 0x5a
 103:				;IOA_ARITH_C_3   equ 0x5b        ; C register (high)
 104:				;IOA_ARITH_CSR   equ 0x5c        ; Command / status
 105:				
 106:				
 107:				; *** Register bits allocation ***
 108:				
 109:				; IOA_CONTROL register
 110:     -	        	BITDEF SYSCTRL_TRARM, 0         ; 1 arms the trace interrupt
 111:     -	        	BITDEF SYSCTRL_MMAP, 1          ; 1 enables memory mapping
 112:     -	        	BITDEF SYSCTRL_NMCLR, 2         ; NMI mapping clear
 113:     -	        	BITDEF SYSCTRL_MAPARM, 3        ; NMI out arm
 114:     -	        	BITDEF SYSCTRL_MMAPN, 4         ; State of MMAP when an NMI occurred
 115:     -	        	BITDEF SYSCTRL_TRPRE0, 5        ; Number of prefixes for trace
 116:     -	        	BITDEF SYSCTRL_TRPRE1, 6
 117:     -	        	BITDEF SYSCTRL_RESERVED, 7      ; Unused bit
 118:				;
 119:				; MMAP page registers
 120:     -	        	BITDEF MMAP_PROT, 7             ; Write protection
 121:     -	        	BITDEF MMAP_SUPER, 6            ; I/O enable
 122:     -	003F'         	MMAP_PAGE_MASK  equ 0x3f        ; RAM page number bits
 123:				;
 124:				; IOA_INT_EN and IOA_INT_PEND registers.
 125:     -	0008'         	INTS_NUM        equ 8           ; Number of possible interrupt sources
 126:     -	        	BITDEF INT_SER1_TX, 0           ; Serial port 1 transmitter buffer is half full or less
 127:     -	        	BITDEF INT_SER1_RX, 1           ; Serial port 1 receiver has data
 128:     -	        	BITDEF INT_SER2_TX, 2           ; Serial port 2 transmitter buffer is half full or less
 129:     -	        	BITDEF INT_SER2_RX, 3           ; Serial port 2 receiver has data
 130:     -	        	BITDEF INT_TICK, 4              ; Regular timekeeping
 131:				;
 132:				; IOA_NMI_REASONS register.
 133:     -	0004'         	NMI_REASONS_NUM equ 4           ; Number of reasons for an NMI
 134:     -	        	BITDEF NMI_SWITCH, 0;           ; Front panel switch
 135:     -	        	BITDEF NMI_PROT_VIOL, 1;        ; Write protection violation
 136:     -	        	BITDEF NMI_SUPER_VIOL, 2;       ; Supervisor violation
 137:     -	        	BITDEF NMI_TRACE, 3;            ; Debugger trace (single step)
 138:     -	000F'         	NMI_REASONS_ALL equ NMI_SWITCH_MASK + NMI_PROT_VIOL_MASK + NMI_SUPER_VIOL_MASK + NMI_TRACE_MASK
 139:				;
 140:				; Serial CSRs (IOA_SER1_CSR and IOA_SER2_CSR).
 141:     -	        	BITDEF SER_CSR_RX_EMPTY, 0      ; Receiver buffer is empty
 142:     -	        	BITDEF SER_CSR_RX_ALHALF, 1     ; Receiver buffer is at least half full
 143:     -	        	BITDEF SER_CSR_RX_FULL, 2       ; Receiver buffer is full
 144:     -	        	BITDEF SER_CSR_FRAME_ERR, 3     ; Framing error in last character
 145:     -	        	BITDEF SER_CSR_TX_EMPTY, 4      ; Transmitter buffer is empty
 146:     -	        	BITDEF SER_CSR_TX_ALHALF, 5     ; Transmitter buffer is at least half full
 147:     -	        	BITDEF SER_CSR_TX_FULL, 6       ; Transmitter buffer is full
 148:				; Bit 7 is not used.
 149:				;
 150:				; I2C (Inter-Integrated Circuit) master interface. Used for RTC (DS1672).
 151:				; Bits in IOA_I2C_CSR
 152:     -	        	BITDEF I2C_CSR_ACKN, 0          ; (Read / write) acknowledge from receiving device
 153:     -	        	BITDEF I2C_CSR_START, 1         ; (Write only) trigger start sequence
 154:     -	        	BITDEF I2C_CSR_STOP, 2          ; (Write only) trigger stop sequence
 155:     -	        	BITDEF I2C_CSR_BUSY, 7          ; (Read only) transceiver busy
 156:				;
 157:				; SPI (Serial Peripheral Interface) master interface. Used for memory card.
 158:				; Bits in IOA_SPI_CSR
 159:     -	        	BITDEF SPI_CSR_FAST, 0          ; (Read / write) SPI speed select
 160:     -	        	BITDEF SPI_CSR_MC_SS, 1         ; (Read / write) memory card slave select
 161:     -	        	BITDEF SPI_CSR_BUSY, 7          ; (Read only) transceiver busy
 162:				
**** cache.z80 ****
  30:				                include "io.i"          ; I/O routines
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io.i ****
   1:				; ***********************************
   2:				; * ZARC Basic I/O Extern Symbols   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and extern statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef io           ; Inhibit for this module
  16:				;
  17:				                ; Variables
  18:				                extern coport   ; Current console port (PRT_xxx)
  19:				                extern trport   ; Current data transfer port (PRT_xxx)
  20:				;
  21:				                ; Routines
  22:				                extern conwch   ; Write character to the console
  23:				                extern conrch   ; Read character from the console
  24:				                extern consta   ; Fetch console port status
  25:				                extern trawch   ; Write character to the data transfer port
  26:				                extern trarch   ; Read character from the data transfer port
  27:				                extern s1wch    ; Write character to serial port 1
  28:				                extern s1rch    ; Read character from serial port 1
  29:				                extern s1sta    ; Fetch serial port 1 status
  30:				                extern s2wch    ; Write character to serial port 2
  31:				                extern s2rch    ; Read character from serial port 2
  32:				                extern s2sta    ; Fetch serial port 2 status
  33:				                extern i2cwr    ; Write to I2C device
  34:				                extern i2crd    ; Read from I2C device
  35:				                extern spiini   ; Initialise SPI interface and set speed
  36:				                extern spiss    ; Set SPI slave select(s)
  37:				                extern spitr    ; Transfer byte to / from SPI device
  38:				;
  39:				                endif
  40:				            endif
  41:				;
  42:				;
  43:				; Port enumeration. Used for console and transfer port selection. Definitions must
  44:				; match names in prt_name_list (monitor.z80).
  45:     -	        	                ENUM_START
  46:     -	        	                ENUM PORT_SER1          ; Serial port 1
  47:     -	        	                ENUM PORT_SER2          ; Serial port 2
  48:     -	        	                ENUM_END PORT_STATES    ; Number of states
  49:				;
  50:				
**** cache.z80 ****
  31:				                include "utility.i"     ; Utility functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//utility.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Utility Routines   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef utility      ; Inhibit for this module
  16:				;
  17:				                extern cwnwln       ; Write new line characters to console.
  18:				                extern conwms       ; Print null-terminated string to the console
  19:				                extern conwmn       ; Print message <n> in a list
  20:				                extern skpspc       ; Step hl past spaces
  21:				                extern toupca       ; Convert character in A to upper case
  22:				                extern toloca       ; Convert character in A to lower case
  23:				                extern cwvich       ; Print only visible 7-bit characters
  24:				                extern cwpspc       ; Print a space
  25:				                extern mtwdli       ; Match word in a string against list of options
  26:				                extern cwphnb       ; Print least-significant nibble in A in hexadecimal
  27:				                extern cwphby       ; Print A in hexadecimal
  28:				                extern cwphwd       ; Print HL in hexadecimal
  29:				                extern cwpdby       ; Print A in decimal. Leading zeros are suppressed
  30:				                extern cwpdwd       ; Print HL in decimal. Leading zeros are suppressed
  31:				                extern cwpdlo       ; Print DEHL in decimal. Leading zeros are suppressed
  32:				                extern rdhxwd       ; Read a 16-bit hexadecimal number from a string
  33:				                extern rdduwd       ; Read a 16-bit unsigned decimal number from a string
  34:				                extern rddulo       ; Read a 32-bit unsigned decimal number from a string
  35:				;
  36:				                endif
  37:				            endif
  38:				;
  39:				;
  40:				; mtwdli (match word in a string against list of options) option bits. Each bit
  41:				; has the described effect if set.
  42:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  43:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  44:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  45:				
**** cache.z80 ****
  32:				                include "mmc.i"         ; Memory card
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//mmc.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Memory Card Include File   *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 7/8/2020                  *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  16:     -	0001'         	                ifndef mmc          ; Inhibit for this module
  17:				; Functions
  18:				                extern mcinit       ; Initialise memory card
  19:				                extern mcprer       ; Print memory card error text
  20:				                extern mcrrs        ; Raw read sector
  21:				                extern mcrws        ; Raw write sector
  22:				; Variables
  23:				                extern mcstat       ; Card state (MC_STAT_xxx)
  24:				;
  25:				                endif
  26:				            endif
  27:				;
  28:				;
  29:     -	0200'         	MMC_SECTOR_SIZE             equ 512     ; Sector size
  30:     -	0009'         	MMC_LOG2_SEC_SIZE           equ 9       ; Save number of shifts for above
  31:     -	0040'         	MMC_CMD_START               equ 0x40    ; Command start bits (01b) shifted for
  32:				                                        ; command byte
  33:     -	0001'         	MMC_CMD_STOP                equ 0x01    ; Stop bit (in CRC byte)
  34:				;
  35:				;
  36:				; Card state (mcstat) states.
  37:     -	        	                ENUM_START
  38:     -	        	                ENUM MMC_STAT_IDLE      ; Not initialised
  39:     -	        	                ENUM MMC_STAT_INIT      ; Initialised (can do raw read / writes)
  40:				
  41:     -	        	                ENUM_END MC_STATES  ; Number of states
  42:				;
  43:				;
  44:				; Memory card command structure
  45:     -	        	                STRUCT
  46:     -	        	                STR_BYTE MMC_CMD    ; Command including start bits
  47:     -	        	                STR_BYTE MMC_ARG1   ; Arguments
  48:     -	        	                STR_BYTE MMC_ARG2   ; Arguments
  49:     -	        	                STR_BYTE MMC_ARG3   ; Arguments
  50:     -	        	                STR_BYTE MMC_ARG4   ; Arguments
  51:     -	        	                STR_BYTE MMC_CRC    ; CRC and stop bit
  52:     -	        	                STR_END MMC_SIZE
  53:				;
  54:				;
  55:				; SPI mode commands (CMDn from MMC-System-Spec-v3.31.pdf chapter 4.9).
  56:     -	0000'         	MMC_CMD_GO_IDLE_STATE       equ 0   ; Resets the memory card
  57:     -	0001'         	MMC_CMD_SEND_OP_COND        equ 1   ; Sends host capacity support information and init.
  58:     -	0009'         	MMC_CMD_SEND_CSD            equ 9   ; Read card specific data
  59:     -	000A'         	MMC_CMD_SEND_CID            equ 10  ; Read card identification
  60:     -	000D'         	MMC_CMD_SEND_STATUS         equ 13  ; Read card status register
  61:     -	0010'         	MMC_CMD_SET_BLOCKLEN        equ 16  ; Set block length (in bytes)
  62:     -	0011'         	MMC_CMD_READ_SINGLE_BLOCK   equ 17  ; Reads a block
  63:     -	0018'         	MMC_CMD_WRITE_BLOCK         equ 24  ; Writes a block
  64:     -	0037'         	MMC_CMD_APP_CMD             equ 55  ; Next command is an application specific command
  65:     -	003B'         	MMC_CMD_CRC_ON_OFF          equ 59  ; Turns the CRC option on or off
  66:				;
  67:				; The list describes all the application specific commands supported/reserved by the 
  68:				; memory card. All the following commands shall be preceded with APP_CMD (CMD55).
  69:     -	0029'         	MMC_ACMD_MC_SEND_OP_COND    equ 41  ; Sends host capacity support information and init
  70:				;
  71:				; R1 response bits
  72:     -	        	BITDEF MMC_R1_IDLE, 0           ; In idle state
  73:     -	        	BITDEF MMC_R1_ERA_RST, 1        ; Erase reset
  74:     -	        	BITDEF MMC_R1_ILL_CMD, 2        ; Illegal command
  75:     -	        	BITDEF MMC_R1_CMD_CRC_ERR, 3    ; Command CRC error
  76:     -	        	BITDEF MMC_R1_ERA_SEQ_ERR, 4    ; Erase sequence error
  77:     -	        	BITDEF MMC_R1_ADDR_ERR, 5       ; Address error
  78:     -	        	BITDEF MMC_R1_PAR_ERR, 6        ; Parameter error
  79:     -	        	BITDEF MMC_R1_START, 7          ; Zero identifies an R1 response
  80:				;
  81:				;
  82:     -	0006'         	MMC_CID_PNM_SIZE      equ 6   ; Product name length (bytes)
  83:				;
  84:				; Card IDentification (CID) register (128 bits)
  85:     -	        	                STRUCT
  86:     -	        	                STR_BYTE MMC_CID_MID    ; Manufacturer ID
  87:     -	        	                STR_WORD MMC_CID_OID    ; OEM/Application ID
  88:     -	        	                STR_BLOCK MMC_CID_PNM, MMC_CID_PNM_SIZE ; Product name
  89:     -	        	                STR_BYTE MMC_CID_PRV    ; Product revision
  90:     -	        	                STR_LONG MMC_CID_PSN    ; Product serial number
  91:     -	        	                STR_BYTE MMC_CID_MDT    ; Manufacturing date
  92:     -	        	                STR_BYTE MMC_CID_CRC    ; CRC7 checksum and "1"
  93:     -	        	                STR_END MMC_CID_SIZE
  94:				;
  95:				;
  96:				; Card-Specific Data (CSD) register (128 bits). It contains a number of bit fields
  97:				; that aren't necessarily byte aligned. In these cases, the entries simply identify
  98:				; the bit numbers contained.
  99:     -	        	                STRUCT
 100:     -	        	                STR_BYTE MMC_CSD_VERSION    ; (127-120) CSD version, spec version
 101:     -	        	                STR_BYTE MMC_CSD_TAAC       ; (119-112) data read access-time-1
 102:     -	        	                STR_BYTE MMC_CSD_NSAC       ; (111-104) data read access-time-2
 103:     -	        	                STR_BYTE MMC_CSD_TR_SPD     ; (103-96) max. data transfer rate
 104:     -	        	                STR_BYTE MMC_CSD_95_88      ; Card command classes (MS 8 bits)
 105:     -	        	                STR_BYTE MMC_CSD_87_80      ; CCC (LS bits) and max. read data length
 106:     -	        	                STR_BYTE MMC_CSD_79_72      ; Flags and C_SIZE bits 10 and 11
 107:     -	        	                STR_BYTE MMC_CSD_71_64      ; C_SIZE bits 2 to 9
 108:     -	        	                STR_BYTE MMC_CSD_63_56      ; C_SIZE bits 1 to 0 and some currents
 109:     -	        	                STR_BYTE MMC_CSD_55_48      ; Currents & C_SIZE_MULT (MS 2 bits)
 110:     -	        	                STR_BYTE MMC_CSD_47_40      ; C_SIZE_MULT (LS bit) and erase size (part)
 111:     -	        	                STR_BYTE MMC_CSD_39_32      ; Erase size (part) and WP group size
 112:     -	        	                STR_BYTE MMC_CSD_31_24      ; WP group enable, ECC and write parameters (part)
 113:     -	        	                STR_BYTE MMC_CSD_23_16      ; Write block lenth (part) and reserved
 114:     -	        	                STR_BYTE MMC_CSD_15_8       ; Flags
 115:     -	        	                STR_BYTE MMC_CSD_CRC        ; CRC7 checksum and "1"
 116:     -	        	                STR_END MMC_CSD_SIZE
 117:				
**** cache.z80 ****
  33:				                include "disks.i"       ; Disk parameters
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//disks.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Disk Format Include File   *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 13/11/2020                *
   5:				; *******************************************
   6:				;
   7:				; Constants and structures for use when handling disks (memory cards) in the
   8:				; monitor.
   9:				;
  10:				; Master Boot Record (MBR) parameters. This follows the format of the "Structure
  11:				; of a classical generic MBR" at https://en.wikipedia.org/wiki/Master_boot_record#PTE
  12:				; This is consistent what what I found on one of the MMC cards I examined.
  13:     -	AA55'         	DSK_BOOT_SIGN               equ 0xaa55
  14:     -	01FE'         	DSK_BOOT_SIGN_OFFSET        equ 0x01fe
  15:     -	0004'         	DSK_MAX_PARTS               equ 4       ; Maximum allowed in a "classical" MBR
  16:     -	01BE'         	DSK_PART1_OFFSET            equ 0x01be
  17:     -	007F'         	DSK_PART_TYP_EXPER          equ 0x7f    ; Experimental (no CP/M 2.2 type coded)
  18:				;
  19:				;
  20:				; Partition table entry structure.
  21:				; Derived from https://en.wikipedia.org/wiki/Master_boot_record#PTE
  22:     -	        	                STRUCT
  23:     -	        	                STR_BYTE DPART_STATUS
  24:				; CHS of first sector.
  25:     -	        	                STR_BYTE DPART_START_HD     ; Head
  26:     -	        	                STR_BYTE DPART_START_SEC    ; Cylinder MS bits and sector
  27:     -	        	                STR_BYTE DPART_START_CYL    ; Cylinder
  28:     -	        	                STR_BYTE DPART_TYPE
  29:				; CHS of last sector.
  30:     -	        	                STR_BYTE DPART_END_HD
  31:     -	        	                STR_BYTE DPART_END_SEC
  32:     -	        	                STR_BYTE DPART_END_CYL
  33:				; Logical Block Address (LBA) parameters.
  34:     -	        	                STR_LONG DPART_START_LBA    ; Start sector
  35:     -	        	                STR_LONG DPART_SIZE_SECS    ; Size in sectors
  36:     -	        	                STR_END DPART_SIZE
  37:				
**** cache.z80 ****
  34:				                include "interrupts.i"  ; Interrupts
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//interrupts.i ****
   1:				; ***********************************
   2:				; * ZARC Interrupts Routines        *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef interrupts   ; Inhibit for this module
  16:				; Variables 
  17:				                extern itenfl   ; Int. enable flag (0 = basic, 1 = normal I/O mode)
  18:				                extern itdsct   ; DI nest count
  19:				; Functions
  20:				                extern itinit   ; Initialise interrupt variables and set basic I/O mode
  21:				                extern itstrt   ; Start monitor interrupts
  22:				                extern itena    ; Enable interrupts if safe
  23:				                extern itdis    ; Disable interrupts and keep count
  24:				                extern itsvec   ; Set interrupt vector to point to a new service routine
  25:				;
  26:				                endif
  27:				            endif
  28:				
**** cache.z80 ****
  35:				                include "cache.i"       ; MMC sector cache
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cache.i ****
   1:				; ***********************************************
   2:				; * ZARC Monitor Memory Card Cache Include File *
   3:				; * Written by: Merlin Skinner                  *
   4:				; * Date Started: 23/11/2020                    *
   5:				; ***********************************************
   6:				;
   7:				; Constants and structures associated with the MMC memory card sector cache.
   8:				;
   9:				; "Dirty" in this case indicates sector data that is in the cache, but has not yet
  10:				; been written to the MMC.
  11:				;
  12:				;
  13:				; The following conditionals are intended to allow the same include file to be
  14:				; used in the defining module and elsewhere as required. Some includes are used
  15:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  16:				; the extern and public statements are not desirable.
  17:				;
  18:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  19:     -	0000'         	                ifndef cache        ; Inhibit for this module
  31:				                endif
  32:				            endif
  33:				;
  34:				;
  35:     -	0010'         	MCCA_BUFFERS                equ 16      ; Number of cached sector buffers
  36:     -	0008'         	MCCA_DIRT_THRES             equ MCCA_BUFFERS / 2    ; Target no. of dirty buffers
  37:				;
  38:				;
  39:				; Sector cache structure. This contains the data associated with a single cached
  40:				; sector.
  41:     -	        	                STRUCT
  42:     -	        	                STR_BYTE MCCAS_STATUS       ; Status byte
  43:     -	        	                STR_24BIT MCCAS_SECTOR      ; 24-bit sector number
  44:     -	        	                STR_WORD MCCAS_CSUM         ; Checksum of data
  45:     -	        	                STR_BLOCK MCCAS_DATA, MMC_SECTOR_SIZE   ; Cached data
  46:     -	        	                STR_END MCCAS_SIZE
  47:				;
  48:				; MCCAS_STATUS byte is defined as follows:
  49:				; Bits 0 to 3 - set if the corresponding CP/M sector in this MMC sector is dirty.
  50:     -	        	BITDEF MCCAS_STAT_CPM0, 0       ; CP/M sector 0 (0 to 0x7f)
  51:     -	        	BITDEF MCCAS_STAT_CPM1, 1       ; CP/M sector 1 (0x80 to 0x0ff)
  52:     -	        	BITDEF MCCAS_STAT_CPM2, 2       ; CP/M sector 2 (0x100 to 0x17f)
  53:     -	        	BITDEF MCCAS_STAT_CPM3, 3       ; CP/M sector 3 (0x180 to 0x1ff)
  54:     -	        	BITDEF MCCAS_STAT_VALID, 4      ; Buffer contains valid data
  55:				;
  56:     -	000F'         	MCCAS_STAT_DIRT_MASK    equ MCCAS_STAT_CPM0_MASK + MCCAS_STAT_CPM1_MASK + MCCAS_STAT_CPM2_MASK + MCCAS_STAT_CPM3_MASK
  57:				
**** cache.z80 ****
  36:				                include "cpm.i"         ; CP/M support
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  17:     -	0001'         	                ifndef cpm          ; Inhibit for this module
  18:				; Constants
  19:				;
  20:				; Variables 
  21:				                extern cppags       ; CP/M page allocations
  22:				;
  23:				; Functions
  24:				                extern cpinit       ; Load and start CP/M
  25:				                extern cpmem        ; Allocate CP/M pages
  26:				;
  27:				                endif
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** cache.z80 ****
  37:				                include "maths.i"       ; Mathematical functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for ZARC Z80 Computer         *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 29/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0001'         	            ifdef monitor           ; Meaningful for monitor build only
  15:     -	0001'         	                ifndef maths        ; Inhibit for this module
  16:				;
  17:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  18:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  19:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  20:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  21:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  22:				                extern crc16x       ; Software CRC-16 (XMODEM)
  23:				;
  24:				                endif
  25:				            endif
  26:				
**** cache.z80 ****
  38:				;
  39:				;
  40:				; *************
  41:				; * Externals *
  42:				; *************
  43:				;
  44:				; Routines
  45:				                public cacold       ; Reset cache (cold start)
  46:				                public cawarm       ; Initialise cache (warm start)
  47:				                public carpt        ; Report status
  48:				                public caflus       ; Flush cache
  49:				                public cars         ; Read sector
  50:				                public caws         ; Write sector
  51:				                public cacrs        ; Read CP/M sector
  52:				                public cacws        ; Write CP/M sector
  53:				;
  54:				; Variables
  55:				;
  56:				; (None)
  57:				;
  58:				;
  59:				;
  60:				; *************
  61:				; * Constants *
  62:				; *************
  63:				;
  64:				; (None)
  65:				;
  66:				;
  67:				;
  68:				; *************
  69:				; * Main Code *
  70:				; *************
  71:				;
  72:				                cseg                    ; Code segment
  73:				;
  74:				; Reset cache. Deletes any cached data, and is intended for use only during a
  75:				; monitor "cold start". Call cainit before using the cache.
  76:    0+11	0000' C5      	cacold          push bc
  77:   11+11	0001' D5      	                push de
  78:   22+15	0002' DDE5    	                push ix
  79:				; Initialise the cache, discarding any sector data.
  80:   37+14	0004' DD210400	                ld ix, cache_buffers        ; Point to first buffer
  81:   51+10	0008' 110602  	                ld de, MCCAS_SIZE           ; Pre-load structure size
  82:   61+7	000B' 0610    	                ld b, MCCA_BUFFERS          ; Number of sector buffer structures
  83:   68+19	000D' DD360000	rst_buff_loop   ld (ix + MCCAS_STATUS), 0   ; Flag no valid data
  84:   87+15	0011' DD19    	                add ix, de
  85:  102+8+5	0013' 10F8    	                djnz rst_buff_loop
  86:  110+14	0015' DDE1    	                pop ix
  87:  124+10	0017' D1      	                pop de
  88:  134+10	0018' C1      	                pop bc
  89:  144+10	0019' C9      	                ret
  90:				;
  91:				;
  92:				; Reinitialise the cache, preserving as much data as possible. This is intended
  93:				; for use during a monitor "warm start".
  94:  154+11	001A' C5      	cawarm          push bc
  95:  165+11	001B' D5      	                push de
  96:  176+11	001C' E5      	                push hl
  97:  187+15	001D' DDE5    	                push ix
  98:  202+14	001F' DD210400	                ld ix, cache_buffers        ; Point to first buffer
  99:				; Initialise without disturbing cached data where possible. Buffers containing
 100:				; sectors with bad checksums are discarded.
 101:  216+7	0023' 0610    	                ld b, MCCA_BUFFERS          ; Number of sector buffer structures
 102:  223+7	0025' 0E00    	                ld c, 0                     ; Checksum error counter
 103:  230+10	0027' 110000  	                ld de, 0                    ; Reset counters
 104:				;
 105:				; Examine in buffer in turn.
 106:  240+19	002A' DD7E00  	in_sec_loop     ld a, (ix + MCCAS_STATUS)   ; Fetch status
 107:  259+8	002D' CB67    	                bit MCCAS_STAT_VALID_BIT, a
 108:  267+7+5	002F' 281F    	                jr z, in_sec_done           ; Jump if buffer not in use
 109:				; Verify checksum.
 110:  274+17	0031' CD6203  	                call calc_csum
 111:				; HL - newly computed checksum
 112:  291+4	0034' 7D      	                ld a, l
 113:  295+19	0035' DDBE04  	                cp (ix + MCCAS_CSUM)
 114:  314+7+5	0038' 2006    	                jr nz, in_bad_csum
 115:  321+4	003A' 7C      	                ld a, h
 116:  325+19	003B' DDBE05  	                cp (ix + MCCAS_CSUM + 1)
 117:  344+7+5	003E' 2807    	                jr z, in_good_csum
 118:				; If the checksum is bad, we can't trust the data regardless of what the status
 119:				; byte says.
 120:  351+4	0040' 0C      	in_bad_csum     inc c                       ; Count errors
 121:  355+19	0041' DD360000	                ld (ix + MCCAS_STATUS), 0   ; Mark buffer as free
 122:  374+12	0045' 1809    	                jr in_sec_done
 123:				;
 124:				; The sector data checksum matches, so we have confidence in the data. Examine the
 125:				; status byte next.
 126:  386+4	0047' 14      	in_good_csum    inc d                       ; Count used buffers
 127:  390+19	0048' DD7E00  	                ld a, (ix + MCCAS_STATUS)   ; Fetch status
 128:  409+7	004B' E60F    	                and MCCAS_STAT_DIRT_MASK
 129:  416+7+5	004D' 2801    	                jr z, in_sec_done
 130:				; Buffer is dirty (has some unwritten data).
 131:  423+4	004F' 1C      	                inc e
 132:  427+10	0050' 210602  	in_sec_done     ld hl, MCCAS_SIZE           ; Structure size
 133:				; Update pointer without disturbing the counts in DE.
 134:  437+4	0053' EB      	                ex de, hl
 135:  441+15	0054' DD19    	                add ix, de
 136:  456+4	0056' EB      	                ex de, hl
 137:  460+8+5	0057' 10D1    	                djnz in_sec_loop
 138:  468+4	0059' 7A      	                ld a, d
 139:  472+13	005A' 320100  	                ld (used_buffs), a          ; Number of buffers in use
 140:  485+4	005D' 7B      	                ld a, e
 141:  489+13	005E' 320200  	                ld (dirty_buffs), a         ; Number of dirty buffers
 142:				;
 143:				; Complain if we found buffers marked as valid but with bad checksums.
 144:  502+4	0061' 79      	                ld a, c
 145:  506+4	0062' A7      	                and a
 146:  510+7+5	0063' 2809    	                jr z, in_all_good
 147:  517+17	0065' CD0000  	                call cwpdby                 ; Print error count in decimal
 148:  534+10	0068' 219204  	                ld hl, in_badsum_msg        ; "corrupt cache buffers discarded"
 149:  544+17	006B' CD0000  	                call conwms                 ; Print message
 150:				;
 151:				; Set preferred next buffer to use.
 152:  561+4	006E' AF      	in_all_good     xor a                       ; Use the first one
 153:  565+13	006F' 320000  	                ld (next_buff), a
 154:				;
 155:  578+14	0072' DDE1    	in_exit         pop ix
 156:  592+10	0074' E1      	                pop hl
 157:  602+10	0075' D1      	                pop de
 158:  612+10	0076' C1      	                pop bc
 159:  622+10	0077' C9      	                ret
 160:				;
 161:				;
 162:				; Report cache status to the console. This is mainly for debugging, but may be
 163:				; of more general interest. The report is of the form:
 164:				;   <buffer no.> - <status> [<checksum error>]
 165:				; for each buffer. <status> is one of:
 166:				;   "unused"
 167:				;   <sector no.> "clean" - no unwritten data
 168:				;   <sector no.> "dirty" - unwritten sector
 169:				;   <sector no.> "grubby: xxxx" - partically unwritten (CP/M sectors)
 170:				; Last line is:
 171:				;   In use: x, 0, dirty: y, next read buffer: z
 172:  632+11	0078' C5      	carpt           push bc
 173:  643+11	0079' D5      	                push de
 174:  654+15	007A' DDE5    	                push ix
 175:  669+10	007C' 212404  	                ld hl, rpt_title_msg        ; "MMC Cache Status:"
 176:  679+17	007F' CD0000  	                call conwms                 ; Print message
 177:				; Loop through each cache structure.
 178:  696+14	0082' DD210400	                ld ix, cache_buffers        ; Point to first buffer
 179:  710+7	0086' 0600    	                ld b, 0                     ; Sector buffer structure count
 180:				; Print buffer number.
 181:  717+4	0088' 78      	rpt_buff_loop   ld a, b
 182:  721+17	0089' CD0000  	                call cwpdby                 ; Print buffer number in decimal
 183:  738+10	008C' 213804  	                ld hl, rpt_sep_msg          ; " - "
 184:  748+17	008F' CD0000  	                call conwms                 ; Print message
 185:				;
 186:  765+19	0092' DD7E00  	                ld a, (ix + MCCAS_STATUS)
 187:  784+8	0095' CB67    	                bit MCCAS_STAT_VALID_BIT, a
 188:  792+7+5	0097' 2008    	                jr nz, rpt_used             ; Jump if buffer is used
 189:				; Unused buffer.
 190:  799+10	0099' 213C04  	                ld hl, rpt_unused_msg       ; "unused"
 191:  809+17	009C' CD0000  	                call conwms                 ; Print message
 192:  826+12	009F' 185C    	                jr rpt_buff_done
 193:				; Buffer in use. Print sector number.
 194:  838+19	00A1' DD6E01  	rpt_used        ld l, (ix + MCCAS_SECTOR)
 195:  857+19	00A4' DD6602  	                ld h, (ix + MCCAS_SECTOR + 1)
 196:  876+19	00A7' DD5E03  	                ld e, (ix + MCCAS_SECTOR + 2)
 197:  895+7	00AA' 1600    	                ld d, 0
 198:  902+17	00AC' CD0000  	                call cwpdlo                 ; Print DEHL in decimal
 199:  919+17	00AF' CD0000  	                call cwpspc                 ; Print a space
 200:				;
 201:  936+19	00B2' DD7E00  	                ld a, (ix + MCCAS_STATUS)
 202:  955+7	00B5' FE10    	                cp MCCAS_STAT_VALID_MASK
 203:  962+7+5	00B7' 2008    	                jr nz, rpt_unclean
 204:				; No other bits are set, so the buffer is clean.
 205:  969+10	00B9' 214304  	                ld hl, rpt_clean_msg        ; "clean"
 206:  979+17	00BC' CD0000  	                call conwms                 ; Print message
 207:  996+12	00BF' 1827    	                jr rpt_checksum
 208:				;
 209:				; One or more CP/M sectors contain unwritten data
 210: 1008+7	00C1' FE1F    	rpt_unclean     cp MCCAS_STAT_VALID_MASK + MCCAS_STAT_DIRT_MASK
 211: 1015+7+5	00C3' 2008    	                jr nz, rpt_grubby
 212:				; The buffer contains no unmodified CP/M sectors (i.e. is completely unwritten).
 213: 1022+10	00C5' 214904  	                ld hl, rpt_dirty_msg        ; "dirty"
 214: 1032+17	00C8' CD0000  	                call conwms                 ; Print message
 215: 1049+12	00CB' 181B    	                jr rpt_checksum
 216:				;
 217:				; The buffer contains a mixture of clean and dirty CP/M sectors.
 218: 1061+4	00CD' 17      	rpt_grubby      rla                         ; Position status bits for display
 219: 1065+4	00CE' 17      	                rla
 220: 1069+4	00CF' 17      	                rla
 221: 1073+4	00D0' 17      	                rla
 222: 1077+4	00D1' 4F      	                ld c, a                     ; Save status (in bits 7 .. 4)
 223: 1081+10	00D2' 214F04  	                ld hl, rpt_grubby_msg       ; "grubby:"
 224: 1091+17	00D5' CD0000  	                call conwms                 ; Print message
 225:				; Print status bits in binary - "1" = dirty.
 226: 1108+11	00D8' C5      	                push bc
 227: 1119+7	00D9' 0604    	                ld b, MMC_SECTOR_SIZE / CPM_SECTOR_SIZE
 228: 1126+7	00DB' 3E30    	rpt_grub_loop   ld a, "0"
 229: 1133+8	00DD' CB11    	                rl c
 230: 1141+7+5	00DF' 3001    	                jr nc, rpt_grub_bit
 231: 1148+4	00E1' 3C      	                inc a                       ; Make it a "1"
 232: 1152+17	00E2' CD0000  	rpt_grub_bit    call conwch                 ; Print character
 233: 1169+8+5	00E5' 10F4    	                djnz rpt_grub_loop
 234: 1177+10	00E7' C1      	                pop bc
 235:				;
 236: 1187+17	00E8' CD6203  	rpt_checksum    call calc_csum
 237:				; HL - newly computed checksum
 238: 1204+4	00EB' 7D      	                ld a, l
 239: 1208+19	00EC' DDBE04  	                cp (ix + MCCAS_CSUM)
 240: 1227+7+5	00EF' 2006    	                jr nz, rpt_bad_csum
 241: 1234+4	00F1' 7C      	                ld a, h
 242: 1238+19	00F2' DDBE05  	                cp (ix + MCCAS_CSUM + 1)
 243: 1257+7+5	00F5' 2806    	                jr z, rpt_buff_done
 244:				; If the checksum is bad, report it.
 245: 1264+10	00F7' 218004  	rpt_bad_csum    ld hl, rpt_badsum_msg       ; "checksum error!"
 246: 1274+17	00FA' CD0000  	                call conwms                 ; Print message
 247:				;
 248: 1291+17	00FD' CD0000  	rpt_buff_done   call cwnwln                 ; Write new line characters to console
 249: 1308+10	0100' 110602  	                ld de, MCCAS_SIZE           ; Structure size
 250: 1318+15	0103' DD19    	                add ix, de
 251: 1333+4	0105' 04      	                inc b                       ; Count buffers
 252: 1337+4	0106' 78      	                ld a, b
 253: 1341+7	0107' FE10    	                cp MCCA_BUFFERS
 254: 1348+10	0109' DA8800  	                jp c, rpt_buff_loop         ; Loop unless all done
 255:				;
 256:				; In use count.
 257: 1358+10	010C' 215804  	                ld hl, rpt_usedc_msg        ; "In use:"
 258: 1368+17	010F' CD0000  	                call conwms                 ; Print message
 259: 1385+13	0112' 3A0100  	                ld a, (used_buffs)
 260: 1398+17	0115' CD0000  	                call cwpdby                 ; Print A in decimal
 261:				;
 262:				; Dirty count.
 263: 1415+10	0118' 216104  	                ld hl, rpt_dirtyc_msg       ; "Dirty:"
 264: 1425+17	011B' CD0000  	                call conwms                 ; Print message
 265: 1442+13	011E' 3A0200  	                ld a, (dirty_buffs)
 266: 1455+17	0121' CD0000  	                call cwpdby                 ; Print A in decimal
 267:				;
 268:				; Preferred next buffer to use
 269: 1472+10	0124' 216B04  	                ld hl, rpt_nexrd_msg        ; "Next read buffer:"
 270: 1482+17	0127' CD0000  	                call conwms                 ; Print message
 271: 1499+13	012A' 3A0000  	                ld a, (next_buff)
 272: 1512+17	012D' CD0000  	                call cwpdby                 ; Print A in decimal
 273: 1529+17	0130' CD0000  	                call cwnwln                 ; Write new line characters to console
 274:				;
 275: 1546+14	0133' DDE1    	                pop ix
 276: 1560+10	0135' D1      	                pop de
 277: 1570+10	0136' C1      	                pop bc
 278: 1580+10	0137' C9      	                ret
 279:				;
 280:				;
 281:				; Flush cache. All dirty or grubby buffers are written to the MMC.
 282:				; Returns with:
 283:				; A - zero (OK) or error code (SPI_ERR_xxx)
 284: 1590+13	0138' 3A0200  	caflus          ld a, (dirty_buffs)
 285: 1603+4	013B' A7      	                and a
 286: 1607+5+6	013C' C8      	                ret z                       ; Normal return with A = 0
 287: 1612+17	013D' CD4D01  	                call clean_one
 288: 1629+4	0140' A7      	                and a
 289: 1633+7+5	0141' 28F5    	                jr z, caflus                ; Keep going except on error
 290: 1640+10	0143' C9      	                ret                         ; Return with error code in A
 291:				;
 292:				;
 293:				; Maintain the level of "dirt" in the cache by writing a buffer if the level is
 294:				; too high. This must be called from time to time to make sure there is always
 295:				; at least one buffer available for re-use.
 296:				; On return, at least one buffer is guaranteed to be clean.
 297: 1650+13	0144' 3A0200  	maintain        ld a, (dirty_buffs)
 298: 1663+7	0147' FE08    	                cp MCCA_DIRT_THRES
 299: 1670+7+5	0149' 3002    	                jr nc, clean_one            ; Clean one and return
 300:				; Thereis nothing to do as the cache is clean enough.
 301: 1677+4	014B' AF      	mnt_flush_exit  xor a                       ; Flag success
 302: 1681+10	014C' C9      	                ret
 303:				;
 304:				;
 305:				; Find a dirty (or grubby) buffer and write it. Fully dirty buffers are a priority
 306:				; as grubby ones may yet have more data written to them.
 307:				; Returns with:
 308:				; A - zero (OK) or error code (SPI_ERR_xxx)
 309: 1691+11	014D' C5      	clean_one       push bc
 310: 1702+11	014E' D5      	                push de
 311: 1713+11	014F' E5      	                push hl
 312: 1724+15	0150' DDE5    	                push ix
 313: 1739+14	0152' DD210400	                ld ix, cache_buffers        ; Point to first buffer
 314: 1753+10	0156' 110602  	                ld de, MCCAS_SIZE           ; Pre-load structure size
 315: 1763+7	0159' 0610    	                ld b, MCCA_BUFFERS          ; Number of sector buffer structures
 316: 1770+19	015B' DD7E00  	mnt_dirt_loop   ld a, (ix + MCCAS_STATUS)
 317: 1789+7	015E' FE1F    	                cp MCCAS_STAT_VALID_MASK + MCCAS_STAT_DIRT_MASK
 318: 1796+7+5	0160' 281C    	                jr z, mnt_found_dirt        ; Jump if dirty buffer found
 319: 1803+15	0162' DD19    	                add ix, de
 320: 1818+8+5	0164' 10F5    	                djnz mnt_dirt_loop
 321:				;
 322:				; There are no fully dirty buffers, so look for a grubby one.
 323: 1826+14	0166' DD210400	                ld ix, cache_buffers        ; Point to first buffer
 324: 1840+7	016A' 0610    	                ld b, MCCA_BUFFERS          ; Number of sector buffer structures
 325: 1847+19	016C' DD7E00  	mnt_grub_loop   ld a, (ix + MCCAS_STATUS)
 326: 1866+8	016F' CB67    	                bit MCCAS_STAT_VALID_BIT, a
 327: 1874+7+5	0171' 2804    	                jr z, mnt_gr_skip
 328: 1881+7	0173' E60F    	                and MCCAS_STAT_DIRT_MASK
 329: 1888+7+5	0175' 2007    	                jr nz, mnt_found_dirt       ; Jump if dirty buffer found
 330: 1895+15	0177' DD19    	mnt_gr_skip     add ix, de
 331: 1910+8+5	0179' 10F1    	                djnz mnt_grub_loop
 332:				;
 333: 1918+17	017B' CD0000  	                call panic                  ; Should never go here!
 334:				;
 335:				; Found buffer to write.
 336:				; IX - address of sector buffer structure to write.
 337:				; Find start of sector data.
 338: 1935+15	017E' DDE5    	mnt_found_dirt  push ix
 339: 1950+10	0180' E1      	                pop hl
 340: 1960+10	0181' 010600  	                ld bc, MCCAS_DATA
 341: 1970+11	0184' 09      	                add hl, bc
 342: 1981+19	0185' DD5E01  	                ld e, (ix + MCCAS_SECTOR)
 343: 2000+19	0188' DD5602  	                ld d, (ix + MCCAS_SECTOR + 1)
 344: 2019+19	018B' DD4E03  	                ld c, (ix + MCCAS_SECTOR + 2); CDE - sector number
 345:				; HL - sector buffer start address
 346:				; IX - pointer to partition table entry structure
 347: 2038+17	018E' CD0000  	                call mcrws                  ; Raw write sector
 348: 2055+4	0191' A7      	                and a
 349: 2059+7+5	0192' 2009    	                jr nz, mnt_exit
 350:				; Successful write. Update status to reflect this. The data is still valid, so
 351:				; we only clear the dirty bits.
 352: 2066+19	0194' DD360010	                ld (ix + MCCAS_STATUS), MCCAS_STAT_VALID_MASK
 353:				; There are one fewer dirty buffers.
 354: 2085+10	0198' 210200  	                ld hl, dirty_buffs
 355: 2095+11	019B' 35      	                dec (hl)
 356:				;
 357: 2106+4	019C' AF      	mnt_ok          xor a               ; Successful return
 358:				; Exit with A - zero (OK) or error code (SPI_ERR_xxx)
 359: 2110+14	019D' DDE1    	mnt_exit        pop ix
 360: 2124+10	019F' E1      	                pop hl
 361: 2134+10	01A0' D1      	                pop de
 362: 2144+10	01A1' C1      	                pop bc
 363: 2154+10	01A2' C9      	                ret
 364:				;
 365:				;
 366:				; Read an MMC sector. Length is MMC_SECTOR_SIZE bytes.
 367:				; Call with:
 368:				; CDE - sector number (0 to (sectors - 1))
 369:				; HL - destination address
 370:				; Returns with:
 371:				; A - zero (OK) or error code (SPI_ERR_xxx)
 372:				; HL - updated pointer to buffer (points to location after last written)
 373: 2164+11	01A3' C5      	cars            push bc
 374: 2175+15	01A4' DDE5    	                push ix
 375: 2190+17	01A6' CDBF01  	                call read_mmc_sect          ; Read sector into cache
 376: 2207+4	01A9' A7      	                and a
 377: 2211+7+5	01AA' 200F    	                jr nz, mrse_exit
 378:				; Copy cached sector to required address.
 379:				; HL - destination address
 380:				; IX - address of sector buffer structure containing the required sector.
 381: 2218+4	01AC' EB      	                ex de, hl                   ; Move address to DE
 382:				; Find start of sector data.
 383: 2222+15	01AD' DDE5    	                push ix
 384: 2237+10	01AF' E1      	                pop hl
 385: 2247+10	01B0' 010600  	                ld bc, MCCAS_DATA
 386: 2257+11	01B3' 09      	                add hl, bc
 387: 2268+10	01B4' 010002  	                ld bc, MMC_SECTOR_SIZE      ; Length
 388:				; BC - byte counter
 389:				; DE - destination address
 390:				; HL - address of sector data
 391: 2278+16+5	01B7' EDB0    	                ldir
 392: 2294+4	01B9' EB      	                ex de, hl                   ; Move next address to HL
 393: 2298+4	01BA' AF      	                xor a                       ; Indicate success
 394:				; Exit with A = zero (OK) or error code (SPI_ERR_xxx) 
 395: 2302+14	01BB' DDE1    	mrse_exit       pop ix
 396: 2316+10	01BD' C1      	                pop bc
 397: 2326+10	01BE' C9      	                ret
 398:				;
 399:				;
 400:				; Read an MMC sector into cache. Length is MMC_SECTOR_SIZE bytes. This is used for
 401:				; normal sector reads and CP/M sector reads and writes.
 402:				; Call with:
 403:				; CDE - sector number (0 to (sectors - 1))
 404:				; Returns with:
 405:				; A - zero (OK) or error code (SPI_ERR_xxx)
 406:				; IX - points to sector cache structure entry used.
 407: 2336+11	01BF' E5      	read_mmc_sect   push hl
 408: 2347+11	01C0' C5      	                push bc
 409: 2358+11	01C1' D5      	                push de
 410: 2369+17	01C2' CDD103  	                call find_sec               ; Is it in the cache?
 411: 2386+7+5	01C5' 3827    	                jr c, mrs_found
 412: 2393+10	01C7' D1      	                pop de                      ; Restore sector number
 413: 2403+10	01C8' C1      	                pop bc
 414: 2413+11	01C9' C5      	                push bc                     ; Leave a copy on the stack
 415: 2424+11	01CA' D5      	                push de
 416: 2435+17	01CB' CDE502  	                call find_new_buff          ; Find buffer we can use
 417:				; Find address of sector data.
 418: 2452+15	01CE' DDE5    	                push ix
 419: 2467+10	01D0' E1      	                pop hl
 420: 2477+10	01D1' 010600  	                ld bc, MCCAS_DATA
 421: 2487+11	01D4' 09      	                add hl, bc
 422: 2498+10	01D5' D1      	                pop de                      ; Restore sector number
 423: 2508+10	01D6' C1      	                pop bc
 424:				; CDE - sector number (0 to (sectors - 1))
 425:				; HL - address of data in structure
 426:				; IX - pointer to partition table entry structure
 427: 2518+11	01D7' E5      	                push hl
 428: 2529+17	01D8' CD0000  	                call mcrrs                  ; Raw read sector
 429: 2546+10	01DB' E1      	                pop hl
 430: 2556+4	01DC' A7      	                and a
 431: 2560+7+5	01DD' 2012    	                jr nz, mrs_exit
 432:				; Successful read. Update status to reflect this.
 433: 2567+19	01DF' DD360010	                ld (ix + MCCAS_STATUS), MCCAS_STAT_VALID_MASK
 434:				; Calculate checksum (simple sum of all of the bytes in the sector data).
 435: 2586+17	01E3' CD6203  	                call calc_csum
 436:				; HL - newly computed checksum
 437: 2603+19	01E6' DD7504  	                ld (ix + MCCAS_CSUM), l
 438: 2622+19	01E9' DD7405  	                ld (ix + MCCAS_CSUM + 1), h
 439: 2641+12	01EC' 1802    	                jr mrs_have_sec
 440:				;
 441: 2653+10	01EE' D1      	mrs_found       pop de                      ; Discard sector number
 442: 2663+10	01EF' C1      	                pop bc
 443:				; IX - address of sector buffer structure containing the required sector.
 444: 2673+4	01F0' AF      	mrs_have_sec    xor a                       ; Indicate success
 445:				; A - zero (OK) or error code (SPI_ERR_xxx)
 446: 2677+10	01F1' E1      	mrs_exit        pop hl
 447: 2687+10	01F2' C9      	                ret
 448:				;
 449:				;
 450:				; Write an MMC sector. Length is MMC_SECTOR_SIZE bytes.
 451:				; Call with:
 452:				; CDE - sector number (0 to (sectors - 1))
 453:				; HL - source address
 454:				; Returns with:
 455:				; A - zero (OK) or error code (SPI_ERR_xxx)
 456:				; HL - updated pointer to buffer (points to location after last read)
 457: 2697+11	01F3' E5      	caws            push hl
 458: 2708+11	01F4' C5      	                push bc
 459: 2719+11	01F5' D5      	                push de
 460: 2730+17	01F6' CDD103  	                call find_sec               ; Is it in the cache?
 461: 2747+7+5	01F9' 3807    	                jr c, mws_found
 462: 2754+10	01FB' D1      	                pop de                      ; Restore sector number
 463: 2764+10	01FC' C1      	                pop bc
 464: 2774+17	01FD' CDE502  	                call find_new_buff          ; Find buffer we can use
 465:				; HL - address of data in structure
 466:				; IX - pointer to partition table entry structure
 467:				; Save current status for later.
 468: 2791+12	0200' 1802    	                jr mws_have_buff
 469:				;
 470:				; Sector was already in a buffer.
 471: 2803+10	0202' D1      	mws_found       pop de                      ; Discard sector number
 472: 2813+10	0203' C1      	                pop bc
 473:				;
 474: 2823+19	0204' DD7E00  	mws_have_buff   ld a, (ix + MCCAS_STATUS)
 475: 2842+13	0207' 320300  	                ld (mws_buff_status), a
 476:				; Find data address in structure.
 477: 2855+15	020A' DDE5    	                push ix
 478: 2870+10	020C' E1      	                pop hl
 479: 2880+10	020D' 010600  	                ld bc, MCCAS_DATA
 480: 2890+11	0210' 09      	                add hl, bc
 481:				; HL - sector buffer start address
 482:				; The buffer is marked as invalid until the copy is complete. This avoids
 483:				; potential issues due to the system being stopped before the copy is complete.
 484: 2901+19	0211' DD360000	                ld (ix + MCCAS_STATUS), 0   ; Flag no valid data
 485: 2920+10	0215' D1      	                pop de                      ; Fetch source address
 486: 2930+4	0216' EB      	                ex de, hl                   ; Swap source and destination
 487:				; Copy buffer
 488: 2934+10	0217' 010002  	                ld bc, MMC_SECTOR_SIZE      ; Length
 489:				; BC - byte counter
 490:				; DE - destination address
 491:				; HL - source address
 492: 2944+16+5	021A' EDB0    	                ldir
 493: 2960+4	021C' EB      	                ex de, hl                   ; Save next address in DE
 494:				; Calculate checksum (simple sum of all of the bytes in the sector data).
 495: 2964+17	021D' CD6203  	                call calc_csum
 496:				; HL - newly computed checksum
 497: 2981+19	0220' DD7504  	                ld (ix + MCCAS_CSUM), l
 498: 3000+19	0223' DD7405  	                ld (ix + MCCAS_CSUM + 1), h
 499: 3019+4	0226' EB      	                ex de, hl                   ; Recover next address to HL
 500:				;
 501:				; Successful write. Update status to reflect this.
 502: 3023+19	0227' DD36001F	                ld (ix + MCCAS_STATUS), MCCAS_STAT_VALID_MASK + MCCAS_STAT_DIRT_MASK
 503:				;
 504:				; Update counters. Which if either is incremented depends on the previous status
 505:				; of the buffer.
 506: 3042+11	022B' E5      	                push hl                     ; Save next address
 507: 3053+13	022C' 3A0300  	                ld a, (mws_buff_status)     ; Fetch old buffer status
 508: 3066+8	022F' CB67    	                bit MCCAS_STAT_VALID_BIT, a
 509: 3074+7+5	0231' 2806    	                jr z, mws_more_dirt
 510:				; Buffer was previously used.
 511: 3081+7	0233' E60F    	                and MCCAS_STAT_DIRT_MASK
 512: 3088+7+5	0235' 2802    	                jr z, mws_more_dirt
 513:				; Buffer was previously dirty, so nothing to do.
 514: 3095+12	0237' 1804    	                jr mws_exit
 515:				;
 516:				; Increment dirty count.
 517: 3107+10	0239' 210200  	mws_more_dirt   ld hl, dirty_buffs
 518: 3117+11	023C' 34      	                inc (hl)
 519:				;
 520: 3128+10	023D' E1      	mws_exit        pop hl                      ; Restore next address
 521: 3138+4	023E' AF      	                xor a                       ; Indicate success
 522: 3142+10	023F' C9      	                ret
 523:				;
 524:				;
 525:				; Read CP/M sector. Length is CPM_SECTOR_SIZE bytes.
 526:				; Call with:
 527:				; CDE - CP/M (128-byte) sector number (offset into partition)
 528:				; HL - destination address
 529:				; IX - pointer to partition table entry structure
 530:				; Returns with:
 531:				; A - zero (OK) or error code (SPI_ERR_xxx)
 532:				; HL - updated pointer to destination (points to location after last written)
 533:				; IX is preserved.
 534: 3152+11	0240' C5      	cacrs           push bc
 535: 3163+15	0241' DDE5    	                push ix
 536: 3178+11	0243' E5      	                push hl
 537: 3189+17	0244' CD8203  	                call cpm_to_mmc         ; Find 512-byte sector and offset
 538: 3206+10+7	0247' DC0000  	                call c, panic           ; Panic if sector out of range
 539:				; CDE - MMC (512-byte) sector number
 540:				; HL - offset into sector (0, 128, 256 or 384)
 541: 3216+11	024A' E5      	                push hl
 542: 3227+17	024B' CDBF01  	                call read_mmc_sect      ; Read MMC sector into cache
 543:				; A - zero (OK) or error code (SPI_ERR_xxx)
 544:				; IX - points to sector cache structure entry used.
 545: 3244+4	024E' A7      	                and a
 546: 3248+7+5	024F' 2804    	                jr z, crs_rd_ok         ; Exit with error code in A
 547:				;
 548:				; An error has occurred. Return with error code in A.
 549: 3255+10	0251' E1      	                pop hl                  ; Discard offset into sector
 550: 3265+10	0252' E1      	                pop hl
 551: 3275+12	0253' 1811    	                jr crs_exit
 552:				;
 553:				; Find start of sector data.
 554: 3287+15	0255' DDE5    	crs_rd_ok       push ix
 555: 3302+10	0257' E1      	                pop hl
 556: 3312+10	0258' 010600  	                ld bc, MCCAS_DATA
 557: 3322+11	025B' 09      	                add hl, bc
 558:				; HL - start of MMC sector data.
 559: 3333+10	025C' C1      	                pop bc
 560: 3343+11	025D' 09      	                add hl, bc              ; Add offset into sector
 561: 3354+10	025E' D1      	                pop de
 562: 3364+10	025F' 018000  	                ld bc, CPM_SECTOR_SIZE  ; Length
 563:				; BC - byte counter
 564:				; DE - destination address
 565:				; HL - address of sector data
 566: 3374+16+5	0262' EDB0    	                ldir
 567: 3390+4	0264' EB      	                ex de, hl                   ; Move next address to HL
 568: 3394+4	0265' AF      	                xor a                       ; Indicate success
 569: 3398+14	0266' DDE1    	crs_exit        pop ix
 570: 3412+10	0268' C1      	                pop bc
 571: 3422+10	0269' C9      	                ret
 572:				;
 573:				;
 574:				; Write CP/M sector. Length is CPM_SECTOR_SIZE bytes.
 575:				; Call with:
 576:				; CDE - CP/M (128-byte) sector number (offset into partition)
 577:				; HL - source address
 578:				; IX - pointer to partition table entry structure
 579:				; Returns with:
 580:				; A - zero (OK) or error code (SPI_ERR_xxx)
 581:				; HL - updated pointer to source (points to location after last read)
 582:				; IX is preserved.
 583: 3432+11	026A' C5      	cacws           push bc
 584: 3443+15	026B' DDE5    	                push ix
 585: 3458+4	026D' D9      	                exx
 586: 3462+11	026E' D5      	                push de                 ; Save DE' and HL'
 587: 3473+11	026F' E5      	                push hl
 588: 3484+4	0270' D9      	                exx
 589: 3488+11	0271' E5      	                push hl
 590: 3499+17	0272' CD8203  	                call cpm_to_mmc         ; Find 512-byte sector and offset
 591: 3516+10+7	0275' DC0000  	                call c, panic           ; Panic if sector out of range
 592:				; CDE - MMC (512-byte) sector number
 593:				; HL - offset into sector (0, 128, 256 or 384)
 594: 3526+11	0278' E5      	                push hl
 595:				; As we are writing only part of an MMC sector, we must first read the sector
 596:				; into cache.
 597: 3537+17	0279' CDBF01  	                call read_mmc_sect      ; Read MMC sector into cache
 598:				; A - zero (OK) or error code (SPI_ERR_xxx)
 599:				; IX - points to sector cache structure entry used.
 600: 3554+4	027C' A7      	                and a
 601: 3558+7+5	027D' 2804    	                jr z, cws_rd_ok         ; Exit with error code in A
 602:				;
 603:				; An error has occurred. Return with error code in A.
 604: 3565+10	027F' E1      	                pop hl                  ; Discard offset into sector
 605: 3575+10	0280' E1      	                pop hl
 606: 3585+12	0281' 185A    	                jr cws_exit
 607:				;
 608:				; Find start of sector data.
 609: 3597+15	0283' DDE5    	cws_rd_ok       push ix
 610: 3612+10	0285' E1      	                pop hl
 611: 3622+10	0286' 010600  	                ld bc, MCCAS_DATA
 612: 3632+11	0289' 09      	                add hl, bc
 613:				; HL - start of MMC sector data.
 614: 3643+10	028A' C1      	                pop bc
 615: 3653+11	028B' 09      	                add hl, bc              ; Add offset into sector
 616:				;
 617:				; BC - offset into sector (0, 128, 256 or 384)
 618: 3664+19	028C' DD7E00  	                ld a, (ix + MCCAS_STATUS)
 619: 3683+13	028F' 320300  	                ld (mws_buff_status), a ; Save old status
 620:				; Find relevant status bit and mark it dirty.
 621: 3696+7	0292' 3E01    	                ld a, 1
 622: 3703+8	0294' CB18    	                rr b                    ; Find bit 1
 623: 3711+7+5	0296' 3002    	                jr nc, cws_fmask_1dn
 624: 3718+4	0298' 07      	                rlca                     ; Move mask twice if bit 1 is set
 625: 3722+4	0299' 07      	                rlca
 626: 3726+8	029A' CB11    	cws_fmask_1dn   rl c                    ; Find bit 0
 627: 3734+7+5	029C' 3001    	                jr nc, cws_fmask_0dn
 628: 3741+4	029E' 07      	                rlca                     ; Move mask once if bit 0 is set
 629:				; A - status bit mask (MCCAS_STAT_CPMx_MASK)
 630: 3745+19	029F' DDB600  	cws_fmask_0dn   or (ix + MCCAS_STATUS)
 631: 3764+19	02A2' DD7700  	                ld (ix + MCCAS_STATUS), a   ; Set relevant dirty bit
 632:				;
 633: 3783+10	02A5' D1      	                pop de                  ; Source address
 634: 3793+4	02A6' EB      	                ex de, hl
 635:				; DE - address of sector data
 636:				; HL - source address
 637: 3797+10	02A7' 018000  	                ld bc, CPM_SECTOR_SIZE  ; Length
 638: 3807+4	02AA' D9      	                exx
 639: 3811+19	02AB' DD6E04  	                ld l, (ix + MCCAS_CSUM)
 640: 3830+19	02AE' DD6605  	                ld h, (ix + MCCAS_CSUM + 1)
 641: 3849+7	02B1' 1600    	                ld d, 0                 ; Pre-load high byte for 16-bit add
 642: 3856+4	02B3' D9      	                exx
 643:				; BC - byte counter
 644:				; H'L' - checksum
 645:				; DE - address of sector data
 646:				; HL - source address
 647:				; Copy the data, updating the checksum as we go.
 648: 3860+7	02B4' 1A      	cws_copy_loop   ld a, (de)
 649: 3867+4	02B5' D9      	                exx
 650: 3871+4	02B6' 5F      	                ld e, a
 651: 3875+4	02B7' A7      	                and a
 652: 3879+15	02B8' ED52    	                sbc hl, de              ; Subtract old byte from checksum
 653: 3894+4	02BA' D9      	                exx
 654: 3898+7	02BB' 7E      	                ld a, (hl)              ; Fetch new byte
 655: 3905+16	02BC' EDA0    	                ldi                     ; Copy the byte and update pointers etc.
 656: 3921+4	02BE' D9      	                exx
 657: 3925+4	02BF' 5F      	                ld e, a
 658: 3929+11	02C0' 19      	                add hl, de              ; Add new byte to checksum
 659: 3940+4	02C1' D9      	                exx
 660: 3944+4	02C2' 78      	                ld a, b
 661: 3948+4	02C3' B1      	                or c
 662: 3952+7+5	02C4' 20EE    	                jr nz, cws_copy_loop
 663:				; Write new checksum.
 664: 3959+4	02C6' D9      	                exx
 665: 3963+19	02C7' DD7504  	                ld (ix + MCCAS_CSUM), l
 666: 3982+19	02CA' DD7405  	                ld (ix + MCCAS_CSUM + 1), h
 667: 4001+4	02CD' D9      	                exx
 668:				;
 669:				; Update dirty buffer count if appropriate.
 670: 4005+13	02CE' 3A0300  	                ld a, (mws_buff_status)     ; Fetch old buffer status
 671: 4018+7	02D1' E60F    	                and MCCAS_STAT_DIRT_MASK
 672: 4025+7+5	02D3' 2007    	                jr nz, cws_success          ; Exit if buffer was already dirty
 673:				; Increment dirty count.
 674: 4032+13	02D5' 3A0200  	                ld a, (dirty_buffs)
 675: 4045+4	02D8' 3C      	                inc a
 676: 4049+13	02D9' 320200  	                ld (dirty_buffs), a
 677:				;
 678: 4062+4	02DC' AF      	cws_success     xor a                       ; Indicate success
 679: 4066+4	02DD' D9      	cws_exit        exx
 680: 4070+10	02DE' E1      	                pop hl
 681: 4080+10	02DF' D1      	                pop de
 682: 4090+4	02E0' D9      	                exx
 683: 4094+14	02E1' DDE1    	                pop ix
 684: 4108+10	02E3' C1      	                pop bc
 685: 4118+10	02E4' C9      	                ret
 686:				;
 687:				;
 688:				; Find a space to store a new sector. This is used by both sector reads and sector
 689:				; writes.
 690:				; Call with:
 691:				; CDE - sector number (0 to (sectors - 1)) for new buffer.
 692:				; Returns with:
 693:				; A - zero (OK) or error code (SPI_ERR_xxx)
 694:				; IX - pointer to partition table entry structure
 695: 4128+17	02E5' CD4401  	find_new_buff   call maintain               ; Maintain cache dirtiness level
 696:				; We are now guaranteed to have at least one buffer available.
 697: 4145+11	02E8' E5      	                push hl
 698: 4156+11	02E9' C5      	                push bc
 699: 4167+11	02EA' D5      	                push de
 700:				; First look for an unused buffer. In order to avoid using the same buffer and
 701:				; associated sectors every time, next_buff is used as the start point for the
 702:				; search.
 703: 4178+13	02EB' 3A0000  	                ld a, (next_buff)           ; Start searching from this point
 704: 4191+4	02EE' 4F      	                ld c, a                     ; Save for later
 705: 4195+17	02EF' CD0104  	                call num_to_addr
 706: 4212+7	02F2' 0610    	                ld b, MCCA_BUFFERS          ; Number of sector buffer structures
 707:				; B - loop counter
 708:				; C - sector buffer structure number
 709:				; IX - structure address
 710: 4219+10	02F4' 110602  	                ld de, MCCAS_SIZE           ; Pre-load structure size
 711: 4229+20	02F7' DDCB0066	fnb_unu_loop    bit MCCAS_STAT_VALID_BIT, (ix + MCCAS_STATUS)
 712: 4249+7+5	02FB' 2836    	                jr z, fnb_found_new         ; Jump if buffer is unused
 713:				; Buffer is already in use.
 714: 4256+15	02FD' DD19    	                add ix, de
 715: 4271+4	02FF' 0C      	                inc c
 716: 4275+4	0300' 79      	                ld a, c
 717: 4279+7	0301' FE10    	                cp MCCA_BUFFERS
 718: 4286+7+5	0303' 3806    	                jr c, fnb_unu_end
 719:				; Wrap-around required.
 720: 4293+14	0305' DD210400	                ld ix, cache_buffers
 721: 4307+7	0309' 0E00    	                ld c, 0
 722: 4314+8+5	030B' 10EA    	fnb_unu_end     djnz fnb_unu_loop
 723:				;
 724:				; All buffers are in use. Now try for a "clean" buffer (i.e. one with no unwritten
 725:				; data).
 726: 4322+13	030D' 3A0000  	                ld a, (next_buff)           ; Start searching from this point
 727: 4335+4	0310' 4F      	                ld c, a                     ; Save for later
 728: 4339+17	0311' CD0104  	                call num_to_addr
 729: 4356+7	0314' 0610    	                ld b, MCCA_BUFFERS          ; Number of sector buffer structures
 730:				; B - loop counter
 731:				; C - sector buffer structure number
 732:				; IX - structure address
 733: 4363+10	0316' 110602  	                ld de, MCCAS_SIZE           ; Pre-load structure size
 734: 4373+19	0319' DD7E00  	fnb_cln_loop    ld a, (ix + MCCAS_STATUS)
 735: 4392+7	031C' FE10    	                cp MCCAS_STAT_VALID_MASK
 736: 4399+7+5	031E' 2817    	                jr z, fnb_found_used        ; Jump if buffer is valid and clean
 737:				; Buffer is dirty (has unwritten data).
 738: 4406+15	0320' DD19    	                add ix, de
 739: 4421+4	0322' 0C      	                inc c
 740: 4425+4	0323' 79      	                ld a, c
 741: 4429+7	0324' FE10    	                cp MCCA_BUFFERS
 742: 4436+7+5	0326' 3806    	                jr c, fnb_cln_end
 743:				; Wrap-around required.
 744: 4443+14	0328' DD210400	                ld ix, cache_buffers
 745: 4457+7	032C' 0E00    	                ld c, 0
 746: 4464+8+5	032E' 10E9    	fnb_cln_end     djnz fnb_cln_loop
 747:				; All buffers are dirty. This should not be the case, as the "maintain" call
 748:				; earlier should not allow this.
 749: 4472+17	0330' CD0000  	                call panic
 750:				;
 751:				; We have found an unused buffer to use.
 752: 4489+10	0333' 210100  	fnb_found_new   ld hl, used_buffs
 753: 4499+11	0336' 34      	                inc (hl)                    ; Mark one more in use
 754:				;
 755:				; Go here if a search revealed found a buffer we can use, rather than having
 756:				; to force one to be freed.
 757:				; C - sector buffer structure number
 758:				; IX - structure address
 759: 4510+10	0337' 210000  	fnb_found_used  ld hl, next_buff
 760: 4520+7	033A' 71      	                ld (hl), c
 761: 4527+17	033B' CD5403  	                call inc_next_buff          ; Increment and wrap-around
 762:				;
 763: 4544+19	033E' DD360000	fnb_have_buff   ld (ix + MCCAS_STATUS), 0   ; Mark buffer unused
 764: 4563+10	0342' D1      	                pop de                      ; Restore sector number
 765: 4573+10	0343' C1      	                pop bc
 766:				; CDE - sector number
 767:				; HL - sector buffer start address
 768: 4583+19	0344' DD7301  	                ld (ix + MCCAS_SECTOR), e
 769: 4602+19	0347' DD7202  	                ld (ix + MCCAS_SECTOR + 1), d
 770: 4621+19	034A' DD7103  	                ld (ix + MCCAS_SECTOR + 2), c
 771:				; IX - address of sector buffer structure containing the required sector.
 772: 4640+4	034D' AF      	                xor a                       ; Indicate success
 773: 4644+10	034E' E1      	fnb_exit        pop hl
 774: 4654+10	034F' C9      	                ret
 775:				;
 776:				; Exit with error code in A.
 777: 4664+10	0350' D1      	fnb_error       pop de                      ; Restore sector number
 778: 4674+10	0351' C1      	                pop bc
 779: 4684+12	0352' 18FA    	                jr fnb_exit
 780:				;
 781:				;
 782:				; Increment next_buff and wrap around if necessary.
 783: 4696+11	0354' E5      	inc_next_buff   push hl
 784: 4707+10	0355' 210000  	                ld hl, next_buff
 785: 4717+7	0358' 7E      	                ld a, (hl)
 786: 4724+4	0359' 3C      	                inc a
 787: 4728+7	035A' FE10    	                cp MCCA_BUFFERS
 788: 4735+7+5	035C' 3801    	                jr c, inb_inc_dn
 789: 4742+4	035E' AF      	                xor a                       ; Reset on overflow
 790: 4746+7	035F' 77      	inb_inc_dn      ld (hl), a
 791: 4753+10	0360' E1      	                pop hl
 792: 4763+10	0361' C9      	                ret
 793:				;
 794:				;
 795:				; Calculate checksum (simple sum of all of the bytes in the sector data).
 796:				; Call with:
 797:				; IX - points to sector cache structure entry
 798:				; Returns with:
 799:				; HL - checksum
 800:				; IX is preserved.
 801: 4773+11	0362' C5      	calc_csum       push bc
 802: 4784+11	0363' D5      	                push de
 803:				; Find start of sector data.
 804: 4795+15	0364' DDE5    	                push ix
 805: 4810+10	0366' E1      	                pop hl
 806: 4820+10	0367' 010600  	                ld bc, MCCAS_DATA
 807: 4830+11	036A' 09      	                add hl, bc
 808: 4841+10	036B' 010002  	                ld bc, MMC_SECTOR_SIZE      ; Length
 809: 4851+10	036E' 110000  	                ld de, 0
 810: 4861+4	0371' 7B      	csum_loop       ld a, e
 811: 4865+7	0372' 86      	                add (hl)
 812: 4872+4	0373' 5F      	                ld e, a
 813: 4876+4	0374' 7A      	                ld a, d
 814: 4880+7	0375' CE00    	                adc 0                       ; Propagate carry
 815: 4887+4	0377' 57      	                ld d, a
 816: 4891+6	0378' 23      	                inc hl                      ; Next address
 817: 4897+6	0379' 0B      	                dec bc
 818: 4903+4	037A' 78      	                ld a, b
 819: 4907+4	037B' B1      	                or c
 820: 4911+7+5	037C' 20F3    	                jr nz, csum_loop
 821: 4918+4	037E' EB      	                ex de, hl                   ; Move result to HL
 822: 4922+10	037F' D1      	                pop de
 823: 4932+10	0380' C1      	                pop bc
 824: 4942+10	0381' C9      	                ret
 825:				;
 826:				;
 827:				; Convert CP/M 128-byte sector number into a 512-byte one in the relevant
 828:				; partition.
 829:				; Call with:
 830:				; CDE - CP/M (128-byte) sector number (offset into partition)
 831:				; IX - pointer to partition table entry structure
 832:				; Returns with:
 833:				; CDE - MMC (512-byte) sector number
 834:				; HL - offset into sector (0, 128, 256 or 384)
 835:				; IX - preserved
 836:				; carry - set on error (sector out of range)
 837:     -	0001'         	                assert MMC_SECTOR_SIZE = (CPM_SECTOR_SIZE << 2)
 838: 4952+11	0382' C5      	cpm_to_mmc      push bc                 ; Save B
 839: 4963+4	0383' AF      	                xor a                   ; Clear A and reset carry
 840: 4967+8	0384' CB19    	                rr c                    ; Divide sector number by two
 841: 4975+8	0386' CB1A    	                rr d
 842: 4983+8	0388' CB1B    	                rr e
 843: 4991+4	038A' 1F      	                rra                     ; Save bit 7 of the offset
 844:				; A bit 7 = bit 7
 845: 4995+4	038B' A7      	                and a                   ; Divide by two again
 846: 4999+8	038C' CB19    	                rr c
 847: 5007+8	038E' CB1A    	                rr d
 848: 5015+8	0390' CB1B    	                rr e
 849: 5023+4	0392' 17      	                rla                     ; Save bit 8 of the offset
 850:				; A bit 0 = bit 8
 851:				; Carry = bit 7
 852: 5027+4	0393' 17      	                rla
 853:				; A bit 1 = bit 8
 854:				; A bit 0 = bit 7
 855: 5031+4	0394' 47      	                ld b, a
 856:				; B - CP/M sector number within MMC sector (0 - 3)
 857:				; CDE - 512-byte sector offset into partition
 858:				; Check that the sector is within the partition. Subtracting the partition size
 859:				; should cause a carry.
 860: 5035+4	0395' 7B      	                ld a, e
 861: 5039+19	0396' DD960C  	                sub (ix + DPART_SIZE_SECS)
 862: 5058+4	0399' 7A      	                ld a, d
 863: 5062+19	039A' DD9E0D  	                sbc (ix + DPART_SIZE_SECS + 1)
 864: 5081+4	039D' 79      	                ld a, c
 865: 5085+19	039E' DD9E0E  	                sbc (ix + DPART_SIZE_SECS + 2)
 866: 5104+7	03A1' 3E00    	                ld a, 0
 867: 5111+19	03A3' DD9E0F  	                sbc (ix + DPART_SIZE_SECS + 3)
 868: 5130+7+5	03A6' 3025    	                jr nc, ctm_error
 869:				; Add start sector of partition.
 870: 5137+4	03A8' 7B      	                ld a, e
 871: 5141+19	03A9' DD8608  	                add (ix + DPART_START_LBA)
 872: 5160+4	03AC' 5F      	                ld e, a
 873: 5164+4	03AD' 7A      	                ld a, d
 874: 5168+19	03AE' DD8E09  	                adc (ix + DPART_START_LBA + 1)
 875: 5187+4	03B1' 57      	                ld d, a
 876: 5191+4	03B2' 79      	                ld a, c
 877: 5195+19	03B3' DD8E0A  	                adc (ix + DPART_START_LBA + 2)
 878: 5214+4	03B6' 4F      	                ld c, a
 879: 5218+4	03B7' AF      	                xor a
 880: 5222+19	03B8' DD8E0B  	                adc (ix + DPART_START_LBA + 3)
 881:				; The result should fit in 24 bits, so A should be zero
 882: 5241+4	03BB' A7      	                and a
 883: 5245+10+7	03BC' C40000  	                call nz, panic
 884:				; Find offset into sector.
 885: 5255+10	03BF' 210000  	                ld hl, 0
 886: 5265+4	03C2' 78      	                ld a, b                 ; Fetch offset bits
 887: 5269+4	03C3' 1F      	                rra                     ; Rotate bit 7 into carry
 888: 5273+8	03C4' CB1D    	                rr l
 889: 5281+4	03C6' 1F      	                rra                     ; Rotate bit 8 into carry
 890: 5285+8	03C7' CB14    	                rl h
 891:				; Restore B (from BC on stack).
 892: 5293+10	03C9' F1      	                pop af
 893: 5303+4	03CA' 47      	                ld b, a
 894: 5307+4	03CB' A7      	                and a                   ; Flag success
 895: 5311+10	03CC' C9      	                ret
 896:				;
 897:				; Error exit (with carry set).
 898:				; Restore B (from BC on stack).
 899: 5321+10	03CD' F1      	ctm_error       pop af
 900: 5331+4	03CE' 47      	                ld b, a
 901: 5335+4	03CF' 37      	                scf
 902: 5339+10	03D0' C9      	                ret
 903:				;
 904:				;
 905:				; Attempt to locate an MMC sector in the cache.
 906:				; CDE - sector number
 907:				; Returns with:
 908:				; IX - points to the relevant buffer structure if found
 909:				; carry - set if sector found in the cache
 910: 5349+11	03D1' C5      	find_sec        push bc
 911: 5360+11	03D2' E5      	                push hl
 912: 5371+14	03D3' DD210400	                ld ix, cache_buffers        ; Point to first buffer
 913: 5385+10	03D7' 210602  	                ld hl, MCCAS_SIZE           ; Pre-load structure size
 914: 5395+7	03DA' 0610    	                ld b, MCCA_BUFFERS          ; Number of sector buffer structures
 915: 5402+20	03DC' DDCB0066	infs_sec_loop   bit MCCAS_STAT_VALID_BIT, (ix + MCCAS_STATUS)
 916: 5422+7+5	03E0' 2815    	                jr z, infs_next             ; Skip if no valid data
 917: 5429+19	03E2' DD7E01  	                ld a, (ix + MCCAS_SECTOR)
 918: 5448+4	03E5' BB      	                cp e
 919: 5452+7+5	03E6' 200F    	                jr nz, infs_next
 920: 5459+19	03E8' DD7E02  	                ld a, (ix + MCCAS_SECTOR + 1)
 921: 5478+4	03EB' BA      	                cp d
 922: 5482+7+5	03EC' 2009    	                jr nz, infs_next
 923: 5489+19	03EE' DD7E03  	                ld a, (ix + MCCAS_SECTOR + 2)
 924: 5508+4	03F1' B9      	                cp c
 925: 5512+7+5	03F2' 2003    	                jr nz, infs_next
 926:				; Sector found!
 927: 5519+4	03F4' 37      	                scf
 928: 5523+12	03F5' 1807    	                jr infs_exit
 929:				; Update pointer without disturbing DE.
 930: 5535+4	03F7' EB      	infs_next       ex de, hl
 931: 5539+15	03F8' DD19    	                add ix, de
 932: 5554+4	03FA' EB      	                ex de, hl
 933: 5558+8+5	03FB' 10DF    	                djnz infs_sec_loop
 934: 5566+4	03FD' A7      	                and a                       ; Reset carry (indicate not found)
 935: 5570+10	03FE' E1      	infs_exit       pop hl
 936: 5580+10	03FF' C1      	                pop bc
 937: 5590+10	0400' C9      	                ret
 938:				;
 939:				;
 940:				; Find sector buffer structure address from index number.
 941:				; Call with:
 942:				; A - buffer number (0 to (MCCA_BUFFERS - 1))
 943:				; Returns with:
 944:				; IX - structure address
 945: 5600+11	0401' C5      	num_to_addr     push bc
 946: 5611+11	0402' D5      	                push de
 947: 5622+11	0403' E5      	                push hl
 948: 5633+7	0404' FE10    	                cp MCCA_BUFFERS
 949: 5640+7+5	0406' 3803    	                jr c, nta_nrb_ok
 950: 5647+17	0408' CD0000  	                call panic                  ; Should never go here
 951:				; Find the corresponding address.
 952: 5664+7	040B' 0600    	nta_nrb_ok      ld b, 0
 953: 5671+4	040D' 4F      	                ld c, a
 954: 5675+10	040E' 110602  	                ld de, MCCAS_SIZE           ; Structure size
 955: 5685+17	0411' CD0000  	                call mamwwu                 ; 16-bit * 16-bit unsigned multiply
 956:				; DEHL - result
 957: 5702+4	0414' 7A      	                ld a, d
 958: 5706+4	0415' B3      	                or e
 959: 5710+10+7	0416' C40000  	                call nz, panic              ; MS 16 bits should be zero
 960: 5720+10	0419' 010400  	                ld bc, cache_buffers
 961: 5730+11	041C' 09      	                add hl, bc                  ; Add base address
 962: 5741+11	041D' E5      	                push hl
 963: 5752+14	041E' DDE1    	                pop ix
 964: 5766+10	0420' E1      	                pop hl
 965: 5776+10	0421' D1      	                pop de
 966: 5786+10	0422' C1      	                pop bc
 967: 5796+10	0423' C9      	                ret
 968:				;
 969:				;
 970:				;
 971:				; *************
 972:				; * Constants *
 973:				; *************
 974:				;
 975:     -	0424' 4D4D4320	rpt_title_msg   byte "MMC Cache Status:", 0x0d, 0x0a, 0
	              43616368
	              65205374
	              61747573
	              3A0D0A00
 976:     -	0438' 202D2000	rpt_sep_msg     byte " - ", 0
 977:     -	043C' 756E7573	rpt_unused_msg  byte "unused", 0
	              656400
 978:     -	0443' 636C6561	rpt_clean_msg   byte "clean", 0
	              6E00
 979:     -	0449' 64697274	rpt_dirty_msg   byte "dirty", 0
	              7900
 980:     -	044F' 67727562	rpt_grubby_msg  byte "grubby: ", 0
	              62793A20
	              00
 981:     -	0458' 496E2075	rpt_usedc_msg   byte "In use: ", 0
	              73653A20
	              00
 982:     -	0461' 2C206469	rpt_dirtyc_msg  byte ", dirty: ", 0
	              7274793A
	              2000
 983:     -	046B' 2C206E65	rpt_nexrd_msg   byte ", next read buffer: ", 0
	              78742072
	              65616420
	              62756666
	              65723A20
	              00
 984:     -	0480' 2C206368	rpt_badsum_msg  byte ", checksum error!", 0
	              65636B73
	              756D2065
	              72726F72
	              2100
 985:     -	0492' 20636F72	in_badsum_msg   byte " corrupt MMC cache buffers discarded!", 0x0d, 0x0a, 0
	              72757074
	              204D4D43
	              20636163
	              68652062
	              75666665
	              72732064
	              69736361
	              72646564
	              210D0A00
 986:				;
 987:				;
 988:				;
 989:				; *************
 990:				; * Variables *
 991:				; *************
 992:				;
 993:				;
 994:				; Note: linker "-c" option is used, so no data is initialised here.
 995:				                dseg                ; Data segment
 996:				;
 997:     -	0000"         	next_buff       defs 1              ; Preferred next buffer to use
 998:     -	0001"         	used_buffs      defs 1              ; Number of buffers in use
 999:     -	0002"         	dirty_buffs     defs 1              ; Number of dirty buffers
1000:     -	0003"         	mws_buff_status defs 1              ; Temporary sector buffer status
1001:     -	0004"         	cache_buffers   defs MCCAS_SIZE * MCCA_BUFFERS  ; Sector buffer structures
1002:				;
1003:     -	2064"         	                end



Statistics:

     4	passes
     0	jr promotions
   606	symbols
  1210	bytes

   278	macro calls
  1320	macro bytes
     0	invented symbols



Symbol Table:

BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
CCP_START      =D600      54784
CDISK          =04        4
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPART_END_CYL  =07        7
DPART_END_HD   =05        5
DPART_END_SEC  =06        6
DPART_SIZE     =10        16
DPART_SIZE_SECS=0C        12
DPART_START_CYL=03        3
DPART_START_HD =01        1
DPART_START_LBA=08        8
DPART_START_SEC=02        2
DPART_STATUS   =00        0
DPART_TYPE     =04        4
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
DSK_BOOT_SIGN  =AA55      43605
DSK_BOOT_SIGN_OFFSET= 1FE      510
DSK_MAX_PARTS  =04        4
DSK_PART1_OFFSET= 1BE      446
DSK_PART_TYP_EXPER=7F        127
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
I2C_CSR_ACKN_BIT=00        0
I2C_CSR_ACKN_MASK=01        1
I2C_CSR_BUSY_BIT=07        7
I2C_CSR_BUSY_MASK=80        128
I2C_CSR_START_BIT=01        1
I2C_CSR_START_MASK=02        2
I2C_CSR_STOP_BIT=02        2
I2C_CSR_STOP_MASK=04        4
INTS_NUM       =08        8
INT_SER1_RX_BIT=01        1
INT_SER1_RX_MASK=02        2
INT_SER1_RX_VEC=01        1
INT_SER1_TX_BIT=00        0
INT_SER1_TX_MASK=01        1
INT_SER1_TX_VEC=00        0
INT_SER2_RX_BIT=03        3
INT_SER2_RX_MASK=08        8
INT_SER2_RX_VEC=03        3
INT_SER2_TX_BIT=02        2
INT_SER2_TX_MASK=04        4
INT_SER2_TX_VEC=02        2
INT_TICK_BIT   =04        4
INT_TICK_MASK  =10        16
INT_TICK_VEC   =04        4
INT_VEC_TABLE  =FFE0      65504
IOA_CONTROL    =02        2
IOA_CRC_0      =24        36
IOA_CRC_1      =25        37
IOA_CRC_DATA   =26        38
IOA_FPGA_MAJREV=00        0
IOA_FPGA_MINREV=01        1
IOA_FP_SW      =03        3
IOA_I2C_CSR    =18        24
IOA_I2C_DATA   =19        25
IOA_INT_EN     =08        8
IOA_INT_PEND   =0A        10
IOA_MMAP_0     =04        4
IOA_MMAP_1     =05        5
IOA_MMAP_2     =06        6
IOA_MMAP_3     =07        7
IOA_NMI_REASONS=0C        12
IOA_SER1_CSR   =10        16
IOA_SER1_DATA  =11        17
IOA_SER2_CSR   =12        18
IOA_SER2_DATA  =13        19
IOA_SPI_CSR    =20        32
IOA_SPI_DATA   =21        33
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MCCAS_CSUM     =04        4
MCCAS_DATA     =06        6
MCCAS_SECTOR   =01        1
MCCAS_SIZE     = 206      518
MCCAS_STATUS   =00        0
MCCAS_STAT_CPM0_BIT=00        0
MCCAS_STAT_CPM0_MASK=01        1
MCCAS_STAT_CPM1_BIT=01        1
MCCAS_STAT_CPM1_MASK=02        2
MCCAS_STAT_CPM2_BIT=02        2
MCCAS_STAT_CPM2_MASK=04        4
MCCAS_STAT_CPM3_BIT=03        3
MCCAS_STAT_CPM3_MASK=08        8
MCCAS_STAT_DIRT_MASK=0F        15
MCCAS_STAT_VALID_BIT=04        4
MCCAS_STAT_VALID_MASK=10        16
MCCA_BUFFERS   =10        16
MCCA_DIRT_THRES=08        8
MC_STATES      =02        2
MMAP_CPM_PAGES =04        4
MMAP_PAGE_MASK =3F        63
MMAP_PROT_BIT  =07        7
MMAP_PROT_MASK =80        128
MMAP_SUPER_BIT =06        6
MMAP_SUPER_MASK=40        64
MMC_ACMD_MC_SEND_OP_COND=29        41
MMC_ARG1       =01        1
MMC_ARG2       =02        2
MMC_ARG3       =03        3
MMC_ARG4       =04        4
MMC_CID_CRC    =0F        15
MMC_CID_MDT    =0E        14
MMC_CID_MID    =00        0
MMC_CID_OID    =01        1
MMC_CID_PNM    =03        3
MMC_CID_PNM_SIZE=06        6
MMC_CID_PRV    =09        9
MMC_CID_PSN    =0A        10
MMC_CID_SIZE   =10        16
MMC_CMD        =00        0
MMC_CMD_APP_CMD=37        55
MMC_CMD_CRC_ON_OFF=3B        59
MMC_CMD_GO_IDLE_STATE=00        0
MMC_CMD_READ_SINGLE_BLOCK=11        17
MMC_CMD_SEND_CID=0A        10
MMC_CMD_SEND_CSD=09        9
MMC_CMD_SEND_OP_COND=01        1
MMC_CMD_SEND_STATUS=0D        13
MMC_CMD_SET_BLOCKLEN=10        16
MMC_CMD_START  =40        64
MMC_CMD_STOP   =01        1
MMC_CMD_WRITE_BLOCK=18        24
MMC_CRC        =05        5
MMC_CSD_15_8   =0E        14
MMC_CSD_23_16  =0D        13
MMC_CSD_31_24  =0C        12
MMC_CSD_39_32  =0B        11
MMC_CSD_47_40  =0A        10
MMC_CSD_55_48  =09        9
MMC_CSD_63_56  =08        8
MMC_CSD_71_64  =07        7
MMC_CSD_79_72  =06        6
MMC_CSD_87_80  =05        5
MMC_CSD_95_88  =04        4
MMC_CSD_CRC    =0F        15
MMC_CSD_NSAC   =02        2
MMC_CSD_SIZE   =10        16
MMC_CSD_TAAC   =01        1
MMC_CSD_TR_SPD =03        3
MMC_CSD_VERSION=00        0
MMC_LOG2_SEC_SIZE=09        9
MMC_R1_ADDR_ERR_BIT=05        5
MMC_R1_ADDR_ERR_MASK=20        32
MMC_R1_CMD_CRC_ERR_BIT=03        3
MMC_R1_CMD_CRC_ERR_MASK=08        8
MMC_R1_ERA_RST_BIT=01        1
MMC_R1_ERA_RST_MASK=02        2
MMC_R1_ERA_SEQ_ERR_BIT=04        4
MMC_R1_ERA_SEQ_ERR_MASK=10        16
MMC_R1_IDLE_BIT=00        0
MMC_R1_IDLE_MASK=01        1
MMC_R1_ILL_CMD_BIT=02        2
MMC_R1_ILL_CMD_MASK=04        4
MMC_R1_PAR_ERR_BIT=06        6
MMC_R1_PAR_ERR_MASK=40        64
MMC_R1_START_BIT=07        7
MMC_R1_START_MASK=80        128
MMC_SECTOR_SIZE= 200      512
MMC_SIZE       =06        6
MMC_STAT_IDLE  =00        0
MMC_STAT_INIT  =01        1
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MS_PER_TICK    =64        100
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NMI_PROT_VIOL_BIT=01        1
NMI_PROT_VIOL_MASK=02        2
NMI_REASONS_ALL=0F        15
NMI_REASONS_NUM=04        4
NMI_SUPER_VIOL_BIT=02        2
NMI_SUPER_VIOL_MASK=04        4
NMI_SWITCH_BIT =00        0
NMI_SWITCH_MASK=01        1
NMI_TRACE_BIT  =03        3
NMI_TRACE_MASK =08        8
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
PORT_SER1      =00        0
PORT_SER2      =01        1
PORT_STATES    =02        2
SER_CSR_FRAME_ERR_BIT=03        3
SER_CSR_FRAME_ERR_MASK=08        8
SER_CSR_RX_ALHALF_BIT=01        1
SER_CSR_RX_ALHALF_MASK=02        2
SER_CSR_RX_EMPTY_BIT=00        0
SER_CSR_RX_EMPTY_MASK=01        1
SER_CSR_RX_FULL_BIT=02        2
SER_CSR_RX_FULL_MASK=04        4
SER_CSR_TX_ALHALF_BIT=05        5
SER_CSR_TX_ALHALF_MASK=20        32
SER_CSR_TX_EMPTY_BIT=04        4
SER_CSR_TX_EMPTY_MASK=10        16
SER_CSR_TX_FULL_BIT=06        6
SER_CSR_TX_FULL_MASK=40        64
SPI_CSR_BUSY_BIT=07        7
SPI_CSR_BUSY_MASK=80        128
SPI_CSR_FAST_BIT=00        0
SPI_CSR_FAST_MASK=01        1
SPI_CSR_MC_SS_BIT=01        1
SPI_CSR_MC_SS_MASK=02        2
SYSCTRL_MAPARM_BIT=03        3
SYSCTRL_MAPARM_MASK=08        8
SYSCTRL_MMAPN_BIT=04        4
SYSCTRL_MMAPN_MASK=10        16
SYSCTRL_MMAP_BIT=01        1
SYSCTRL_MMAP_MASK=02        2
SYSCTRL_NMCLR_BIT=02        2
SYSCTRL_NMCLR_MASK=04        4
SYSCTRL_RESERVED_BIT=07        7
SYSCTRL_RESERVED_MASK=80        128
SYSCTRL_TRARM_BIT=00        0
SYSCTRL_TRARM_MASK=01        1
SYSCTRL_TRPRE0_BIT=05        5
SYSCTRL_TRPRE0_MASK=20        32
SYSCTRL_TRPRE1_BIT=06        6
SYSCTRL_TRPRE1_MASK=40        64
TICK_FREQ      =0A        10
TPA_START      = 100      256
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
cache          =01        1
cache_buffers   04"       4
cacold          00'       0 (public)
cacrs            240'     576 (public)
cacws            26A'     618 (public)
caflus           138'     312 (public)
calc_csum        362'     866
carpt           78'       120 (public)
cars             1A3'     419 (public)
cawarm          1A'       26 (public)
caws             1F3'     499 (public)
clean_one        14D'     333
conrch          00        0 (extern)
consta          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
coport          00        0 (extern)
cpinit          00        0 (extern)
cpm_to_mmc       382'     898
cpmem           00        0 (extern)
cppags          00        0 (extern)
crc16x          00        0 (extern)
crs_exit         266'     614
crs_rd_ok        255'     597
csum_loop        371'     881
ctm_error        3CD'     973
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cws_copy_loop    2B4'     692
cws_exit         2DD'     733
cws_fmask_0dn    29F'     671
cws_fmask_1dn    29A'     666
cws_rd_ok        283'     643
cws_success      2DC'     732
cwvich          00        0 (extern)
dirty_buffs     02"       2
enum_counter   =02        2
find_new_buff    2E5'     741
find_sec         3D1'     977
fnb_cln_end      32E'     814
fnb_cln_loop     319'     793
fnb_error        350'     848
fnb_exit         34E'     846
fnb_found_new    333'     819
fnb_found_used   337'     823
fnb_have_buff    33E'     830
fnb_unu_end      30B'     779
fnb_unu_loop     2F7'     759
i2crd           00        0 (extern)
i2cwr           00        0 (extern)
in_all_good     6E'       110
in_bad_csum     40'       64
in_badsum_msg    492'     1170
in_exit         72'       114
in_good_csum    47'       71
in_sec_done     50'       80
in_sec_loop     2A'       42
inb_inc_dn       35F'     863
inc_next_buff    354'     852
infs_exit        3FE'     1022
infs_next        3F7'     1015
infs_sec_loop    3DC'     988
itdis           00        0 (extern)
itdsct          00        0 (extern)
itena           00        0 (extern)
itenfl          00        0 (extern)
itinit          00        0 (extern)
itstrt          00        0 (extern)
itsvec          00        0 (extern)
jptbl_addr     =7E        126
madbbu          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
maintain         144'     324
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
mcinit          00        0 (extern)
mcprer          00        0 (extern)
mcrrs           00        0 (extern)
mcrws           00        0 (extern)
mcstat          00        0 (extern)
mnt_dirt_loop    15B'     347
mnt_exit         19D'     413
mnt_flush_exit   14B'     331
mnt_found_dirt   17E'     382
mnt_gr_skip      177'     375
mnt_grub_loop    16C'     364
mnt_ok           19C'     412
monitor        =01        1
mrs_exit         1F1'     497
mrs_found        1EE'     494
mrs_have_sec     1F0'     496
mrse_exit        1BB'     443
mtwdli          00        0 (extern)
mws_buff_status 03"       3
mws_exit         23D'     573
mws_found        202'     514
mws_have_buff    204'     516
mws_more_dirt    239'     569
next_buff       00"       0
nta_nrb_ok       40B'     1035
num_to_addr      401'     1025
panic           00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
read_mmc_sect    1BF'     447
rpt_bad_csum    F7'       247
rpt_badsum_msg   480'     1152
rpt_buff_done   FD'       253
rpt_buff_loop   88'       136
rpt_checksum    E8'       232
rpt_clean_msg    443'     1091
rpt_dirty_msg    449'     1097
rpt_dirtyc_msg   461'     1121
rpt_grub_bit    E2'       226
rpt_grub_loop   DB'       219
rpt_grubby      CD'       205
rpt_grubby_msg   44F'     1103
rpt_nexrd_msg    46B'     1131
rpt_sep_msg      438'     1080
rpt_title_msg    424'     1060
rpt_unclean     C1'       193
rpt_unused_msg   43C'     1084
rpt_used        A1'       161
rpt_usedc_msg    458'     1112
rst_buff_loop   0D'       13
rusby           00        0 (extern)
ruswd           00        0 (extern)
s1rch           00        0 (extern)
s1sta           00        0 (extern)
s1wch           00        0 (extern)
s2rch           00        0 (extern)
s2sta           00        0 (extern)
s2wch           00        0 (extern)
skpspc          00        0 (extern)
spiini          00        0 (extern)
spiss           00        0 (extern)
spitr           00        0 (extern)
str_offset     =24        36
tikcnt          00        0 (extern)
toloca          00        0 (extern)
toupca          00        0 (extern)
trarch          00        0 (extern)
trawch          00        0 (extern)
trport          00        0 (extern)
used_buffs      01"       1
wusby           00        0 (extern)
wuswd           00        0 (extern)
