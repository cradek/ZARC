   1:				; *******************************************************
   2:				; * Bitcoin Mining for CP/M                             *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 5/9/2022                            *
   5:				; *******************************************************
   6:				;
   7:				; This program is intended to run under CP/M 2.2. It should run under any such
   8:				; system, though timing is only available when run on ZARC.
   9:				;
  10:				                title Bitcoin Mining for CP/M
  11:				;
  12:				;
  13:				;
  14:				; ************
  15:				; * Includes *
  16:				; ************
  17:				;
  18:				;
  19:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** bitcoin.z80 ****
  20:				                include "cpm.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** bitcoin.z80 ****
  21:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** bitcoin.z80 ****
  22:				                include "bitcoin.i"     ; Project include file
**** bitcoin.i ****
   1:				; *******************************************************
   2:				; * Bitcoin Mining for CP/M                             *
   3:				; * Include file                                        *
   4:				; * Written by: Merlin Skinner                          *
   5:				; * Date Started: 5/9/2022                              *
   6:				; *******************************************************
   7:				;
   8:				;
   9:				;
  10:				; *************
  11:				; * Constants *
  12:				; *************
  13:				;
  14:				;
  15:				;DEBUG           equ 1                   ; Define to enable debug messages
  16:				;
  17:     -	0040'         	STACK_SIZE      equ 64                  ; Stack space allocation
  18:     -	0003'         	BREAK_CHAR      equ 'C' - 0x40
  19:				;
  20:     -	07D0'         	MSG_PERIOD      equ 2 * 1000            ; Time between messages in ms (ZARC)
  21:     -	001F'         	MSG_REP_MASK    equ 32 - 1              ; Iteration report mask
  22:				; MSG_REP_MASK must be 2^n - 1, where n is a positive integer. Reports will
  23:				; occur every 2^n iterations.
  24:     -	0200'         	SH2_CHUNK_BITS  equ 512                 ; SHA-2 chunk size in bits
  25:     -	0040'         	SH2_CHUNK_BYTES equ (SH2_CHUNK_BITS / 8) ; Above in bytes
  26:     -	0010'         	SH2_CHUNK_LONGS equ (SH2_CHUNK_BYTES / 4) ; Above in 32-bit words
  27:     -	0100'         	SH2_DIGEST_BITS equ 256                 ; SHA-2 digest size in bits
  28:     -	0020'         	SH2_DIGEST_BYTES equ (SH2_DIGEST_BITS / 8) ; Above in bytes
  29:				;
  30:				; Block header structure.
  31:     -	        	                STRUCT
  32:     -	        	                STR_LONG BH_VER         ; Bitcoin version number
  33:     -	        	                STR_BLOCK BH_PREV_HASH, 32  ; Previous block hash
  34:     -	        	                STR_BLOCK BH_MERKLE, 32 ; Merkle root
  35:     -	        	                STR_LONG BH_TIME_STAMP  ; Bitcoin version number
  36:     -	        	                STR_LONG BH_DIFFICULTY  ; Difficulty target for the block
  37:     -	        	                STR_LONG BH_NONCE
  38:     -	        	                STR_END BH_SIZE
  39:				;
  40:     -	0001'         	                assert BH_SIZE = 80
  41:				;
  42:				; From https://developer.bitcoin.org/reference/block_chain.html
  43:				; The hashes are in internal byte order; the other values are all in
  44:				; little-endian order.
  45:				;
  46:				;
**** bitcoin.z80 ****
  23:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** bitcoin.z80 ****
  24:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** bitcoin.z80 ****
  25:				                include "cpm_utility.i" ; CP/M utilities
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMU         ; Inhibit for this module
  10:				; CP/M specific.
  11:				                extern cbdos    ; Call BDOS with some registers saved
  12:				                extern cbios    ; Call BIOS with some registers saved
  13:				                extern panic    ; Fatal application error
  14:				                extern zrcdet   ; Detect ZARC
  15:				                extern z80det   ; Detect Z80 (instead of 8080 / 8085)
  16:				;
  17:				; Derived from the monitor's utility.z80.
  18:				                extern conwch   ; Write character to console
  19:				                extern conrch   ; Read character from the console
  20:				                extern const    ; Fetch console input status
  21:				                extern cwnwln   ; Write new line characters to console
  22:				                extern conwms   ; Print "$" terminated string to the console
  23:				                extern conwmn   ; Print message <n> in a list
  24:				                extern skpspc   ; Step hl past spaces
  25:				                extern toupca   ; Convert character in A to upper case
  26:				                extern toloca   ; Convert character in A to lower case
  27:				                extern cwvich   ; Print only visible 7-bit characters
  28:				                extern cwpspc   ; Print a space
  29:				                extern mtwdli   ; Match word in a string against list of options
  30:				                extern cwphnb   ; Print least-significant nibble in A in hexadecimal
  31:				                extern cwphby   ; Print A in hexadecimal
  32:				                extern cwphwd   ; Print HL in hexadecimal
  33:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  34:				                extern cwpdby   ; Print A in decimal. Leading zeros are suppressed
  35:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  36:				                extern cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  37:				                extern rdhxwd   ; Read a 16-bit hexadecimal number from a string
  38:				                extern rdduwd   ; Read a 16-bit unsigned decimal number from a string
  39:				                extern rddulo   ; Read a 32-bit unsigned decimal number from a string
  40:				;
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** bitcoin.z80 ****
  26:				                include "cpm_files.i"   ; CP/M file handling
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_files.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMF         ; Inhibit for this module
  10:				                extern finit    ; Initialise FCBR structure
  11:				                extern fbfcb    ; Build FCB
  12:				                extern fdel     ; Delete file *
  13:				                extern fopen    ; Open existing file for R/W *
  14:				                extern fmake    ; Create new file *
  15:				                extern fwrrec   ; Write record to file *
  16:				                extern fwrby    ; Write byte to file *
  17:				                extern fwrblk   ; Write block to file *
  18:				                extern frdrec   ; Read record from file *
  19:				                extern frdby    ; Read byte from file *
  20:				                extern frdblk   ; Read block from file *
  21:				                extern fclose   ; Close file *
  22:				                extern fdfcb    ; Display FCB
  23:				                extern fdnam    ; Display filename
  24:				                extern fdswem   ; Display sequential write error message
  25:				                extern fdsrem   ; Display sequential read error message
  26:				            endif
  27:				;
  28:				; * Any errors are reported to the console.
  29:				;
  30:				; FCB with record buffer. This is used by the cpm_files routines.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BLOCK FCBR_FCB, FCB_SIZE    ; FCB structure
  33:     -	        	                STR_BYTE FCBR_FLAGS             ; Status flags
  34:     -	        	                STR_BYTE FCBR_CONTENTS          ; No. of bytes in RBUFF (*)
  35:     -	        	                STR_BLOCK FCBR_RBUFF, CPM_SECTOR_SIZE   ; Record buffer
  36:     -	        	                STR_END FCBR_SIZE               ; Structure size
  37:				;
  38:				; Flags are active if the bit is zero.
  39:     -	        	BITDEF FCBR_FL_OPEN, 0          ; File is open
  40:     -	        	BITDEF FCBR_FL_DIRTY, 1         ; RBUFF contains data to write
  41:				
**** bitcoin.z80 ****
  27:				                include "cpm_maths.i"   ; Integer mathematics
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for CP/M Applications         *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 10/9/2022                           *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMM         ; Inhibit for this module
  10:				; CP/M specific.
  11:				; 32-bit arithmetic.
  12:				                extern mclr32       ; 32-bit clear (zero)
  13:				                extern mcop32       ; 32-bit copy from (hl) to (de)
  14:				                extern minc32       ; 32-bit increment
  15:				                extern mcp32        ; 32-bit compare (hl) - (de)
  16:				                extern madd32       ; 32-bit add (hl) <- (hl) + (de)
  17:				                extern msub32       ; 32-bit sub (hl) <- (hl) - (de)
  18:				;
  19:				; Derived from the monitor's maths.z80.
  20:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  21:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  22:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  23:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  24:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  25:				                extern crc16x       ; Software CRC-16 (XMODEM)
  26:				;
  27:				            endif
  28:				;
**** bitcoin.z80 ****
  28:				                include "cpm_files.i"   ; CP/M file handling
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_files.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMF         ; Inhibit for this module
  10:				                extern finit    ; Initialise FCBR structure
  11:				                extern fbfcb    ; Build FCB
  12:				                extern fdel     ; Delete file *
  13:				                extern fopen    ; Open existing file for R/W *
  14:				                extern fmake    ; Create new file *
  15:				                extern fwrrec   ; Write record to file *
  16:				                extern fwrby    ; Write byte to file *
  17:				                extern fwrblk   ; Write block to file *
  18:				                extern frdrec   ; Read record from file *
  19:				                extern frdby    ; Read byte from file *
  20:				                extern frdblk   ; Read block from file *
  21:				                extern fclose   ; Close file *
  22:				                extern fdfcb    ; Display FCB
  23:				                extern fdnam    ; Display filename
  24:				                extern fdswem   ; Display sequential write error message
  25:				                extern fdsrem   ; Display sequential read error message
  26:				            endif
  27:				;
  28:				; * Any errors are reported to the console.
  29:				;
  30:				; FCB with record buffer. This is used by the cpm_files routines.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BLOCK FCBR_FCB, FCB_SIZE    ; FCB structure
  33:     -	        	                STR_BYTE FCBR_FLAGS             ; Status flags
  34:     -	        	                STR_BYTE FCBR_CONTENTS          ; No. of bytes in RBUFF (*)
  35:     -	        	                STR_BLOCK FCBR_RBUFF, CPM_SECTOR_SIZE   ; Record buffer
  36:     -	        	                STR_END FCBR_SIZE               ; Structure size
  37:				;
  38:				; Flags are active if the bit is zero.
  39:     -	        	BITDEF FCBR_FL_OPEN, 0          ; File is open
  40:     -	        	BITDEF FCBR_FL_DIRTY, 1         ; RBUFF contains data to write
  41:				
**** bitcoin.z80 ****
  29:				                include "cpm_top.i"     ; CP/M dummy top module
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_top.i ****
   1:				; *******************************************************
   2:				; * Dummy Module to find the Last Location in Use.      *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				                extern fstfre       ; First location after end of data segment
  10:				
**** bitcoin.z80 ****
  30:				;
  31:				;
  32:				;
  33:				; *************
  34:				; * Externals *
  35:				; *************
  36:				;
  37:				;
  38:				; Variables
  39:				;                public brkflg   ; Non-zero if break character detected
  40:				;
  41:				; From sha-256.z80
  42:				                extern sh2ini   ; Initialise sha-256 state
  43:				                extern sh2m     ; Process a message in memory
  44:				                extern sh2dh    ; Display hash value
  45:				;
  46:				;
  47:				;
  48:				; *************
  49:				; * Main Code *
  50:				; *************
  51:				;
  52:				;
  53:				; The CP/M transient area start address is set in the linker invocation (see
  54:				; makefile).
  55:				                cseg                    ; Code segment
  56:				;
  57:				; The default stack space is very small (8 deep), which would almost certainly
  58:				; cause issues, particularly with interrupts running. The initial code should
  59:				; not assume a Z80 so we can exit cleanly if this is run on something else.
  60:    0+20	0000' ED730000	                ld (bdos_sp), sp
  61:   20+10	0004' 318701  	                ld sp, app_stack_top    ; Switch to our stack space
  62:				;
  63:				; Determine CPU type.
  64:   30+17	0007' CD0000  	                call z80det             ; Detect Z80 (instead of 8080 / 8085)
  65:   47+10	000A' D21800  	                jp nc, on_z80           ; Jump if we have a Z80
  66:				;
  67:				; 8080 / 8085 detected. Print message and exit. We can't use conwms as this
  68:				; assumes a Z80.
  69:   57+10	000D' 11AD03  	                ld de, no_z80_msg       ; "Z80 CPU required"
  70:   67+7	0010' 0E09    	                ld c, BDOS_PRINT_STRING ; Print String
  71:   74+17	0012' CD0500  	                call BDOS
  72:   91+10	0015' C30000  	                jp 0                    ; Warm boot
  73:				;
  74:				; Sign on.
  75:  101+10	0018' 218F03  	on_z80          ld hl, signon_msg
  76:  111+17	001B' CD0000  	                call conwms             ; Print $-terminated string to console
  77:				;
  78:				; Are we running on a ZARC system?
  79:  128+17	001E' CD0000  	                call zrcdet
  80:				; Carry set if ZARC BIOS not found.
  81:  145+4	0021' 3F      	                ccf
  82:  149+4	0022' 17      	                rla
  83:  153+7	0023' E601    	                and 1
  84:  160+13	0025' 320200  	                ld (zarc_flag), a       ; 0x01 if ZARC, zero otherwise
  85:  173+7+5	0028' 2006    	                jr nz, init_fcbr
  86:				;
  87:				; Warn about limited facilites.
  88:  180+10	002A' 21C003  	                ld hl, no_zarc_msg      ; "ZARC BIOS not detected ..."
  89:  190+17	002D' CD0000  	                call conwms             ; Print $-terminated string to console
  90:				;
  91:				; Setup file structure.
  92:				; IX - pointer to FCBR structure (FCB with record buffer). This is defined in
  93:				; cpm_files.i
  94:  207+14	0030' DD210300	init_fcbr       ld ix, fcbr
  95:  221+17	0034' CD0000  	                call finit              ; Initialise FCBR structure
  96:				;
  97:				; Examine the command tail, looking for operands. This is stored in the default
  98:				; buffer. "The first byte at 0080H contains the length of the command tall,
  99:				; while the command tail itself begins at 0081H. The command tail is terminated
 100:				; by a byte containing a binary zero value."
 101:				; (http://www.cpm.z80.de/manuals/cpm22-m.pdf appendix H).
 102:  238+10	0037' 218100  	                ld hl, DEF_BUFFER + 1
 103:				; No operands (yet).
 104:				; The terminator should follow.
 105:  248+17	003A' CD0000  	op_check_term   call skpspc
 106:  265+7	003D' 7E      	                ld a, (hl)
 107:  272+4	003E' A7      	                and a
 108:     -	0000'         	                ifdef DEBUG
 111:				                endif
 112:  276+7+5	003F' 2806    	                jr z, operands_ok       ; Normal behaviour
 113:				;
 114:				; Go here if we don't like the operands supplied.
 115:  283+10	0041' 21F003  	op_error        ld hl, op_err_msg
 116:  293+10	0044' C39702  	                jp msg_exit
 117:				;
 118:				; Operand processing complete.
 119:     -	0047'         	operands_ok
 120:				;
 121:				;
 122:				; Perform validation tests. First the null string.
 123:  303+10	0047' 219704  	                ld hl, test_null_msg    ; "Null message test: "
 124:  313+17	004A' CD0000  	                call conwms             ; Print $-terminated string to console
 125:  330+17	004D' CD0000  	                call sh2ini             ; Initialise sha-256 state
 126:  347+10	0050' 210000  	                ld hl, 0                ; Pointer does not matter
 127:  357+10	0053' 010000  	                ld bc, 0                ; Overall message length in bytes
 128:  367+17	0056' CD0000  	                call sh2m               ; Process a message in memory
 129:				; HL - pointer to message digest (h0 to h7)
 130:  384+10	0059' 11C105  	                ld de, null_msg_hash
 131:  394+17	005C' CDD202  	                call cmp_hashes         ; Compare hashes and report errors
 132:  411+10+7	005F' D48903  	                call nc, disp_ok        ; Display OK if it was so
 133:				;
 134:				; Test message 1
 135:  421+10	0062' 21AB04  	                ld hl, test_short_msg   ; "Short message test: "
 136:  431+17	0065' CD0000  	                call conwms             ; Print $-terminated string to console
 137:  448+17	0068' CD0000  	                call sh2ini             ; Initialise sha-256 state
 138:  465+10	006B' 21E105  	                ld hl, test1_msg        ; Point to message
 139:  475+10	006E' 010F00  	                ld bc, test1_msg_len    ; Overall message length in bytes
 140:  485+17	0071' CD0000  	                call sh2m               ; Process a message in memory
 141:				; HL - pointer to message digest (h0 to h7)
 142:  502+10	0074' 11F005  	                ld de, test1_msg_hash
 143:  512+17	0077' CDD202  	                call cmp_hashes         ; Compare hashes and report errors
 144:  529+10+7	007A' D48903  	                call nc, disp_ok        ; Display OK if it was so
 145:				;
 146:				; Test message 2. This will require three chunks, one with message text, another
 147:				; with the rest of the message text (but is just too short to contain the
 148:				; length), and the last with just the length.
 149:  539+10	007D' 21C004  	                ld hl, test_long_msg    ; "Long message test: "
 150:  549+17	0080' CD0000  	                call conwms             ; Print $-terminated string to console
 151:  566+17	0083' CD0000  	                call sh2ini             ; Initialise sha-256 state
 152:  583+10	0086' 211006  	                ld hl, test2_msg        ; Point to message
 153:  593+10	0089' 017800  	                ld bc, test2_msg_len    ; Overall message length in bytes
 154:  603+17	008C' CD0000  	                call sh2m               ; Process a message in memory
 155:				; HL - pointer to message digest (h0 to h7)
 156:  620+10	008F' 118806  	                ld de, test2_msg_hash
 157:  630+17	0092' CDD202  	                call cmp_hashes         ; Compare hashes and report errors
 158:  647+10+7	0095' D48903  	                call nc, disp_ok        ; Display OK if it was so
 159:				;
 160:				; Test message 3. This is just one byte shorter than the previous message. It
 161:				; will require two chunks, one with message text, another with the rest of the
 162:				; message text and the length. No chunk will contain pad bytes.
 163:  657+10	0098' 21D404  	                ld hl, test_long2_msg   ; "Long message test 2: "
 164:  667+17	009B' CD0000  	                call conwms             ; Print $-terminated string to console
 165:  684+17	009E' CD0000  	                call sh2ini             ; Initialise sha-256 state
 166:  701+10	00A1' 211006  	                ld hl, test2_msg        ; Use test2 message (except last byte)
 167:  711+10	00A4' 017700  	                ld bc, test3_msg_len    ; Overall message length in bytes
 168:  721+17	00A7' CD0000  	                call sh2m               ; Process a message in memory
 169:				; HL - pointer to message digest (h0 to h7)
 170:  738+10	00AA' 11A806  	                ld de, test3_msg_hash
 171:  748+17	00AD' CDD202  	                call cmp_hashes         ; Compare hashes and report errors
 172:  765+10+7	00B0' D48903  	                call nc, disp_ok        ; Display OK if it was so
 173:				;
 174:				; Bitcoin genesis block.
 175:  775+10	00B3' 21EA04  	                ld hl, genesis_msg      ; "Bitcoin genesis block: "
 176:  785+17	00B6' CD0000  	                call conwms             ; Print $-terminated string to console
 177:  802+17	00B9' CD0000  	                call sh2ini             ; Initialise sha-256 state
 178:  819+10	00BC' 21CC06  	                ld hl, genesis          ; Point to message
 179:  829+10	00BF' 015000  	                ld bc, BH_SIZE          ; Header size
 180:  839+17	00C2' CD0000  	                call sh2m               ; Process a message in memory
 181:				; HL - pointer to message digest (h0 to h7)
 182:  856+10	00C5' 11AF00  	                ld de, bit_hash_buf     ; Hash digest buffer
 183:  866+11	00C8' D5      	                push de
 184:  877+17	00C9' CD4D03  	                call copy_hash          ; Copy hash and endian convert
 185:				; Apply the second SHA-2 step, as Bitcoin uses double SHA-2.
 186:  894+17	00CC' CD0000  	                call sh2ini             ; Initialise sha-256 state
 187:  911+10	00CF' E1      	                pop hl
 188:  921+10	00D0' 012000  	                ld bc, SH2_DIGEST_BYTES ; Overall message length in bytes
 189:  931+17	00D3' CD0000  	                call sh2m               ; Process a message in memory
 190:				; HL - pointer to message digest (h0 to h7)
 191:  948+10	00D6' 111C07  	                ld de, genesis_hash
 192:  958+17	00D9' CD0603  	                call bit_cmp_hashes     ; Compare Bitcoin hashes
 193:  975+10+7	00DC' D48903  	                call nc, disp_ok        ; Display OK if it was so
 194:				;
 195:  985+10	00DF' 210205  	                ld hl, bitc_exam_msg    ; "Bitcoin example block: "
 196:  995+17	00E2' CD0000  	                call conwms             ; Print $-terminated string to console
 197: 1012+17	00E5' CD0000  	                call sh2ini             ; Initialise sha-256 state
 198: 1029+10	00E8' 213C07  	                ld hl, bitc_example     ; Point to message
 199: 1039+10	00EB' 015000  	                ld bc, BH_SIZE          ; Header size
 200: 1049+17	00EE' CD0000  	                call sh2m               ; Process a message in memory
 201:				; HL - pointer to message digest (h0 to h7)
 202: 1066+10	00F1' 11AF00  	                ld de, bit_hash_buf     ; Hash digest buffer
 203: 1076+11	00F4' D5      	                push de
 204: 1087+17	00F5' CD4D03  	                call copy_hash          ; Copy hash and endian convert
 205:				; Apply the second SHA-2 step, as Bitcoin uses double SHA-2.
 206: 1104+17	00F8' CD0000  	                call sh2ini             ; Initialise sha-256 state
 207: 1121+10	00FB' E1      	                pop hl
 208: 1131+10	00FC' 012000  	                ld bc, SH2_DIGEST_BYTES ; Overall message length in bytes
 209: 1141+17	00FF' CD0000  	                call sh2m               ; Process a message in memory
 210:				; HL - pointer to message digest (h0 to h7)
 211: 1158+10	0102' 118C07  	                ld de, bitc_exam_hash
 212: 1168+17	0105' CD0603  	                call bit_cmp_hashes     ; Compare Bitcoin hashes
 213: 1185+10+7	0108' D48903  	                call nc, disp_ok        ; Display OK if it was so
 214:				;
 215:				;
 216:				; Attempt to load saved progress.
 217: 1195+10	010B' 211A05  	                ld hl, load_state_msg   ; "Loading saved state "
 218: 1205+17	010E' CD0000  	                call conwms             ; Print $-terminated string to console
 219:				; IX - pointer to FCBR structure (FCB with record buffer) was setup earlier.
 220: 1222+10	0111' 213105  	                ld hl, save_fn          ; Filename
 221: 1232+17	0114' CD0000  	                call fbfcb              ; Build the FCB.
 222:				;
 223: 1249+17	0117' CD0000  	                call fopen              ; Open file for reading
 224:				; Carry set on error. A generic message will have been written to the console
 225:				; if an error occurred.
 226: 1266+10	011A' DA3701  	                jp c, load_error
 227:				;
 228: 1276+10	011D' 21CF00  	                ld hl, save_start       ; Start of saved variables
 229: 1286+10	0120' 017800  	                ld bc, save_size        ; Size
 230: 1296+17	0123' CD0000  	                call frdblk             ; Read block from file
 231:				; Carry set on error. A generic message will have been written to the console
 232:				; if an error occurred.
 233: 1313+10	0126' DA3701  	                jp c, load_error
 234:				; We should have loaded exactly save_size bytes.
 235: 1323+10	0129' 217800  	                ld hl, save_size
 236: 1333+4	012C' A7      	                and a
 237: 1337+15	012D' ED42    	                sbc hl, bc
 238: 1352+7+5	012F' 2006    	                jr nz, load_error
 239:				;
 240: 1359+17	0131' CD8903  	                call disp_ok            ; Print "OK"
 241: 1376+10	0134' C36501  	                jp load_done
 242:				;
 243:				;
 244:				; Load failed.
 245: 1386+10	0137' 213C05  	load_error      ld hl, load_err_msg     ; "Error reading file"
 246: 1396+17	013A' CD0000  	                call conwms             ; Print $-terminated string to console
 247:				;
 248:				; Copy the genesis block to use as the basis of our search.
 249: 1413+10	013D' 21CC06  	                ld hl, genesis          ; Point to message
 250: 1423+10	0140' 11D300  	                ld de, bit_hdr_buf      ; Bitcoin header buffer
 251: 1433+10	0143' 015000  	                ld bc, BH_SIZE          ; Header size
 252: 1443+16+5	0146' EDB0    	                ldir
 253:				; Initialise nonce.
 254: 1459+10	0148' 211F01  	                ld hl, bit_hdr_buf + BH_NONCE
 255: 1469+17	014B' CD0000  	                call mclr32             ; 32-bit clear (zero)
 256:				; Reset best hash and corresponding best nonce found.
 257: 1486+10	014E' 212301  	                ld hl, best_hash
 258: 1496+7	0151' 0620    	                ld b, SH2_DIGEST_BYTES
 259: 1503+7	0153' 3EFF    	                ld a, 0xff
 260: 1510+7	0155' 77      	init_clr_hash   ld (hl), a
 261: 1517+6	0156' 23      	                inc hl
 262: 1523+8+5	0157' 10FC    	                djnz init_clr_hash
 263: 1531+10	0159' 214301  	                ld hl, best_nonce
 264: 1541+17	015C' CD0000  	                call mclr32             ; 32-bit clear (zero)
 265:				; Reset iteration counter.
 266: 1558+10	015F' 21CF00  	                ld hl, iter_count
 267: 1568+17	0162' CD0000  	                call mclr32             ;  32-bit clear (zero)
 268:				;
 269:				; Reset iteration counters.
 270: 1585+17	0165' CD0000  	load_done       call fclose             ; Close file
 271: 1602+10	0168' 210000  	                ld hl, 0
 272: 1612+16	016B' 22AD00  	                ld (iter_delta), hl     ; Iterations since last report
 273:				;
 274:				; Initialise timing (ZARC only).
 275: 1628+13	016E' 3A0200  	                ld a, (zarc_flag)       ; 0x01 if ZARC, zero otherwise
 276: 1641+4	0171' A7      	                and a
 277: 1645+7+5	0172' 2819    	                jr z, initt_done
 278:				;
 279:				; ZARC system. Reset the elapsed time.
 280: 1652+4	0174' AF      	                xor a
 281: 1656+4	0175' 47      	                ld b, a
 282: 1660+4	0176' 4F      	                ld c, a
 283: 1664+4	0177' 57      	                ld d, a
 284: 1668+4	0178' 5F      	                ld e, a
 285:				; BCDE - 32-bit time
 286: 1672+10	0179' 217800  	                ld hl, BIOS_SET_TIMER   ; Set timer
 287: 1682+17	017C' CD0000  	                call cbios              ; Call BIOS
 288:				;
 289:				; Set initial message time.
 290: 1699+10	017F' 21A900  	                ld hl, msg_time         ; Message timer (ms)
 291: 1709+10	0182' 36D0    	                ld (hl), low MSG_PERIOD
 292: 1719+6	0184' 23      	                inc hl
 293: 1725+10	0185' 3607    	                ld (hl), high MSG_PERIOD
 294: 1735+6	0187' 23      	                inc hl
 295: 1741+10	0188' 3600    	                ld (hl), 0
 296: 1751+6	018A' 23      	                inc hl
 297: 1757+10	018B' 3600    	                ld (hl), 0
 298:				;
 299: 1767+17	018D' CDAA02  	initt_done      call disp_best          ; Display best nonce and hash
 300: 1784+10	0190' 213204  	                ld hl, start_msg        ; "Starting mining. Press ^C to exit."
 301: 1794+17	0193' CD0000  	                call conwms             ; Print $-terminated string to console
 302:				;
 303:				;
 304:				; Main iteration loop.
 305: 1811+17	0196' CD0000  	main_loop       call sh2ini             ; Initialise sha-256 state
 306: 1828+10	0199' 21D300  	                ld hl, bit_hdr_buf      ; Bitcoin block header buffer
 307: 1838+10	019C' 015000  	                ld bc, BH_SIZE          ; Header size
 308: 1848+17	019F' CD0000  	                call sh2m               ; Process a message in memory
 309:				; HL - pointer to message digest (h0 to h7)
 310: 1865+10	01A2' 11AF00  	                ld de, bit_hash_buf     ; Hash digest buffer
 311: 1875+11	01A5' D5      	                push de
 312: 1886+17	01A6' CD4D03  	                call copy_hash          ; Copy hash and endian convert
 313:				; Apply the second SHA-2 step, as Bitcoin uses double SHA-2.
 314: 1903+17	01A9' CD0000  	                call sh2ini             ; Initialise sha-256 state
 315: 1920+10	01AC' E1      	                pop hl
 316: 1930+10	01AD' 012000  	                ld bc, SH2_DIGEST_BYTES ; Overall message length in bytes
 317: 1940+17	01B0' CD0000  	                call sh2m               ; Process a message in memory
 318:				; HL - pointer to message digest (h0 to h7)
 319:				;
 320:				; Assess the resulting hash. Is it smaller than the best yet? The bytes are
 321:				; to be treated as h0 - h7 in reverse order and big endian format to suit
 322:				; Bitcoin conventions.
 323: 1957+11	01B3' E5      	                push hl                 ; Save pointer to hash
 324:				; Perform a subtract, starting at the LS byte of h0.
 325: 1968+6	01B4' 23      	                inc hl
 326: 1974+6	01B5' 23      	                inc hl
 327: 1980+6	01B6' 23      	                inc hl
 328: 1986+4	01B7' EB      	                ex de, hl
 329: 1990+10	01B8' 212601  	                ld hl, best_hash + 3
 330: 2000+7	01BB' 0608    	                ld b, 8                 ; Register counter
 331: 2007+4	01BD' A7      	                and a                   ; Reset carry
 332: 2011+7	01BE' 0E04    	hcmp_reg_loop   ld c, 4
 333:				; B - register counter
 334:				; C - byte counter
 335:				; DE - pointer to calculated hash
 336:				; HL - pointer to best hash
 337: 2018+11	01C0' D5      	                push de
 338: 2029+11	01C1' E5      	                push hl
 339: 2040+7	01C2' 1A      	hcmp_byte_loop  ld a, (de)
 340: 2047+7	01C3' 9E      	                sbc (hl)
 341: 2054+6	01C4' 2B      	                dec hl
 342: 2060+6	01C5' 1B      	                dec de
 343: 2066+4	01C6' 0D      	                dec c
 344: 2070+7+5	01C7' 20F9    	                jr nz, hcmp_byte_loop
 345: 2077+10	01C9' E1      	                pop hl
 346: 2087+10	01CA' D1      	                pop de
 347:				; Next calculated hash register.
 348: 2097+6	01CB' 13      	                inc de
 349: 2103+6	01CC' 13      	                inc de
 350: 2109+6	01CD' 13      	                inc de
 351: 2115+6	01CE' 13      	                inc de
 352:				; Next best hash register.
 353: 2121+6	01CF' 23      	                inc hl
 354: 2127+6	01D0' 23      	                inc hl
 355: 2133+6	01D1' 23      	                inc hl
 356: 2139+6	01D2' 23      	                inc hl
 357: 2145+8+5	01D3' 10E9    	                djnz hcmp_reg_loop
 358:				; Compare complete.
 359: 2153+10	01D5' E1      	                pop hl                  ; Recover pointer to h0 - h7
 360: 2163+7+5	01D6' 3014    	                jr nc, next_nonce       ; Keep going if not best
 361:				;
 362:				;
 363:				; This is the best hash yet.
 364:				; HL - pointer to message digest (h0 to h7)
 365:				; Save the hash
 366: 2170+10	01D8' 112301  	                ld de, best_hash
 367: 2180+10	01DB' 015000  	                ld bc, BH_SIZE
 368: 2190+16+5	01DE' EDB0    	                ldir
 369:				; Save nonce
 370: 2206+10	01E0' 211F01  	                ld hl, bit_hdr_buf + BH_NONCE
 371: 2216+10	01E3' 114301  	                ld de, best_nonce
 372: 2226+17	01E6' CD0000  	                call mcop32             ; 32-bit copy from (hl) to (de)
 373:				;
 374: 2243+17	01E9' CDAA02  	                call disp_best          ; Display best nonce and hash
 375:				;
 376:				; Increment the nonce.
 377: 2260+10	01EC' 211F01  	next_nonce      ld hl, bit_hdr_buf + BH_NONCE
 378: 2270+17	01EF' CD0000  	                call minc32             ; 32-bit increment
 379:				;
 380:				; Update iteration counter.
 381: 2287+10	01F2' 21CF00  	                ld hl, iter_count
 382: 2297+17	01F5' CD0000  	                call minc32             ; 32-bit increment
 383: 2314+10+7	01F8' DC0000  	                call c, panic           ; Counter can't realistically overflow
 384:				;
 385:				; Update iterations since last report.
 386: 2324+16	01FB' 2AAD00  	                ld hl, (iter_delta)
 387: 2340+6	01FE' 23      	                inc hl
 388: 2346+4	01FF' 7C      	                ld a, h
 389: 2350+4	0200' B5      	                or l
 390: 2354+7+5	0201' 2803    	                jr z, rep_delinc_dn     ; Jump if no overflow
 391: 2361+16	0203' 22AD00  	                ld (iter_delta), hl
 392:     -	0206'         	rep_delinc_dn
 393:				;
 394:				;
 395:				; Report progress every so often.
 396: 2377+13	0206' 3A0200  	                ld a, (zarc_flag)       ; 0x01 if ZARC, zero otherwise
 397: 2390+4	0209' A7      	                and a
 398: 2394+7+5	020A' 2818    	                jr z, rep_not_zarc      ; jump if not a ZARC system
 399:				;
 400:				; ZARC system. Examine time.
 401: 2401+10	020C' 217B00  	                ld hl, BIOS_GET_TIMER   ; Get timer
 402: 2411+17	020F' CD0000  	                call cbios              ; Call BIOS
 403:				; BCDE - 32-bit time in ms. Time is limited to approximately 49.7 days.
 404:				; Subtract msg_time from current time. If it doesn't carry, we should report.
 405: 2428+10	0212' 21A900  	                ld hl, msg_time         ; Message timer (ms)
 406: 2438+4	0215' 7B      	                ld a, e
 407: 2442+7	0216' 96      	                sub (hl)
 408: 2449+6	0217' 23      	                inc hl
 409: 2455+4	0218' 7A      	                ld a, d
 410: 2459+7	0219' 9E      	                sbc (hl)
 411: 2466+6	021A' 23      	                inc hl
 412: 2472+4	021B' 79      	                ld a, c
 413: 2476+7	021C' 9E      	                sbc (hl)
 414: 2483+6	021D' 23      	                inc hl
 415: 2489+4	021E' 78      	                ld a, b
 416: 2493+7	021F' 9E      	                sbc (hl)
 417: 2500+7+5	0220' 3009    	                jr nc, rep_start        ; Jump if time to report
 418: 2507+12	0222' 1841    	                jr rep_done
 419:				;
 420:				; Not a ZARC system. Report every so many iterations.
 421: 2519+13	0224' 3ACF00  	rep_not_zarc    ld a, (iter_count)      ; Fetch LS byte of counter
 422: 2532+7	0227' E61F    	                and MSG_REP_MASK
 423: 2539+7+5	0229' 203A    	                jr nz, rep_done
 424:				;
 425: 2546+10	022B' 215704  	rep_start       ld hl, iter_msg         ; CR, "Iteration: "
 426: 2556+17	022E' CD0000  	                call conwms             ; Print $-terminated string to console
 427: 2573+10	0231' 21CF00  	                ld hl, iter_count
 428: 2583+7	0234' 4E      	                ld c, (hl)
 429: 2590+6	0235' 23      	                inc hl
 430: 2596+7	0236' 46      	                ld b, (hl)
 431: 2603+6	0237' 23      	                inc hl
 432: 2609+7	0238' 5E      	                ld e, (hl)
 433: 2616+6	0239' 23      	                inc hl
 434: 2622+7	023A' 56      	                ld d, (hl)
 435: 2629+4	023B' 60      	                ld h, b
 436: 2633+4	023C' 69      	                ld l, c
 437: 2637+17	023D' CD0000  	                call cwpdlo             ; Print DEHL in decimal
 438:				;
 439: 2654+10	0240' 216404  	                ld hl, delta_msg        ; ", delta: "
 440: 2664+17	0243' CD0000  	                call conwms             ; Print $-terminated string to console
 441: 2681+10	0246' 21AD00  	                ld hl, iter_delta
 442: 2691+7	0249' 5E      	                ld e, (hl)
 443: 2698+6	024A' 23      	                inc hl
 444: 2704+7	024B' 56      	                ld d, (hl)
 445: 2711+4	024C' EB      	                ex de, hl
 446: 2715+17	024D' CD0000  	                call cwpdwd             ; Print HL in decimal
 447:				; Leave the cursor at the end of the line so we can print over it next time.
 448:				;
 449:				; Reset iteration delta counter.
 450: 2732+10	0250' 210000  	                ld hl, 0
 451: 2742+16	0253' 22AD00  	                ld (iter_delta), hl     ; Iterations since last report
 452:				;
 453:				; Update the time if we are on ZARC.
 454: 2758+13	0256' 3A0200  	                ld a, (zarc_flag)       ; 0x01 if ZARC, zero otherwise
 455: 2771+4	0259' A7      	                and a
 456: 2775+7+5	025A' 2809    	                jr z, rep_done          ; jump if not a ZARC system
 457:				;
 458:				; Calculate time for next report.
 459: 2782+10	025C' 21A900  	                ld hl, msg_time         ; Message timer (ms)
 460: 2792+10	025F' 11C806  	                ld de, msg_per_const
 461: 2802+17	0262' CD0000  	                call madd32             ; 32-bit add (hl) <- (hl) + (de)
 462:				;
 463:				; Exit unless break detected.
 464: 2819+17	0265' CD0000  	rep_done        call const              ; Fetch console input status
 465: 2836+4	0268' A7      	                and a
 466: 2840+7+5	0269' 280A    	                jr z, ml_no_break       ; Jump if no character received
 467:				; The BIOS is used for console I/O as the corresponding BDOS function echoes
 468:				; the character to the display.
 469: 2847+17	026B' CD0000  	                call conrch             ; Read character from the console
 470:				; Exit if ^C pressed.
 471: 2864+10	026E' 210704  	                ld hl, break_msg        ; "Exiting due to ^C"
 472: 2874+7	0271' FE03    	                cp BREAK_CHAR
 473: 2881+7+5	0273' 2803    	                jr z, break_det         ; Exit on break
 474:				;
 475: 2888+10	0275' C39601  	ml_no_break     jp main_loop            ; Do another iteration
 476:				;
 477:				;
 478:				; Break detected. Attempt to save state. The fcbr is reused, so the save
 479:				; filename is the same as that used for loading.
 480: 2898+10	0278' 217605  	break_det       ld hl, save_msg         ; "Saving state "
 481: 2908+17	027B' CD0000  	                call conwms             ; Print $-terminated string to console
 482: 2925+17	027E' CD0000  	                call fdnam              ; Display CP/M filename
 483: 2942+17	0281' CD0000  	                call cwnwln             ; Write new line characters to console
 484: 2959+17	0284' CD0000  	                call fmake              ; Create new file and report errors
 485:				; A - BDOS error code if carry = 1
 486:				; Carry flag is set if BDOS reported an error.
 487: 2976+7+5	0287' 380B    	                jr c, save_error        ; Give up if can't make
 488:				;
 489:				; Save the variables.
 490: 2983+10	0289' 21CF00  	                ld hl, save_start       ; Start of saved variables
 491: 2993+10	028C' 017800  	                ld bc, save_size        ; Size
 492: 3003+17	028F' CD0000  	                call fwrblk             ; Write block to file
 493:				; Carry set on error. A generic message will have been written to the console
 494:				; if an error occurred.
 495: 3020+7+5	0292' 3006    	                jr nc, exit             ; Exit if no error
 496:				;
 497: 3027+10	0294' 218E05  	save_error      ld hl, save_err_msg     ; "Error saving state"
 498:				;
 499:				;
 500:				; Print message pointed to by HL, then exit.
 501: 3037+17	0297' CD0000  	msg_exit        call conwms             ; Print $-terminated string to console
 502:				;
 503:				; Return to CP/M.
 504: 3054+17	029A' CD0000  	exit            call fclose             ; Close file
 505: 3071+10	029D' 211D04  	                ld hl, exit_msg         ; "Returning to CP/M."
 506: 3081+17	02A0' CD0000  	                call conwms             ; Print $-terminated string to console
 507:				;
 508: 3098+20	02A3' ED7B0000	                ld sp, (bdos_sp)
 509:				; For this application a warm boot is required as we may have overwritten the
 510:				; CCP.
 511:				;                ret                     ; Return to BDOS
 512: 3118+10	02A7' C30000  	                jp 0                    ; Warm boot
 513:				;
 514:				;
 515:				;
 516:				; ***************
 517:				; * Subroutines *
 518:				; ***************
 519:				;
 520:				;
 521:				; Display nonce and hash.
 522: 3128+11	02AA' C5      	disp_best       push bc
 523: 3139+11	02AB' D5      	                push de
 524: 3150+11	02AC' E5      	                push hl
 525:				;
 526: 3161+10	02AD' 21A405  	                ld hl, best_msg         ; "Best nonce / hash found:"
 527: 3171+17	02B0' CD0000  	                call conwms             ; Print $-terminated string to console
 528: 3188+10	02B3' 214301  	                ld hl, best_nonce
 529: 3198+7	02B6' 4E      	                ld c, (hl)
 530: 3205+6	02B7' 23      	                inc hl
 531: 3211+7	02B8' 46      	                ld b, (hl)
 532: 3218+6	02B9' 23      	                inc hl
 533: 3224+7	02BA' 5E      	                ld e, (hl)
 534: 3231+6	02BB' 23      	                inc hl
 535: 3237+7	02BC' 56      	                ld d, (hl)
 536: 3244+4	02BD' 60      	                ld h, b
 537: 3248+4	02BE' 69      	                ld l, c
 538: 3252+17	02BF' CD0000  	                call cwpdlo             ; Print DEHL in decimal
 539:				;
 540: 3269+17	02C2' CD0000  	                call cwpspc             ; Print a space
 541: 3286+10	02C5' 212301  	                ld hl, best_hash
 542: 3296+17	02C8' CD6903  	                call bit_disp_hash      ; Display hash value in Bitcoin format
 543: 3313+17	02CB' CD0000  	                call cwnwln             ; Write new line characters to console
 544:				;
 545: 3330+10	02CE' E1      	                pop hl
 546: 3340+10	02CF' D1      	                pop de
 547: 3350+10	02D0' C1      	                pop bc
 548: 3360+10	02D1' C9      	                ret
 549:				;
 550:				;
 551:				; Compare hashes and report any errors. Call with:
 552:				; HL - pointer to hash (message digest [h0 to h7])
 553:				; DE - pointer to expected hash value
 554:				; Returns with:
 555:				; Carry flag - set on mismatch, clear otherwise
 556: 3370+11	02D2' C5      	cmp_hashes      push bc
 557:				;
 558: 3381+11	02D3' E5      	                push hl
 559: 3392+11	02D4' D5      	                push de
 560:				;
 561: 3403+10	02D5' 012000  	                ld bc, 8 * 4            ; Compare 8 32-bit words
 562: 3413+7	02D8' 1A      	ch_loop         ld a, (de)
 563: 3420+6	02D9' 13      	                inc de
 564: 3426+16	02DA' EDA1    	                cpi                     ; cp (hl), inc hl, dec bc
 565: 3442+7+5	02DC' 2008    	                jr nz, ch_miss
 566: 3449+10	02DE' EAD802  	                jp pe, ch_loop
 567:				; Hashes match!
 568: 3459+10	02E1' D1      	                pop de                  ; Discard pointers
 569: 3469+10	02E2' E1      	                pop hl
 570: 3479+4	02E3' A7      	                and a                   ; Flag success
 571: 3483+12	02E4' 181E    	                jr ch_exit
 572:				;
 573: 3495+17	02E6' CD0000  	ch_miss         call cwnwln             ; Write new line characters to console
 574: 3512+10	02E9' 216E04  	                ld hl, hc_mismatch_msg  ; "Hash mismatch. Expected:"
 575: 3522+17	02EC' CD0000  	                call conwms             ; Print $-terminated string to console
 576: 3539+10	02EF' E1      	                pop hl                  ; Recover pointer to expected hash
 577: 3549+17	02F0' CD0000  	                call sh2dh              ; Display hash value
 578: 3566+17	02F3' CD0000  	                call cwnwln             ; Write new line characters to console
 579: 3583+10	02F6' 218904  	                ld hl, hc_found_msg     ; "found:"
 580: 3593+17	02F9' CD0000  	                call conwms             ; Print $-terminated string to console
 581: 3610+10	02FC' E1      	                pop hl                  ; Recover pointer to calculated hash
 582: 3620+17	02FD' CD0000  	                call sh2dh              ; Display hash value
 583: 3637+17	0300' CD0000  	                call cwnwln             ; Write new line characters to console
 584: 3654+4	0303' 37      	                scf                     ; Flag error
 585:				;
 586: 3658+10	0304' C1      	ch_exit         pop bc
 587: 3668+10	0305' C9      	                ret
 588:				;
 589:				;
 590:				; As cmp_hashes but the hash is reversed as is the convention for Bitcoin.
 591:				; Call with:
 592:				; HL - pointer to hash (message digest [h0 to h7])
 593:				; DE - pointer to expected hash value in Bitcoin format
 594:				; Returns with:
 595:				; Carry flag - set on mismatch, clear otherwise
 596: 3678+11	0306' C5      	bit_cmp_hashes  push bc
 597:				;
 598: 3689+11	0307' E5      	                push hl                 ; Save hash pointers
 599: 3700+11	0308' D5      	                push de
 600:				;
 601:				; Advance hash address to last register (h7)
 602: 3711+10	0309' 011C00  	                ld bc, 7 * 4
 603: 3721+11	030C' 09      	                add hl, bc
 604:				;
 605: 3732+7	030D' 0E08    	                ld c, 8                 ; Register counter
 606: 3739+7	030F' 0604    	bch_reg_loop    ld b, 4                 ; Byte counter
 607: 3746+7	0311' 1A      	bch_byte_loop   ld a, (de)
 608: 3753+7	0312' BE      	                cp (hl)
 609: 3760+7+5	0313' 2012    	                jr nz, bch_miss
 610: 3767+6	0315' 13      	                inc de
 611: 3773+6	0316' 23      	                inc hl
 612: 3779+8+5	0317' 10F8    	                djnz bch_byte_loop
 613:				; Register complete. Make HL point to the MS byte of the previous register.
 614: 3787+11	0319' C5      	                push bc
 615: 3798+10	031A' 01F8FF  	                ld bc, -8
 616: 3808+11	031D' 09      	                add hl, bc
 617: 3819+10	031E' C1      	                pop bc
 618: 3829+4	031F' 0D      	                dec c
 619: 3833+7+5	0320' 20ED    	                jr nz, bch_reg_loop
 620:				; Hashes match!
 621: 3840+10	0322' D1      	                pop de                  ; Discard pointers
 622: 3850+10	0323' E1      	                pop hl
 623: 3860+4	0324' A7      	                and a                   ; Flag success
 624: 3864+12	0325' 1824    	                jr bch_exit
 625:				;
 626: 3876+17	0327' CD0000  	bch_miss        call cwnwln             ; Write new line characters to console
 627: 3893+10	032A' 216E04  	                ld hl, hc_mismatch_msg  ; "Hash mismatch. Expected:"
 628: 3903+17	032D' CD0000  	                call conwms             ; Print $-terminated string to console
 629: 3920+10	0330' E1      	                pop hl                  ; Recover pointer to expected hash
 630:				; Neither sh2dh or bit_disp_hash will display as expected because the value is
 631:				; reversed as well as being in big-endian order.
 632: 3930+7	0331' 0620    	                ld b, 8 * 4
 633: 3937+7	0333' 7E      	bch_disp_loop   ld a, (hl)
 634: 3944+17	0334' CD0000  	                call cwphby             ; Print A in hexadecimal
 635: 3961+6	0337' 23      	                inc hl
 636: 3967+8+5	0338' 10F9    	                djnz bch_disp_loop
 637: 3975+17	033A' CD0000  	                call cwnwln             ; Write new line characters to console
 638: 3992+10	033D' 218904  	                ld hl, hc_found_msg     ; "found:"
 639: 4002+17	0340' CD0000  	                call conwms             ; Print $-terminated string to console
 640: 4019+10	0343' E1      	                pop hl                  ; Recover pointer to calculated hash
 641: 4029+17	0344' CD6903  	                call bit_disp_hash      ; Display hash value in Bitcoin format
 642: 4046+17	0347' CD0000  	                call cwnwln             ; Write new line characters to console
 643: 4063+4	034A' 37      	                scf                     ; Flag error
 644:				;
 645: 4067+10	034B' C1      	bch_exit        pop bc
 646: 4077+10	034C' C9      	                ret
 647:				;
 648:				;
 649:				; Copy h0 to h7 (the hash digest) to a buffer, performing an endian swap as
 650:				; we go.
 651:				; DE - pointer to buffer
 652:				; HL - pointer to message digest (h0 to h7)
 653: 4087+11	034D' C5      	copy_hash       push bc
 654:				;
 655: 4098+7	034E' 0608    	                ld b, 8                 ; Register counter
 656: 4105+6	0350' 13      	ch_reg_loop     inc de                  ; Advance to last (MS) byte
 657: 4111+6	0351' 13      	                inc de
 658: 4117+6	0352' 13      	                inc de
 659: 4123+11	0353' D5      	                push de
 660: 4134+7	0354' 7E      	                ld a, (hl)
 661: 4141+7	0355' 12      	                ld (de), a
 662: 4148+6	0356' 23      	                inc hl
 663: 4154+6	0357' 1B      	                dec de
 664: 4160+7	0358' 7E      	                ld a, (hl)
 665: 4167+7	0359' 12      	                ld (de), a
 666: 4174+6	035A' 23      	                inc hl
 667: 4180+6	035B' 1B      	                dec de
 668: 4186+7	035C' 7E      	                ld a, (hl)
 669: 4193+7	035D' 12      	                ld (de), a
 670: 4200+6	035E' 23      	                inc hl
 671: 4206+6	035F' 1B      	                dec de
 672: 4212+7	0360' 7E      	                ld a, (hl)
 673: 4219+7	0361' 12      	                ld (de), a
 674: 4226+6	0362' 23      	                inc hl
 675: 4232+10	0363' D1      	                pop de
 676: 4242+6	0364' 13      	                inc de                  ; Advance to next longword
 677: 4248+8+5	0365' 10E9    	                djnz ch_reg_loop        ; Loop for all registers
 678:				;
 679: 4256+10	0367' C1      	                pop bc
 680: 4266+10	0368' C9      	                ret
 681:				;
 682:				;
 683:				; Display hash value. This works the same way as sh2dh in sha-256.z80, but in
 684:				; this case the bytes are displayed in reverse order to suit Bitcoin
 685:				; conventions.
 686:				; Call with:
 687:				; HL - pointer to hash (message digest [h0 to h7])
 688: 4276+11	0369' C5      	bit_disp_hash   push bc
 689:				;
 690:				; Advance address to last register (h7)
 691: 4287+10	036A' 011C00  	                ld bc, 7 * 4
 692: 4297+11	036D' 09      	                add hl, bc
 693: 4308+7	036E' 0608    	                ld b, 8                 ; Register counter
 694: 4315+11	0370' E5      	bdh_reg_loop    push hl
 695: 4326+17	0371' CD7D03  	                call disp_hex32_be      ; Display big endian value
 696: 4343+10	0374' E1      	                pop hl
 697: 4353+6	0375' 2B      	                dec hl                  ; Point to next word
 698: 4359+6	0376' 2B      	                dec hl
 699: 4365+6	0377' 2B      	                dec hl
 700: 4371+6	0378' 2B      	                dec hl
 701: 4377+8+5	0379' 10F5    	                djnz bdh_reg_loop
 702:				;
 703: 4385+10	037B' C1      	                pop bc
 704: 4395+10	037C' C9      	                ret
 705:				;
 706:				;
 707:				; Display 32-bit big-endian hexadecimal value in memory. Call with:
 708:				; HL - pointer to value
 709: 4405+11	037D' C5      	disp_hex32_be   push bc
 710:				;
 711: 4416+7	037E' 0604    	                ld b, 4                 ; Byte counter
 712: 4423+7	0380' 7E      	dhb32_loop      ld a, (hl)
 713: 4430+17	0381' CD0000  	                call cwphby             ; Print A in hexadecimal
 714: 4447+6	0384' 23      	                inc hl
 715: 4453+8+5	0385' 10F9    	                djnz dhb32_loop
 716:				;
 717: 4461+10	0387' C1      	                pop bc
 718: 4471+10	0388' C9      	                ret
 719:				;
 720:				; Display OK message.
 721: 4481+10	0389' 219204  	disp_ok         ld hl, ok_msg           ; "OK"
 722: 4491+10	038C' C30000  	                jp conwms               ; Print $-terminated string to console
 723:				;
 724:				;
 725:				;
 726:				; *************
 727:				; * Constants *
 728:				; *************
 729:				;
 730:				;
 731:     -	038F' 2A2A2A20	signon_msg      byte "*** Bitcoin Mining V1.0 ***", 0x0d, 0x0a, "$"
	              42697463
	              6F696E20
	              4D696E69
	              6E672056
	              312E3020
	              2A2A2A0D
	              0A24
 732:     -	03AD' 5A383020	no_z80_msg      byte "Z80 CPU required", 0x0d, 0x0a, "$"
	              43505520
	              72657175
	              69726564
	              0D0A24
 733:     -	03C0' 5A415243	no_zarc_msg     byte "ZARC BIOS not detected. Timing not available."
	              2042494F
	              53206E6F
	              74206465
	              74656374
	              65642E20
	              54696D69
	              6E67206E
	              6F742061
	              7661696C
	              61626C65
	              2E
 734:     -	03ED' 0D0A24  	                byte 0x0d, 0x0a, "$"
 735:     -	03F0' 556E6578	op_err_msg      byte "Unexpected operand(s).$"
	              70656374
	              6564206F
	              70657261
	              6E642873
	              292E24
 736:     -	0407' 0D0A4578	break_msg       byte 0x0d, 0x0a, "Exiting due to ^C", 0x0d, 0x0a, "$"
	              6974696E
	              67206475
	              6520746F
	              205E430D
	              0A24
 737:     -	041D' 52657475	exit_msg        byte "Returning to CP/M.", 0x0d, 0x0a, "$"
	              726E696E
	              6720746F
	              2043502F
	              4D2E0D0A
	              24
 738:     -	0432' 53746172	start_msg       byte "Starting mining. Press ^C to exit.", 0x0d, 0x0a, "$"
	              74696E67
	              206D696E
	              696E672E
	              20507265
	              7373205E
	              4320746F
	              20657869
	              742E0D0A
	              24
 739:     -	0457' 0D497465	iter_msg        byte 0x0d, "Iteration: $"
	              72617469
	              6F6E3A20
	              24
 740:     -	0464' 2C206465	delta_msg       byte ", delta: $"
	              6C74613A
	              2024
 741:     -	046E' 48617368	hc_mismatch_msg byte "Hash mismatch. Expected:", 0x0d, 0x0a, "$"
	              206D6973
	              6D617463
	              682E2045
	              78706563
	              7465643A
	              0D0A24
 742:     -	0489' 666F756E	hc_found_msg    byte "found:", 0x0d, 0x0a, "$"
	              643A0D0A
	              24
 743:     -	0492' 4F4B0D0A	ok_msg          byte "OK", 0x0d, 0x0a, "$"
	              24
 744:     -	0497' 4E756C6C	test_null_msg   byte "Null message test: $"
	              206D6573
	              73616765
	              20746573
	              743A2024
 745:     -	04AB' 53686F72	test_short_msg  byte "Short message test: $"
	              74206D65
	              73736167
	              65207465
	              73743A20
	              24
 746:     -	04C0' 4C6F6E67	test_long_msg   byte "Long message test: $"
	              206D6573
	              73616765
	              20746573
	              743A2024
 747:     -	04D4' 4C6F6E67	test_long2_msg  byte "Long message test 2: $"
	              206D6573
	              73616765
	              20746573
	              7420323A
	              2024
 748:     -	04EA' 42697463	genesis_msg     byte "Bitcoin genesis block: $"
	              6F696E20
	              67656E65
	              73697320
	              626C6F63
	              6B3A2024
 749:     -	0502' 42697463	bitc_exam_msg   byte "Bitcoin example block: $"
	              6F696E20
	              6578616D
	              706C6520
	              626C6F63
	              6B3A2024
 750:     -	051A' 4C6F6164	load_state_msg  byte "Loading saved state.", 0x0d, 0x0a, "$"
	              696E6720
	              73617665
	              64207374
	              6174652E
	              0D0A24
 751:     -	0531' 42495443	save_fn         byte "BITCOIN SAV"
	              4F494E20
	              534156
 752:     -	053C' 4572726F	load_err_msg    byte "Error reading saved state. "
	              72207265
	              6164696E
	              67207361
	              76656420
	              73746174
	              652E20
 753:     -	0557' 5573696E	                byte "Using bitcoin genesis block.", 0x0d, 0x0a, "$"
	              67206269
	              74636F69
	              6E206765
	              6E657369
	              7320626C
	              6F636B2E
	              0D0A24
 754:     -	0576' 0D0A5361	save_msg        byte 0x0d, 0x0a, "Saving state to file $"
	              76696E67
	              20737461
	              74652074
	              6F206669
	              6C652024
 755:     -	058E' 4572726F	save_err_msg    byte "Error saving state.", 0x0d, 0x0a, "$"
	              72207361
	              76696E67
	              20737461
	              74652E0D
	              0A24
 756:     -	05A4' 0D0A4265	best_msg        byte 0x0d, 0x0a, "Best nonce / hash found:", 0x0d, 0x0a, "$"
	              7374206E
	              6F6E6365
	              202F2068
	              61736820
	              666F756E
	              643A0D0A
	              24
 757:				;
 758:				;
 759:				; Null message test hash.
 760:				; Should be 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
 761:     -	05C1' 42C4B0E3	null_msg_hash   dword 0xe3b0c442, 0x98fc1c14, 0x9afbf4c8, 0x996fb924
	              141CFC98
	              C8F4FB9A
	              24B96F99
 762:     -	05D1' E441AE27	                dword 0x27ae41e4, 0x649b934c, 0xa495991b, 0x7852b855
	              4C939B64
	              1B9995A4
	              55B85278
 763:				;
 764:				; Short message test hash.
 765:				; Should be 0x60e76ce856c4bd873cc66e424d214ced480d77c34091aad5eb190b2cd9668bd8
 766:				; according to https://www.movable-type.co.uk/scripts/sha256.html
 767:     -	05E1' 41207465	test1_msg       byte "A test message."
	              7374206D
	              65737361
	              67652E
 768:     -	000F'         	test1_msg_len   equ $ - test1_msg
 769:     -	05F0' E86CE760	test1_msg_hash  dword 0x60e76ce8, 0x56c4bd87, 0x3cc66e42, 0x4d214ced
	              87BDC456
	              426EC63C
	              ED4C214D
 770:     -	0600' C3770D48	                dword 0x480d77c3, 0x4091aad5, 0xeb190b2c, 0xd9668bd8
	              D5AA9140
	              2C0B19EB
	              D88B66D9
 771:				;
 772:				; Multi-chunk message test hash (32 bytes / line).
 773:				; Should be 0x6dcec3724b30827de24fb9a3c2ce966af5ee167d60a6d1f6751131189a4bff46
 774:				; according to https://www.movable-type.co.uk/scripts/sha256.html
 775:     -	0610' 4C6F7265	test2_msg       byte "Lorem ipsum dolor sit amet, cons"
	              6D206970
	              73756D20
	              646F6C6F
	              72207369
	              7420616D
	              65742C20
	              636F6E73
 776:     -	0630' 65637465	                byte "ectetur adipiscing elit, sed do "
	              74757220
	              61646970
	              69736369
	              6E672065
	              6C69742C
	              20736564
	              20646F20
 777:     -	0650' 65697573	                byte "eiusmod tempor incididunt ut lab"
	              6D6F6420
	              74656D70
	              6F722069
	              6E636964
	              6964756E
	              74207574
	              206C6162
 778:     -	0670' 6F726520	                byte "ore et dolore magna.    "
	              65742064
	              6F6C6F72
	              65206D61
	              676E612E
	              20202020
 779:     -	0078'         	test2_msg_len   equ $ - test2_msg
 780:     -	0688' 72C3CE6D	test2_msg_hash  dword 0x6dcec372, 0x4b30827d, 0xe24fb9a3, 0xc2ce966a
	              7D82304B
	              A3B94FE2
	              6A96CEC2
 781:     -	0698' 7D16EEF5	                dword 0xf5ee167d, 0x60a6d1f6, 0x75113118, 0x9a4bff46
	              F6D1A660
	              18311175
	              46FF4B9A
 782:				; Test message as one line:
 783:				; Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna.    
 784:				;
 785:				; test3 uses test2 text, but is just one character shorter.
 786:				; Should be 0x0c6b0d223dd57168016f9b91749df4d83954a5ba6232b5060746e9e6b7e6b527
 787:				; according to https://www.movable-type.co.uk/scripts/sha256.html
 788:     -	0077'         	test3_msg_len   equ test2_msg_len - 1
 789:     -	06A8' 220D6B0C	test3_msg_hash  dword 0x0c6b0d22, 0x3dd57168, 0x016f9b91, 0x749df4d8
	              6871D53D
	              919B6F01
	              D8F49D74
 790:     -	06B8' BAA55439	                dword 0x3954a5ba, 0x6232b506, 0x0746e9e6, 0xb7e6b527
	              06B53262
	              E6E94607
	              27B5E6B7
 791:				; Test message as one line:
 792:				; Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna.   
 793:				;
 794:				; Time between messages in ms as a 32-bit integer.
 795:     -	06C8' D0070000	msg_per_const   dword MSG_PERIOD
 796:				;
 797:				; Raw hex version of the Genesis block (header only).
 798:     -	06CC' 01000000	genesis         byte 0x01, 0x00, 0x00, 0x00         ; Version
 799:				; Previous block hash
 800:     -	06D0' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 801:     -	06D8' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 802:     -	06E0' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 803:     -	06E8' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 804:				; Merkle root
 805:     -	06F0' 3BA3EDFD	                byte 0x3B, 0xA3, 0xED, 0xFD, 0x7A, 0x7B, 0x12, 0xB2
	              7A7B12B2
 806:     -	06F8' 7AC72C3E	                byte 0x7A, 0xC7, 0x2C, 0x3E, 0x67, 0x76, 0x8F, 0x61
	              67768F61
 807:     -	0700' 7FC81BC3	                byte 0x7F, 0xC8, 0x1B, 0xC3, 0x88, 0x8A, 0x51, 0x32
	              888A5132
 808:     -	0708' 3A9FB8AA	                byte 0x3A, 0x9F, 0xB8, 0xAA, 0x4B, 0x1E, 0x5E, 0x4A
	              4B1E5E4A
 809:     -	0710' 29AB5F49	                byte 0x29, 0xAB, 0x5F, 0x49         ; Timestamp
 810:     -	0714' FFFF001D	                byte 0xFF, 0xFF, 0x00, 0x1D         ; Difficulty
 811:     -	0718' 1DAC2B7C	                byte 0x1D, 0xAC, 0x2B, 0x7C         ; Nonce
 812:				; End of header
 813:     -	0001'         	                assert ($ - genesis) = BH_SIZE
 814:				; Corresponding hash (in Bitcoin reversed format).
 815:     -	071C' 00000000	genesis_hash    byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xd6, 0x68
	              0019D668
 816:     -	0724' 9C085AE1	                byte 0x9c, 0x08, 0x5a, 0xe1, 0x65, 0x83, 0x1e, 0x93
	              65831E93
 817:     -	072C' 4FF763AE	                byte 0x4f, 0xf7, 0x63, 0xae, 0x46, 0xa2, 0xa6, 0xc1
	              46A2A6C1
 818:     -	0734' 72B3F1B6	                byte 0x72, 0xb3, 0xf1, 0xb6, 0x0a, 0x8c, 0xe2, 0x6f
	              0A8CE26F
 819:				;
 820:				; Bitcoin header example from:
 821:				; http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html
 822:				; Looking it up here:
 823:				; https://api.blockchair.com/bitcoin/raw/block/286819
 824:     -	073C' 02000000	bitc_example    byte 0x02, 0x00, 0x00, 0x00         ; Version
 825:				; Previous block hash (reversed), as in raw hex dump
 826:     -	0740' 17975B97	                byte 0x17, 0x97, 0x5b, 0x97, 0xc1, 0x8e, 0xd1, 0xf7
	              C18ED1F7
 827:     -	0748' E255ADF2	                byte 0xe2, 0x55, 0xad, 0xf2, 0x97, 0x59, 0x9b, 0x55
	              97599B55
 828:     -	0750' 330EDAB8	                byte 0x33, 0x0e, 0xda, 0xb8, 0x78, 0x03, 0xc8, 0x17
	              7803C817
 829:     -	0758' 01000000	                byte 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 830:				; Merkle root (reversed), as in raw hex dump
 831:     -	0760' 8A97295A	                byte 0x8a, 0x97, 0x29, 0x5a, 0x27, 0x47, 0xb4, 0xf1
	              2747B4F1
 832:     -	0768' A0B3948D	                byte 0xa0, 0xb3, 0x94, 0x8d, 0xf3, 0x99, 0x03, 0x44
	              F3990344
 833:     -	0770' C0E19FA6	                byte 0xc0, 0xe1, 0x9f, 0xa6, 0xb2, 0xb9, 0x2b, 0x3a
	              B2B92B3A
 834:     -	0778' 19C8E6BA	                byte 0x19, 0xc8, 0xe6, 0xba, 0xdc, 0x14, 0x17, 0x87
	              DC141787
 835:     -	0780' 358B0553	                byte 0x35, 0x8b, 0x05, 0x53         ; Timestamp
 836:     -	0784' 535F0119	                byte 0x53, 0x5f, 0x01, 0x19         ; Difficulty
 837:     -	0788' 48750833	                byte 0x48, 0x75, 0x08, 0x33         ; Nonce
 838:				; End of header
 839:     -	0001'         	                assert ($ - bitc_example) = BH_SIZE
 840:				; Corresponding hash (in Bitcoin reversed format).
 841:     -	078C' 00000000	bitc_exam_hash  byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 842:     -	0794' E067A478	                byte 0xe0, 0x67, 0xa4, 0x78, 0x02, 0x4a, 0xdd, 0xfe
	              024ADDFE
 843:     -	079C' CDC93628	                byte 0xcd, 0xc9, 0x36, 0x28, 0x97, 0x8a, 0xa5, 0x2d
	              978AA52D
 844:     -	07A4' 91FABD42	                byte 0x91, 0xfa, 0xbd, 0x42, 0x92, 0x98, 0x2a, 0x50
	              92982A50
 845:				;
 846:				;
 847:				;
 848:				; *************
 849:				; * Variables *
 850:				; *************
 851:				;
 852:				;
 853:				; Note: linker "-c" option is used, so no data is initialised here.
 854:				                dseg                ; Data segment
 855:				;
 856:     -	0000"         	bdos_sp         defs 2              ; BDOS's stack pointer
 857:     -	0002"         	zarc_flag       defs 1              ; Non-zero if on a ZARC system
 858:     -	0003"         	fcbr            defs FCBR_SIZE      ; FCB and record buffer structure
 859:     -	00A9"         	msg_time        defs 4              ; Message timer (ms)
 860:     -	00AD"         	iter_delta      defs 2              ; Iterations since last report
 861:     -	00AF"         	bit_hash_buf    defs SH2_DIGEST_BYTES   ; Space for hash digest
 862:				;
 863:     -	00CF"         	save_start                          ; Start of saved variables
 864:     -	00CF"         	iter_count      defs 4              ; Iteration counter
 865:     -	00D3"         	bit_hdr_buf     defs BH_SIZE        ; Bitcoin block header buffer
 866:     -	0123"         	best_hash       defs SH2_DIGEST_BYTES   ; Smallest hash found
 867:     -	0143"         	best_nonce      defs 4              ; Nonce corresponding to above
 868:     -	0078"         	save_size       equ $ - save_start
 869:				;
 870:     -	0147"         	                defs STACK_SIZE     ; Stack space
 871:     -	0187"         	app_stack_top
 872:				;
 873:     -	0187"         	                end



Statistics:

     4	passes
     0	jr promotions
   446	symbols
  1964	bytes

   195	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BH_DIFFICULTY  =48        72
BH_MERKLE      =24        36
BH_NONCE       =4C        76
BH_PREV_HASH   =04        4
BH_SIZE        =50        80
BH_TIME_STAMP  =44        68
BH_VER         =00        0
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
BREAK_CHAR     =03        3
CCP_START      =D600      54784
CDISK          =04        4
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCBR_CONTENTS  =25        37
FCBR_FCB       =00        0
FCBR_FLAGS     =24        36
FCBR_FL_DIRTY_BIT=01        1
FCBR_FL_DIRTY_MASK=02        2
FCBR_FL_OPEN_BIT=00        0
FCBR_FL_OPEN_MASK=01        1
FCBR_RBUFF     =26        38
FCBR_SIZE      =A6        166
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MMAP_CPM_PAGES =04        4
MSG_PERIOD     = 7D0      2000
MSG_REP_MASK   =1F        31
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
SH2_CHUNK_BITS = 200      512
SH2_CHUNK_BYTES=40        64
SH2_CHUNK_LONGS=10        16
SH2_DIGEST_BITS= 100      256
SH2_DIGEST_BYTES=20        32
STACK_SIZE     =40        64
TPA_START      = 100      256
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
app_stack_top    187"     391
bch_byte_loop    311'     785
bch_disp_loop    333'     819
bch_exit         34B'     843
bch_miss         327'     807
bch_reg_loop     30F'     783
bdh_reg_loop     370'     880
bdos_sp         00"       0
best_hash        123"     291
best_msg         5A4'     1444
best_nonce       143"     323
bit_cmp_hashes   306'     774
bit_disp_hash    369'     873
bit_hash_buf    AF"       175
bit_hdr_buf     D3"       211
bitc_exam_hash   78C'     1932
bitc_exam_msg    502'     1282
bitc_example     73C'     1852
break_det        278'     632
break_msg        407'     1031
cbdos           00        0 (extern)
cbios           00        0 (extern)
ch_exit          304'     772
ch_loop          2D8'     728
ch_miss          2E6'     742
ch_reg_loop      350'     848
cmp_hashes       2D2'     722
conrch          00        0 (extern)
const           00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
copy_hash        34D'     845
crc16x          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
delta_msg        464'     1124
dhb32_loop       380'     896
disp_best        2AA'     682
disp_hex32_be    37D'     893
disp_ok          389'     905
enum_counter   =04        4
exit             29A'     666
exit_msg         41D'     1053
fbfcb           00        0 (extern)
fcbr            03"       3
fclose          00        0 (extern)
fdel            00        0 (extern)
fdfcb           00        0 (extern)
fdnam           00        0 (extern)
fdsrem          00        0 (extern)
fdswem          00        0 (extern)
finit           00        0 (extern)
fmake           00        0 (extern)
fopen           00        0 (extern)
frdblk          00        0 (extern)
frdby           00        0 (extern)
frdrec          00        0 (extern)
fstfre          00        0 (extern)
fwrblk          00        0 (extern)
fwrby           00        0 (extern)
fwrrec          00        0 (extern)
genesis          6CC'     1740
genesis_hash     71C'     1820
genesis_msg      4EA'     1258
hc_found_msg     489'     1161
hc_mismatch_msg  46E'     1134
hcmp_byte_loop   1C2'     450
hcmp_reg_loop    1BE'     446
init_clr_hash    155'     341
init_fcbr       30'       48
initt_done       18D'     397
iter_count      CF"       207
iter_delta      AD"       173
iter_msg         457'     1111
jptbl_addr     =F6        246
load_done        165'     357
load_err_msg     53C'     1340
load_error       137'     311
load_state_msg   51A'     1306
madbbu          00        0 (extern)
madd32          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
main_loop        196'     406
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
mclr32          00        0 (extern)
mcop32          00        0 (extern)
mcp32           00        0 (extern)
minc32          00        0 (extern)
ml_no_break      275'     629
msg_exit         297'     663
msg_per_const    6C8'     1736
msg_time        A9"       169
msub32          00        0 (extern)
mtwdli          00        0 (extern)
next_nonce       1EC'     492
no_z80_msg       3AD'     941
no_zarc_msg      3C0'     960
null_msg_hash    5C1'     1473
ok_msg           492'     1170
on_z80          18'       24
op_check_term   3A'       58
op_err_msg       3F0'     1008
op_error        41'       65
operands_ok     47'       71
panic           00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
rep_delinc_dn    206'     518
rep_done         265'     613
rep_not_zarc     224'     548
rep_start        22B'     555
save_err_msg     58E'     1422
save_error       294'     660
save_fn          531'     1329
save_msg         576'     1398
save_size      =78        120
save_start      CF"       207
sh2dh           00        0 (extern)
sh2ini          00        0 (extern)
sh2m            00        0 (extern)
signon_msg       38F'     911
skpspc          00        0 (extern)
start_msg        432'     1074
str_offset     =A6        166
test1_msg        5E1'     1505
test1_msg_hash   5F0'     1520
test1_msg_len  =0F        15
test2_msg        610'     1552
test2_msg_hash   688'     1672
test2_msg_len  =78        120
test3_msg_hash   6A8'     1704
test3_msg_len  =77        119
test_long2_msg   4D4'     1236
test_long_msg    4C0'     1216
test_null_msg    497'     1175
test_short_msg   4AB'     1195
toloca          00        0 (extern)
toupca          00        0 (extern)
z80det          00        0 (extern)
zarc_flag       02"       2
zrcdet          00        0 (extern)
