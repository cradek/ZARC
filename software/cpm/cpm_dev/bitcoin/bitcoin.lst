   1:				; *******************************************************
   2:				; * Bitcoin Mining for CP/M                             *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 5/9/2022                            *
   5:				; *******************************************************
   6:				;
   7:				; This program is intended to run under CP/M 2.2. It should run under any such
   8:				; system, though timing is only available when run on ZARC.
   9:				;
  10:				                title Bitcoin Mining for CP/M
  11:				;
  12:				;
  13:				;
  14:				; ************
  15:				; * Includes *
  16:				; ************
  17:				;
  18:				;
  19:				                include "macros.i"
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** bitcoin.z80 ****
  20:				                include "cpm.i"
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** bitcoin.z80 ****
  21:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** bitcoin.z80 ****
  22:				                include "bitcoin.i"     ; Project include file
**** bitcoin.i ****
   1:				; *******************************************************
   2:				; * Bitcoin Mining for CP/M                             *
   3:				; * Include file                                        *
   4:				; * Written by: Merlin Skinner                          *
   5:				; * Date Started: 5/9/2022                              *
   6:				; *******************************************************
   7:				;
   8:				;
   9:				;
  10:				; *************
  11:				; * Constants *
  12:				; *************
  13:				;
  14:				;
  15:				;DEBUG           equ 1                   ; Define to enable debug messages
  16:				;
  17:     -	0040'         	STACK_SIZE      equ 64                  ; Stack space allocation
  18:     -	0003'         	BREAK_CHAR      equ 'C' - 0x40
  19:				;
  20:     -	2710'         	MSG_PERIOD      equ 10 * 1000           ; Time between messages in ms (ZARC)
  21:     -	001F'         	MSG_REP_MASK    equ 32 - 1              ; Iteration report mask
  22:				; MSG_REP_MASK must be 2^n - 1, where n is a positive integer. Reports will
  23:				; occur every 2^n iterations.
  24:     -	0200'         	SH2_CHUNK_BITS  equ 512                 ; SHA-2 chunk size in bits
  25:     -	0040'         	SH2_CHUNK_BYTES equ (SH2_CHUNK_BITS / 8) ; Above in bytes
  26:     -	0010'         	SH2_CHUNK_LONGS equ (SH2_CHUNK_BYTES / 4) ; Above in 32-bit words
  27:     -	0100'         	SH2_DIGEST_BITS equ 256                 ; SHA-2 digest size in bits
  28:     -	0020'         	SH2_DIGEST_BYTES equ (SH2_DIGEST_BITS / 8) ; Above in bytes
  29:				;
  30:				; Block header structure.
  31:     -	        	                STRUCT
  32:     -	        	                STR_LONG BH_VER         ; Bitcoin version number
  33:     -	        	                STR_BLOCK BH_PREV_HASH, 32  ; Previous block hash
  34:     -	        	                STR_BLOCK BH_MERKLE, 32 ; Merkle root
  35:     -	        	                STR_LONG BH_TIME_STAMP  ; Bitcoin version number
  36:     -	        	                STR_LONG BH_DIFFICULTY  ; Difficulty target for the block
  37:     -	        	                STR_LONG BH_NONCE
  38:     -	        	                STR_END BH_SIZE
  39:				;
  40:     -	0001'         	                assert BH_SIZE = 80
  41:				;
  42:				; From https://developer.bitcoin.org/reference/block_chain.html
  43:				; The hashes are in internal byte order; the other values are all in
  44:				; little-endian order.
  45:				;
  46:				;
**** bitcoin.z80 ****
  23:				                include "z80.i"
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000'         	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008'         	Z80_RST08_VEC   equ 0x0008
  12:     -	0010'         	Z80_RST10_VEC   equ 0x0010
  13:     -	0018'         	Z80_RST18_VEC   equ 0x0018
  14:     -	0020'         	Z80_RST20_VEC   equ 0x0020
  15:     -	0028'         	Z80_RST28_VEC   equ 0x0028
  16:     -	0030'         	Z80_RST30_VEC   equ 0x0030
  17:     -	0038'         	Z80_RST38_VEC   equ 0x0038
  18:     -	0066'         	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** bitcoin.z80 ****
  24:				                include "monitor.i"
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** bitcoin.z80 ****
  25:				                include "cpm_utility.i" ; CP/M utilities
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMU         ; Inhibit for this module
  10:				; CP/M specific.
  11:				                extern cbdos    ; Call BDOS with some registers saved
  12:				                extern cbios    ; Call BIOS with some registers saved
  13:				                extern panic    ; Fatal application error
  14:				                extern zrcdet   ; Detect ZARC
  15:				                extern z80det   ; Detect Z80 (instead of 8080 / 8085)
  16:				;
  17:				; Derived from the monitor's utility.z80.
  18:				                extern conwch   ; Write character to console
  19:				                extern conrch   ; Read character from the console
  20:				                extern const    ; Fetch console input status
  21:				                extern cwnwln   ; Write new line characters to console
  22:				                extern conwms   ; Print "$" terminated string to the console
  23:				                extern conwmn   ; Print message <n> in a list
  24:				                extern skpspc   ; Step hl past spaces
  25:				                extern toupca   ; Convert character in A to upper case
  26:				                extern toloca   ; Convert character in A to lower case
  27:				                extern cwvich   ; Print only visible 7-bit characters
  28:				                extern cwpspc   ; Print a space
  29:				                extern mtwdli   ; Match word in a string against list of options
  30:				                extern cwphnb   ; Print least-significant nibble in A in hexadecimal
  31:				                extern cwphby   ; Print A in hexadecimal
  32:				                extern cwphwd   ; Print HL in hexadecimal
  33:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  34:				                extern cwpdby   ; Print A in decimal. Leading zeros are suppressed
  35:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  36:				                extern cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  37:				                extern rdhxwd   ; Read a 16-bit hexadecimal number from a string
  38:				                extern rdduwd   ; Read a 16-bit unsigned decimal number from a string
  39:				                extern rddulo   ; Read a 32-bit unsigned decimal number from a string
  40:				;
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** bitcoin.z80 ****
  26:				                include "cpm_files.i"   ; CP/M file handling
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//cpm_files.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMF         ; Inhibit for this module
  10:				                extern finit    ; Initialise FCBR structure
  11:				                extern fbfcb    ; Build FCB
  12:				                extern fdel     ; Delete file *
  13:				                extern fopen    ; Open existing file for R/W *
  14:				                extern fmake    ; Create new file *
  15:				                extern fwrrec   ; Write record to file *
  16:				                extern fwrby    ; Write byte to file *
  17:				                extern fwrblk   ; Write block to file *
  18:				                extern frdrec   ; Read record from file *
  19:				                extern frdby    ; Read byte from file *
  20:				                extern frdblk   ; Read block from file *
  21:				                extern fclose   ; Close file *
  22:				                extern fdfcb    ; Display FCB
  23:				                extern fdnam    ; Display filename
  24:				                extern fdswem   ; Display sequential write error message
  25:				                extern fdsrem   ; Display sequential read error message
  26:				            endif
  27:				;
  28:				; * Any errors are reported to the console.
  29:				;
  30:				; FCB with record buffer. This is used by the cpm_files routines.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BLOCK FCBR_FCB, FCB_SIZE    ; FCB structure
  33:     -	        	                STR_BYTE FCBR_FLAGS             ; Status flags
  34:     -	        	                STR_BYTE FCBR_CONTENTS          ; No. of bytes in RBUFF (*)
  35:     -	        	                STR_BLOCK FCBR_RBUFF, CPM_SECTOR_SIZE   ; Record buffer
  36:     -	        	                STR_END FCBR_SIZE               ; Structure size
  37:				;
  38:				; Flags are active if the bit is zero.
  39:     -	        	BITDEF FCBR_FL_OPEN, 0          ; File is open
  40:     -	        	BITDEF FCBR_FL_DIRTY, 1         ; RBUFF contains data to write
  41:				
**** bitcoin.z80 ****
  27:				                include "cpm_maths.i"   ; Integer mathematics
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//cpm_maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for CP/M Applications         *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 10/9/2022                           *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMM         ; Inhibit for this module
  10:				; CP/M specific.
  11:				; 32-bit arithmetic.
  12:				                extern mclr32       ; 32-bit clear (zero)
  13:				                extern mcop32       ; 32-bit copy from (hl) to (de)
  14:				                extern minc32       ; 32-bit increment
  15:				                extern mcp32        ; 32-bit compare (hl) - (de)
  16:				                extern madd32       ; 32-bit add (hl) <- (hl) + (de)
  17:				                extern msub32       ; 32-bit sub (hl) <- (hl) - (de)
  18:				;
  19:				; Derived from the monitor's maths.z80.
  20:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  21:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  22:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  23:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  24:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  25:				                extern crc16x       ; Software CRC-16 (XMODEM)
  26:				;
  27:				            endif
  28:				;
**** bitcoin.z80 ****
  28:				                include "cpm_files.i"   ; CP/M file handling
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//cpm_files.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMF         ; Inhibit for this module
  10:				                extern finit    ; Initialise FCBR structure
  11:				                extern fbfcb    ; Build FCB
  12:				                extern fdel     ; Delete file *
  13:				                extern fopen    ; Open existing file for R/W *
  14:				                extern fmake    ; Create new file *
  15:				                extern fwrrec   ; Write record to file *
  16:				                extern fwrby    ; Write byte to file *
  17:				                extern fwrblk   ; Write block to file *
  18:				                extern frdrec   ; Read record from file *
  19:				                extern frdby    ; Read byte from file *
  20:				                extern frdblk   ; Read block from file *
  21:				                extern fclose   ; Close file *
  22:				                extern fdfcb    ; Display FCB
  23:				                extern fdnam    ; Display filename
  24:				                extern fdswem   ; Display sequential write error message
  25:				                extern fdsrem   ; Display sequential read error message
  26:				            endif
  27:				;
  28:				; * Any errors are reported to the console.
  29:				;
  30:				; FCB with record buffer. This is used by the cpm_files routines.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BLOCK FCBR_FCB, FCB_SIZE    ; FCB structure
  33:     -	        	                STR_BYTE FCBR_FLAGS             ; Status flags
  34:     -	        	                STR_BYTE FCBR_CONTENTS          ; No. of bytes in RBUFF (*)
  35:     -	        	                STR_BLOCK FCBR_RBUFF, CPM_SECTOR_SIZE   ; Record buffer
  36:     -	        	                STR_END FCBR_SIZE               ; Structure size
  37:				;
  38:				; Flags are active if the bit is zero.
  39:     -	        	BITDEF FCBR_FL_OPEN, 0          ; File is open
  40:     -	        	BITDEF FCBR_FL_DIRTY, 1         ; RBUFF contains data to write
  41:				
**** bitcoin.z80 ****
  29:				                include "cpm_top.i"     ; CP/M dummy top module
**** /home/merlin/Technical/HardwareProjects/ZARC_Z80_Box/software/includes//cpm_top.i ****
   1:				; *******************************************************
   2:				; * Dummy Module to find the Last Location in Use.      *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				                extern fstfre       ; First location after end of data segment
  10:				
**** bitcoin.z80 ****
  30:				;
  31:				;
  32:				;
  33:				; *************
  34:				; * Externals *
  35:				; *************
  36:				;
  37:				;
  38:				; Variables
  39:				;                public brkflg   ; Non-zero if break character detected
  40:				;
  41:				; From sha-256.z80
  42:				                extern sh2ini   ; Initialise sha-256 state
  43:				                extern sh2m     ; Process a message in memory
  44:				                extern sh2dh    ; Display hash value
  45:				;
  46:				;
  47:				;
  48:				; *************
  49:				; * Main Code *
  50:				; *************
  51:				;
  52:				;
  53:				; The CP/M transient area start address is set in the linker invocation (see
  54:				; makefile).
  55:				                cseg                    ; Code segment
  56:				;
  57:				; The default stack space is very small (8 deep), which would almost certainly
  58:				; cause issues, particularly with interrupts running. The initial code should
  59:				; not assume a Z80 so we can exit cleanly if this is run on something else.
  60:    0+20	0000' ED730000	                ld (bdos_sp), sp
  61:   20+10	0004' 318701  	                ld sp, app_stack_top    ; Switch to our stack space
  62:				;
  63:				; Determine CPU type.
  64:   30+17	0007' CD0000  	                call z80det             ; Detect Z80 (instead of 8080 / 8085)
  65:   47+10	000A' D21800  	                jp nc, on_z80           ; Jump if we have a Z80
  66:				;
  67:				; 8080 / 8085 detected. Print message and exit. We can't use conwms as this
  68:				; assumes a Z80.
  69:   57+10	000D' 11C003  	                ld de, no_z80_msg       ; "Z80 CPU required"
  70:   67+7	0010' 0E09    	                ld c, BDOS_PRINT_STRING ; Print String
  71:   74+17	0012' CD0500  	                call BDOS
  72:   91+10	0015' C30000  	                jp 0                    ; Warm boot
  73:				;
  74:				; Sign on.
  75:  101+10	0018' 21A203  	on_z80          ld hl, signon_msg
  76:  111+17	001B' CD0000  	                call conwms             ; Print $-terminated string to console
  77:				;
  78:				; Are we running on a ZARC system?
  79:  128+17	001E' CD0000  	                call zrcdet
  80:				; Carry set if ZARC BIOS not found.
  81:  145+4	0021' 3F      	                ccf
  82:  149+4	0022' 17      	                rla
  83:  153+7	0023' E601    	                and 1
  84:  160+13	0025' 320200  	                ld (zarc_flag), a       ; 0x01 if ZARC, zero otherwise
  85:  173+7+5	0028' 2006    	                jr nz, exam_tail
  86:				;
  87:				; Warn about limited facilites.
  88:  180+10	002A' 21D303  	                ld hl, no_zarc_msg      ; "ZARC BIOS not detected ..."
  89:  190+17	002D' CD0000  	                call conwms             ; Print $-terminated string to console
  90:				;
  91:				; Examine the command tail, looking for operands. This is stored in the default
  92:				; buffer. "The first byte at 0080H contains the length of the command tall,
  93:				; while the command tail itself begins at 0081H. The command tail is terminated
  94:				; by a byte containing a binary zero value."
  95:				; (http://www.cpm.z80.de/manuals/cpm22-m.pdf appendix H).
  96:  207+10	0030' 218100  	exam_tail       ld hl, DEF_BUFFER + 1
  97:				; No operands (yet).
  98:				; The terminator should follow.
  99:  217+17	0033' CD0000  	op_check_term   call skpspc
 100:  234+7	0036' 7E      	                ld a, (hl)
 101:  241+4	0037' A7      	                and a
 102:     -	0000'         	                ifdef DEBUG
 105:				                endif
 106:  245+7+5	0038' 2806    	                jr z, operands_ok       ; Normal behaviour
 107:				;
 108:				; Go here if we don't like the operands supplied.
 109:  252+10	003A' 210304  	op_error        ld hl, op_err_msg
 110:  262+10	003D' C3AA02  	                jp msg_exit
 111:				;
 112:				; Operand processing complete.
 113:     -	0040'         	operands_ok
 114:				;
 115:				;
 116:				; Perform validation tests. First the null string.
 117:  272+10	0040' 21AA04  	                ld hl, test_null_msg    ; "Null message test: "
 118:  282+17	0043' CD0000  	                call conwms             ; Print $-terminated string to console
 119:  299+17	0046' CD0000  	                call sh2ini             ; Initialise sha-256 state
 120:  316+10	0049' 210000  	                ld hl, 0                ; Pointer does not matter
 121:  326+10	004C' 010000  	                ld bc, 0                ; Overall message length in bytes
 122:  336+17	004F' CD0000  	                call sh2m               ; Process a message in memory
 123:				; HL - pointer to message digest (h0 to h7)
 124:  353+10	0052' 11D605  	                ld de, null_msg_hash
 125:  363+17	0055' CDE502  	                call cmp_hashes         ; Compare hashes and report errors
 126:  380+10+7	0058' D49C03  	                call nc, disp_ok        ; Display OK if it was so
 127:				;
 128:				; Test message 1
 129:  390+10	005B' 21BE04  	                ld hl, test_short_msg   ; "Short message test: "
 130:  400+17	005E' CD0000  	                call conwms             ; Print $-terminated string to console
 131:  417+17	0061' CD0000  	                call sh2ini             ; Initialise sha-256 state
 132:  434+10	0064' 21F605  	                ld hl, test1_msg        ; Point to message
 133:  444+10	0067' 010F00  	                ld bc, test1_msg_len    ; Overall message length in bytes
 134:  454+17	006A' CD0000  	                call sh2m               ; Process a message in memory
 135:				; HL - pointer to message digest (h0 to h7)
 136:  471+10	006D' 110506  	                ld de, test1_msg_hash
 137:  481+17	0070' CDE502  	                call cmp_hashes         ; Compare hashes and report errors
 138:  498+10+7	0073' D49C03  	                call nc, disp_ok        ; Display OK if it was so
 139:				;
 140:				; Test message 2. This will require three chunks, one with message text, another
 141:				; with the rest of the message text (but is just too short to contain the
 142:				; length), and the last with just the length.
 143:  508+10	0076' 21D304  	                ld hl, test_long_msg    ; "Long message test: "
 144:  518+17	0079' CD0000  	                call conwms             ; Print $-terminated string to console
 145:  535+17	007C' CD0000  	                call sh2ini             ; Initialise sha-256 state
 146:  552+10	007F' 212506  	                ld hl, test2_msg        ; Point to message
 147:  562+10	0082' 017800  	                ld bc, test2_msg_len    ; Overall message length in bytes
 148:  572+17	0085' CD0000  	                call sh2m               ; Process a message in memory
 149:				; HL - pointer to message digest (h0 to h7)
 150:  589+10	0088' 119D06  	                ld de, test2_msg_hash
 151:  599+17	008B' CDE502  	                call cmp_hashes         ; Compare hashes and report errors
 152:  616+10+7	008E' D49C03  	                call nc, disp_ok        ; Display OK if it was so
 153:				;
 154:				; Test message 3. This is just one byte shorter than the previous message. It
 155:				; will require two chunks, one with message text, another with the rest of the
 156:				; message text and the length. No chunk will contain pad bytes.
 157:  626+10	0091' 21E704  	                ld hl, test_long2_msg   ; "Long message test 2: "
 158:  636+17	0094' CD0000  	                call conwms             ; Print $-terminated string to console
 159:  653+17	0097' CD0000  	                call sh2ini             ; Initialise sha-256 state
 160:  670+10	009A' 212506  	                ld hl, test2_msg        ; Use test2 message (except last byte)
 161:  680+10	009D' 017700  	                ld bc, test3_msg_len    ; Overall message length in bytes
 162:  690+17	00A0' CD0000  	                call sh2m               ; Process a message in memory
 163:				; HL - pointer to message digest (h0 to h7)
 164:  707+10	00A3' 11BD06  	                ld de, test3_msg_hash
 165:  717+17	00A6' CDE502  	                call cmp_hashes         ; Compare hashes and report errors
 166:  734+10+7	00A9' D49C03  	                call nc, disp_ok        ; Display OK if it was so
 167:				;
 168:				; Bitcoin genesis block.
 169:  744+10	00AC' 21FD04  	                ld hl, genesis_msg      ; "Bitcoin genesis block: "
 170:  754+17	00AF' CD0000  	                call conwms             ; Print $-terminated string to console
 171:  771+17	00B2' CD0000  	                call sh2ini             ; Initialise sha-256 state
 172:  788+10	00B5' 21E106  	                ld hl, genesis          ; Point to message
 173:  798+10	00B8' 015000  	                ld bc, BH_SIZE          ; Header size
 174:  808+17	00BB' CD0000  	                call sh2m               ; Process a message in memory
 175:				; HL - pointer to message digest (h0 to h7)
 176:  825+10	00BE' 11AF00  	                ld de, bit_hash_buf     ; Hash digest buffer
 177:  835+11	00C1' D5      	                push de
 178:  846+17	00C2' CD6003  	                call copy_hash          ; Copy hash and endian convert
 179:				; Apply the second SHA-2 step, as Bitcoin uses double SHA-2.
 180:  863+17	00C5' CD0000  	                call sh2ini             ; Initialise sha-256 state
 181:  880+10	00C8' E1      	                pop hl
 182:  890+10	00C9' 012000  	                ld bc, SH2_DIGEST_BYTES ; Overall message length in bytes
 183:  900+17	00CC' CD0000  	                call sh2m               ; Process a message in memory
 184:				; HL - pointer to message digest (h0 to h7)
 185:  917+10	00CF' 113107  	                ld de, genesis_hash
 186:  927+17	00D2' CD1903  	                call bit_cmp_hashes     ; Compare Bitcoin hashes
 187:  944+10+7	00D5' D49C03  	                call nc, disp_ok        ; Display OK if it was so
 188:				;
 189:  954+10	00D8' 211505  	                ld hl, bitc_exam_msg    ; "Bitcoin example block: "
 190:  964+17	00DB' CD0000  	                call conwms             ; Print $-terminated string to console
 191:  981+17	00DE' CD0000  	                call sh2ini             ; Initialise sha-256 state
 192:  998+10	00E1' 215107  	                ld hl, bitc_example     ; Point to message
 193: 1008+10	00E4' 015000  	                ld bc, BH_SIZE          ; Header size
 194: 1018+17	00E7' CD0000  	                call sh2m               ; Process a message in memory
 195:				; HL - pointer to message digest (h0 to h7)
 196: 1035+10	00EA' 11AF00  	                ld de, bit_hash_buf     ; Hash digest buffer
 197: 1045+11	00ED' D5      	                push de
 198: 1056+17	00EE' CD6003  	                call copy_hash          ; Copy hash and endian convert
 199:				; Apply the second SHA-2 step, as Bitcoin uses double SHA-2.
 200: 1073+17	00F1' CD0000  	                call sh2ini             ; Initialise sha-256 state
 201: 1090+10	00F4' E1      	                pop hl
 202: 1100+10	00F5' 012000  	                ld bc, SH2_DIGEST_BYTES ; Overall message length in bytes
 203: 1110+17	00F8' CD0000  	                call sh2m               ; Process a message in memory
 204:				; HL - pointer to message digest (h0 to h7)
 205: 1127+10	00FB' 11A107  	                ld de, bitc_exam_hash
 206: 1137+17	00FE' CD1903  	                call bit_cmp_hashes     ; Compare Bitcoin hashes
 207: 1154+10+7	0101' D49C03  	                call nc, disp_ok        ; Display OK if it was so
 208:				;
 209:				;
 210:				; Attempt to load saved progress.
 211: 1164+14	0104' DD210300	                ld ix, fcbr
 212:				; IX - pointer to FCBR structure (FCB with record buffer). This is defined in
 213:				; cpm_files.i
 214: 1178+17	0108' CD0000  	                call finit              ; Initialise FCBR structure
 215: 1195+10	010B' 214605  	                ld hl, save_fn          ; Filename
 216: 1205+17	010E' CD0000  	                call fbfcb              ; Build the FCB.
 217: 1222+10	0111' 212D05  	                ld hl, load_msg         ; "Loading saved state "
 218: 1232+17	0114' CD0000  	                call conwms             ; Print $-terminated string to console
 219: 1249+17	0117' CD0000  	                call fdnam              ; Display CP/M filename
 220: 1266+17	011A' CD0000  	                call cwnwln             ; Write new line characters to console
 221:				;
 222: 1283+17	011D' CD0000  	                call fopen              ; Open file for reading
 223:				; Carry set on error. A generic message will have been written to the console
 224:				; if an error occurred.
 225: 1300+10	0120' DA3D01  	                jp c, load_error
 226:				;
 227: 1310+10	0123' 21CF00  	                ld hl, save_start       ; Start of saved variables
 228: 1320+10	0126' 017800  	                ld bc, save_size        ; Size
 229: 1330+17	0129' CD0000  	                call frdblk             ; Read block from file
 230:				; Carry set on error. A generic message will have been written to the console
 231:				; if an error occurred.
 232: 1347+10	012C' DA3D01  	                jp c, load_error
 233:				; We should have loaded exactly save_size bytes.
 234: 1357+10	012F' 217800  	                ld hl, save_size
 235: 1367+4	0132' A7      	                and a
 236: 1371+15	0133' ED42    	                sbc hl, bc
 237: 1386+7+5	0135' 2006    	                jr nz, load_error
 238:				;
 239: 1393+17	0137' CD9C03  	                call disp_ok            ; Print "OK"
 240: 1410+10	013A' C36B01  	                jp load_done
 241:				;
 242:				;
 243:				; Load failed.
 244: 1420+10	013D' 215105  	load_error      ld hl, load_err_msg     ; "Error reading file"
 245: 1430+17	0140' CD0000  	                call conwms             ; Print $-terminated string to console
 246:				;
 247:				; Copy the genesis block to use as the basis of our search.
 248: 1447+10	0143' 21E106  	                ld hl, genesis          ; Point to message
 249: 1457+10	0146' 11D300  	                ld de, bit_hdr_buf      ; Bitcoin header buffer
 250: 1467+10	0149' 015000  	                ld bc, BH_SIZE          ; Header size
 251: 1477+16+5	014C' EDB0    	                ldir
 252:				; Initialise nonce.
 253: 1493+10	014E' 211F01  	                ld hl, bit_hdr_buf + BH_NONCE
 254: 1503+17	0151' CD0000  	                call mclr32             ; 32-bit clear (zero)
 255:				; Reset best hash and corresponding best nonce found.
 256: 1520+10	0154' 212301  	                ld hl, best_hash
 257: 1530+7	0157' 0620    	                ld b, SH2_DIGEST_BYTES
 258: 1537+7	0159' 3EFF    	                ld a, 0xff
 259: 1544+7	015B' 77      	init_clr_hash   ld (hl), a
 260: 1551+6	015C' 23      	                inc hl
 261: 1557+8+5	015D' 10FC    	                djnz init_clr_hash
 262: 1565+10	015F' 214301  	                ld hl, best_nonce
 263: 1575+17	0162' CD0000  	                call mclr32             ; 32-bit clear (zero)
 264:				; Reset iteration counter.
 265: 1592+10	0165' 21CF00  	                ld hl, iter_count
 266: 1602+17	0168' CD0000  	                call mclr32             ;  32-bit clear (zero)
 267:				;
 268:				; Reset iteration counters.
 269: 1619+17	016B' CD0000  	load_done       call fclose             ; Close file
 270: 1636+10	016E' 210000  	                ld hl, 0
 271: 1646+16	0171' 22AD00  	                ld (iter_delta), hl     ; Iterations since last report
 272:				;
 273:				; Initialise timing (ZARC only).
 274: 1662+13	0174' 3A0200  	                ld a, (zarc_flag)       ; 0x01 if ZARC, zero otherwise
 275: 1675+4	0177' A7      	                and a
 276: 1679+7+5	0178' 2819    	                jr z, initt_done
 277:				;
 278:				; ZARC system. Reset the elapsed time.
 279: 1686+4	017A' AF      	                xor a
 280: 1690+4	017B' 47      	                ld b, a
 281: 1694+4	017C' 4F      	                ld c, a
 282: 1698+4	017D' 57      	                ld d, a
 283: 1702+4	017E' 5F      	                ld e, a
 284:				; BCDE - 32-bit time
 285: 1706+10	017F' 217800  	                ld hl, BIOS_SET_TIMER   ; Set timer
 286: 1716+17	0182' CD0000  	                call cbios              ; Call BIOS
 287:				;
 288:				; Set initial message time.
 289: 1733+10	0185' 21A900  	                ld hl, msg_time         ; Message timer (ms)
 290: 1743+10	0188' 3610    	                ld (hl), low MSG_PERIOD
 291: 1753+6	018A' 23      	                inc hl
 292: 1759+10	018B' 3627    	                ld (hl), high MSG_PERIOD
 293: 1769+6	018D' 23      	                inc hl
 294: 1775+10	018E' 3600    	                ld (hl), 0
 295: 1785+6	0190' 23      	                inc hl
 296: 1791+10	0191' 3600    	                ld (hl), 0
 297:				;
 298: 1801+17	0193' CDBD02  	initt_done      call disp_best          ; Display best nonce and hash
 299: 1818+10	0196' 214504  	                ld hl, start_msg        ; "Starting mining. Press ^C to exit."
 300: 1828+17	0199' CD0000  	                call conwms             ; Print $-terminated string to console
 301:				;
 302:				;
 303:				; Main iteration loop.
 304: 1845+17	019C' CD0000  	main_loop       call sh2ini             ; Initialise sha-256 state
 305: 1862+10	019F' 21D300  	                ld hl, bit_hdr_buf      ; Bitcoin block header buffer
 306: 1872+10	01A2' 015000  	                ld bc, BH_SIZE          ; Header size
 307: 1882+17	01A5' CD0000  	                call sh2m               ; Process a message in memory
 308:				; HL - pointer to message digest (h0 to h7)
 309: 1899+10	01A8' 11AF00  	                ld de, bit_hash_buf     ; Hash digest buffer
 310: 1909+11	01AB' D5      	                push de
 311: 1920+17	01AC' CD6003  	                call copy_hash          ; Copy hash and endian convert
 312:				; Apply the second SHA-2 step, as Bitcoin uses double SHA-2.
 313: 1937+17	01AF' CD0000  	                call sh2ini             ; Initialise sha-256 state
 314: 1954+10	01B2' E1      	                pop hl
 315: 1964+10	01B3' 012000  	                ld bc, SH2_DIGEST_BYTES ; Overall message length in bytes
 316: 1974+17	01B6' CD0000  	                call sh2m               ; Process a message in memory
 317:				; HL - pointer to message digest (h0 to h7)
 318:				;
 319:				; Assess the resulting hash. Is it smaller than the best yet? The bytes are
 320:				; to be treated as h0 - h7 in reverse order and big endian format to suit
 321:				; Bitcoin conventions.
 322: 1991+11	01B9' E5      	                push hl                 ; Save pointer to hash
 323:				; Perform a subtract, starting at the LS byte of h0.
 324: 2002+6	01BA' 23      	                inc hl
 325: 2008+6	01BB' 23      	                inc hl
 326: 2014+6	01BC' 23      	                inc hl
 327: 2020+4	01BD' EB      	                ex de, hl
 328: 2024+10	01BE' 212601  	                ld hl, best_hash + 3
 329: 2034+7	01C1' 0608    	                ld b, 8                 ; Register counter
 330: 2041+4	01C3' A7      	                and a                   ; Reset carry
 331: 2045+7	01C4' 0E04    	hcmp_reg_loop   ld c, 4
 332:				; B - register counter
 333:				; C - byte counter
 334:				; DE - pointer to calculated hash
 335:				; HL - pointer to best hash
 336: 2052+11	01C6' D5      	                push de
 337: 2063+11	01C7' E5      	                push hl
 338: 2074+7	01C8' 1A      	hcmp_byte_loop  ld a, (de)
 339: 2081+7	01C9' 9E      	                sbc (hl)
 340: 2088+6	01CA' 2B      	                dec hl
 341: 2094+6	01CB' 1B      	                dec de
 342: 2100+4	01CC' 0D      	                dec c
 343: 2104+7+5	01CD' 20F9    	                jr nz, hcmp_byte_loop
 344: 2111+10	01CF' E1      	                pop hl
 345: 2121+10	01D0' D1      	                pop de
 346:				; Next calculated hash register.
 347: 2131+6	01D1' 13      	                inc de
 348: 2137+6	01D2' 13      	                inc de
 349: 2143+6	01D3' 13      	                inc de
 350: 2149+6	01D4' 13      	                inc de
 351:				; Next best hash register.
 352: 2155+6	01D5' 23      	                inc hl
 353: 2161+6	01D6' 23      	                inc hl
 354: 2167+6	01D7' 23      	                inc hl
 355: 2173+6	01D8' 23      	                inc hl
 356: 2179+8+5	01D9' 10E9    	                djnz hcmp_reg_loop
 357:				; Compare complete.
 358: 2187+10	01DB' E1      	                pop hl                  ; Recover pointer to h0 - h7
 359: 2197+7+5	01DC' 3014    	                jr nc, next_nonce       ; Keep going if not best
 360:				;
 361:				;
 362:				; This is the best hash yet.
 363:				; HL - pointer to message digest (h0 to h7)
 364:				; Save the hash
 365: 2204+10	01DE' 112301  	                ld de, best_hash
 366: 2214+10	01E1' 015000  	                ld bc, BH_SIZE
 367: 2224+16+5	01E4' EDB0    	                ldir
 368:				; Save nonce
 369: 2240+10	01E6' 211F01  	                ld hl, bit_hdr_buf + BH_NONCE
 370: 2250+10	01E9' 114301  	                ld de, best_nonce
 371: 2260+17	01EC' CD0000  	                call mcop32             ; 32-bit copy from (hl) to (de)
 372:				;
 373: 2277+17	01EF' CDBD02  	                call disp_best          ; Display best nonce and hash
 374:				;
 375:				; Increment the nonce.
 376: 2294+10	01F2' 211F01  	next_nonce      ld hl, bit_hdr_buf + BH_NONCE
 377: 2304+17	01F5' CD0000  	                call minc32             ; 32-bit increment
 378:				;
 379:				; Update iteration counter.
 380: 2321+10	01F8' 21CF00  	                ld hl, iter_count
 381: 2331+17	01FB' CD0000  	                call minc32             ; 32-bit increment
 382: 2348+10+7	01FE' DC0000  	                call c, panic           ; Counter can't realistically overflow
 383:				;
 384:				; Update iterations since last report.
 385: 2358+16	0201' 2AAD00  	                ld hl, (iter_delta)
 386: 2374+6	0204' 23      	                inc hl
 387: 2380+4	0205' 7C      	                ld a, h
 388: 2384+4	0206' B5      	                or l
 389: 2388+7+5	0207' 2803    	                jr z, rep_delinc_dn     ; Jump if no overflow
 390: 2395+16	0209' 22AD00  	                ld (iter_delta), hl
 391:     -	020C'         	rep_delinc_dn
 392:				;
 393:				;
 394:				; Report progress every so often.
 395: 2411+13	020C' 3A0200  	                ld a, (zarc_flag)       ; 0x01 if ZARC, zero otherwise
 396: 2424+4	020F' A7      	                and a
 397: 2428+7+5	0210' 2818    	                jr z, rep_not_zarc      ; jump if not a ZARC system
 398:				;
 399:				; ZARC system. Examine time.
 400: 2435+10	0212' 217B00  	                ld hl, BIOS_GET_TIMER   ; Get timer
 401: 2445+17	0215' CD0000  	                call cbios              ; Call BIOS
 402:				; BCDE - 32-bit time in ms. Time is limited to approximately 49.7 days.
 403:				; Subtract msg_time from current time. If it doesn't carry, we should report.
 404: 2462+10	0218' 21A900  	                ld hl, msg_time         ; Message timer (ms)
 405: 2472+4	021B' 7B      	                ld a, e
 406: 2476+7	021C' 96      	                sub (hl)
 407: 2483+6	021D' 23      	                inc hl
 408: 2489+4	021E' 7A      	                ld a, d
 409: 2493+7	021F' 9E      	                sbc (hl)
 410: 2500+6	0220' 23      	                inc hl
 411: 2506+4	0221' 79      	                ld a, c
 412: 2510+7	0222' 9E      	                sbc (hl)
 413: 2517+6	0223' 23      	                inc hl
 414: 2523+4	0224' 78      	                ld a, b
 415: 2527+7	0225' 9E      	                sbc (hl)
 416: 2534+7+5	0226' 3009    	                jr nc, rep_start        ; Jump if time to report
 417: 2541+12	0228' 1841    	                jr rep_done
 418:				;
 419:				; Not a ZARC system. Report every so many iterations.
 420: 2553+13	022A' 3ACF00  	rep_not_zarc    ld a, (iter_count)      ; Fetch LS byte of counter
 421: 2566+7	022D' E61F    	                and MSG_REP_MASK
 422: 2573+7+5	022F' 203A    	                jr nz, rep_done
 423:				;
 424: 2580+10	0231' 216A04  	rep_start       ld hl, iter_msg         ; CR, "Iteration: "
 425: 2590+17	0234' CD0000  	                call conwms             ; Print $-terminated string to console
 426: 2607+10	0237' 21CF00  	                ld hl, iter_count
 427: 2617+7	023A' 4E      	                ld c, (hl)
 428: 2624+6	023B' 23      	                inc hl
 429: 2630+7	023C' 46      	                ld b, (hl)
 430: 2637+6	023D' 23      	                inc hl
 431: 2643+7	023E' 5E      	                ld e, (hl)
 432: 2650+6	023F' 23      	                inc hl
 433: 2656+7	0240' 56      	                ld d, (hl)
 434: 2663+4	0241' 60      	                ld h, b
 435: 2667+4	0242' 69      	                ld l, c
 436: 2671+17	0243' CD0000  	                call cwpdlo             ; Print DEHL in decimal
 437:				;
 438: 2688+10	0246' 217704  	                ld hl, delta_msg        ; ", delta: "
 439: 2698+17	0249' CD0000  	                call conwms             ; Print $-terminated string to console
 440: 2715+10	024C' 21AD00  	                ld hl, iter_delta
 441: 2725+7	024F' 5E      	                ld e, (hl)
 442: 2732+6	0250' 23      	                inc hl
 443: 2738+7	0251' 56      	                ld d, (hl)
 444: 2745+4	0252' EB      	                ex de, hl
 445: 2749+17	0253' CD0000  	                call cwpdwd             ; Print HL in decimal
 446:				; Leave the cursor at the end of the line so we can print over it next time.
 447:				;
 448:				; Reset iteration delta counter.
 449: 2766+10	0256' 210000  	                ld hl, 0
 450: 2776+16	0259' 22AD00  	                ld (iter_delta), hl     ; Iterations since last report
 451:				;
 452:				; Update the time if we are on ZARC.
 453: 2792+13	025C' 3A0200  	                ld a, (zarc_flag)       ; 0x01 if ZARC, zero otherwise
 454: 2805+4	025F' A7      	                and a
 455: 2809+7+5	0260' 2809    	                jr z, rep_done          ; jump if not a ZARC system
 456:				;
 457:				; Calculate time for next report.
 458: 2816+10	0262' 21A900  	                ld hl, msg_time         ; Message timer (ms)
 459: 2826+10	0265' 11DD06  	                ld de, msg_per_const
 460: 2836+17	0268' CD0000  	                call madd32             ; 32-bit add (hl) <- (hl) + (de)
 461:				;
 462:				; Exit unless break detected.
 463: 2853+17	026B' CD0000  	rep_done        call const              ; Fetch console input status
 464: 2870+4	026E' A7      	                and a
 465: 2874+7+5	026F' 280A    	                jr z, ml_no_break       ; Jump if no character received
 466:				; The BIOS is used for console I/O as the corresponding BDOS function echoes
 467:				; the character to the display.
 468: 2881+17	0271' CD0000  	                call conrch             ; Read character from the console
 469:				; Exit if ^C pressed.
 470: 2898+10	0274' 211A04  	                ld hl, break_msg        ; "Exiting due to ^C"
 471: 2908+7	0277' FE03    	                cp BREAK_CHAR
 472: 2915+7+5	0279' 2803    	                jr z, break_det         ; Exit on break
 473:				;
 474: 2922+10	027B' C39C01  	ml_no_break     jp main_loop            ; Do another iteration
 475:				;
 476:				;
 477:				; Break detected. Attempt to save state. The fcbr is reused.
 478: 2932+14	027E' DD210300	break_det       ld ix, fcbr             ; Ensure pointer is still valid
 479:				; IX - pointer to FCBR structure (FCB with record buffer). This is defined in
 480:				; cpm_files.i
 481: 2946+17	0282' CD0000  	                call finit              ; Re-initialise FCBR structure
 482: 2963+10	0285' 214605  	                ld hl, save_fn          ; Filename
 483: 2973+17	0288' CD0000  	                call fbfcb              ; Build the FCB.
 484: 2990+10	028B' 218B05  	                ld hl, save_msg         ; "Saving state "
 485: 3000+17	028E' CD0000  	                call conwms             ; Print $-terminated string to console
 486: 3017+17	0291' CD0000  	                call fdnam              ; Display CP/M filename
 487: 3034+17	0294' CD0000  	                call cwnwln             ; Write new line characters to console
 488:				;
 489: 3051+17	0297' CD0000  	                call fmake              ; Create new file and report errors
 490:				; A - BDOS error code if carry = 1
 491:				; Carry flag is set if BDOS reported an error.
 492: 3068+7+5	029A' 380B    	                jr c, save_error        ; Give up if can't make
 493:				;
 494:				; Save the variables.
 495: 3075+10	029C' 21CF00  	                ld hl, save_start       ; Start of saved variables
 496: 3085+10	029F' 017800  	                ld bc, save_size        ; Size
 497: 3095+17	02A2' CD0000  	                call fwrblk             ; Write block to file
 498:				; Carry set on error. A generic message will have been written to the console
 499:				; if an error occurred.
 500: 3112+7+5	02A5' 3006    	                jr nc, exit             ; Exit if no error
 501:				;
 502: 3119+10	02A7' 21A305  	save_error      ld hl, save_err_msg     ; "Error saving state"
 503:				;
 504:				;
 505:				; Print message pointed to by HL, then exit.
 506: 3129+17	02AA' CD0000  	msg_exit        call conwms             ; Print $-terminated string to console
 507:				;
 508:				; Return to CP/M.
 509: 3146+17	02AD' CD0000  	exit            call fclose             ; Close file
 510: 3163+10	02B0' 213004  	                ld hl, exit_msg         ; "Returning to CP/M."
 511: 3173+17	02B3' CD0000  	                call conwms             ; Print $-terminated string to console
 512:				;
 513: 3190+20	02B6' ED7B0000	                ld sp, (bdos_sp)
 514:				; For this application a warm boot is required as we may have overwritten the
 515:				; CCP.
 516:				;                ret                     ; Return to BDOS
 517: 3210+10	02BA' C30000  	                jp 0                    ; Warm boot
 518:				;
 519:				;
 520:				;
 521:				; ***************
 522:				; * Subroutines *
 523:				; ***************
 524:				;
 525:				;
 526:				; Display nonce and hash.
 527: 3220+11	02BD' C5      	disp_best       push bc
 528: 3231+11	02BE' D5      	                push de
 529: 3242+11	02BF' E5      	                push hl
 530:				;
 531: 3253+10	02C0' 21B905  	                ld hl, best_msg         ; "Best nonce / hash found:"
 532: 3263+17	02C3' CD0000  	                call conwms             ; Print $-terminated string to console
 533: 3280+10	02C6' 214301  	                ld hl, best_nonce
 534: 3290+7	02C9' 4E      	                ld c, (hl)
 535: 3297+6	02CA' 23      	                inc hl
 536: 3303+7	02CB' 46      	                ld b, (hl)
 537: 3310+6	02CC' 23      	                inc hl
 538: 3316+7	02CD' 5E      	                ld e, (hl)
 539: 3323+6	02CE' 23      	                inc hl
 540: 3329+7	02CF' 56      	                ld d, (hl)
 541: 3336+4	02D0' 60      	                ld h, b
 542: 3340+4	02D1' 69      	                ld l, c
 543: 3344+17	02D2' CD0000  	                call cwpdlo             ; Print DEHL in decimal
 544:				;
 545: 3361+17	02D5' CD0000  	                call cwpspc             ; Print a space
 546: 3378+10	02D8' 212301  	                ld hl, best_hash
 547: 3388+17	02DB' CD7C03  	                call bit_disp_hash      ; Display hash value in Bitcoin format
 548: 3405+17	02DE' CD0000  	                call cwnwln             ; Write new line characters to console
 549:				;
 550: 3422+10	02E1' E1      	                pop hl
 551: 3432+10	02E2' D1      	                pop de
 552: 3442+10	02E3' C1      	                pop bc
 553: 3452+10	02E4' C9      	                ret
 554:				;
 555:				;
 556:				; Compare hashes and report any errors. Call with:
 557:				; HL - pointer to hash (message digest [h0 to h7])
 558:				; DE - pointer to expected hash value
 559:				; Returns with:
 560:				; Carry flag - set on mismatch, clear otherwise
 561: 3462+11	02E5' C5      	cmp_hashes      push bc
 562:				;
 563: 3473+11	02E6' E5      	                push hl
 564: 3484+11	02E7' D5      	                push de
 565:				;
 566: 3495+10	02E8' 012000  	                ld bc, 8 * 4            ; Compare 8 32-bit words
 567: 3505+7	02EB' 1A      	ch_loop         ld a, (de)
 568: 3512+6	02EC' 13      	                inc de
 569: 3518+16	02ED' EDA1    	                cpi                     ; cp (hl), inc hl, dec bc
 570: 3534+7+5	02EF' 2008    	                jr nz, ch_miss
 571: 3541+10	02F1' EAEB02  	                jp pe, ch_loop
 572:				; Hashes match!
 573: 3551+10	02F4' D1      	                pop de                  ; Discard pointers
 574: 3561+10	02F5' E1      	                pop hl
 575: 3571+4	02F6' A7      	                and a                   ; Flag success
 576: 3575+12	02F7' 181E    	                jr ch_exit
 577:				;
 578: 3587+17	02F9' CD0000  	ch_miss         call cwnwln             ; Write new line characters to console
 579: 3604+10	02FC' 218104  	                ld hl, hc_mismatch_msg  ; "Hash mismatch. Expected:"
 580: 3614+17	02FF' CD0000  	                call conwms             ; Print $-terminated string to console
 581: 3631+10	0302' E1      	                pop hl                  ; Recover pointer to expected hash
 582: 3641+17	0303' CD0000  	                call sh2dh              ; Display hash value
 583: 3658+17	0306' CD0000  	                call cwnwln             ; Write new line characters to console
 584: 3675+10	0309' 219C04  	                ld hl, hc_found_msg     ; "found:"
 585: 3685+17	030C' CD0000  	                call conwms             ; Print $-terminated string to console
 586: 3702+10	030F' E1      	                pop hl                  ; Recover pointer to calculated hash
 587: 3712+17	0310' CD0000  	                call sh2dh              ; Display hash value
 588: 3729+17	0313' CD0000  	                call cwnwln             ; Write new line characters to console
 589: 3746+4	0316' 37      	                scf                     ; Flag error
 590:				;
 591: 3750+10	0317' C1      	ch_exit         pop bc
 592: 3760+10	0318' C9      	                ret
 593:				;
 594:				;
 595:				; As cmp_hashes but the hash is reversed as is the convention for Bitcoin.
 596:				; Call with:
 597:				; HL - pointer to hash (message digest [h0 to h7])
 598:				; DE - pointer to expected hash value in Bitcoin format
 599:				; Returns with:
 600:				; Carry flag - set on mismatch, clear otherwise
 601: 3770+11	0319' C5      	bit_cmp_hashes  push bc
 602:				;
 603: 3781+11	031A' E5      	                push hl                 ; Save hash pointers
 604: 3792+11	031B' D5      	                push de
 605:				;
 606:				; Advance hash address to last register (h7)
 607: 3803+10	031C' 011C00  	                ld bc, 7 * 4
 608: 3813+11	031F' 09      	                add hl, bc
 609:				;
 610: 3824+7	0320' 0E08    	                ld c, 8                 ; Register counter
 611: 3831+7	0322' 0604    	bch_reg_loop    ld b, 4                 ; Byte counter
 612: 3838+7	0324' 1A      	bch_byte_loop   ld a, (de)
 613: 3845+7	0325' BE      	                cp (hl)
 614: 3852+7+5	0326' 2012    	                jr nz, bch_miss
 615: 3859+6	0328' 13      	                inc de
 616: 3865+6	0329' 23      	                inc hl
 617: 3871+8+5	032A' 10F8    	                djnz bch_byte_loop
 618:				; Register complete. Make HL point to the MS byte of the previous register.
 619: 3879+11	032C' C5      	                push bc
 620: 3890+10	032D' 01F8FF  	                ld bc, -8
 621: 3900+11	0330' 09      	                add hl, bc
 622: 3911+10	0331' C1      	                pop bc
 623: 3921+4	0332' 0D      	                dec c
 624: 3925+7+5	0333' 20ED    	                jr nz, bch_reg_loop
 625:				; Hashes match!
 626: 3932+10	0335' D1      	                pop de                  ; Discard pointers
 627: 3942+10	0336' E1      	                pop hl
 628: 3952+4	0337' A7      	                and a                   ; Flag success
 629: 3956+12	0338' 1824    	                jr bch_exit
 630:				;
 631: 3968+17	033A' CD0000  	bch_miss        call cwnwln             ; Write new line characters to console
 632: 3985+10	033D' 218104  	                ld hl, hc_mismatch_msg  ; "Hash mismatch. Expected:"
 633: 3995+17	0340' CD0000  	                call conwms             ; Print $-terminated string to console
 634: 4012+10	0343' E1      	                pop hl                  ; Recover pointer to expected hash
 635:				; Neither sh2dh or bit_disp_hash will display as expected because the value is
 636:				; reversed as well as being in big-endian order.
 637: 4022+7	0344' 0620    	                ld b, 8 * 4
 638: 4029+7	0346' 7E      	bch_disp_loop   ld a, (hl)
 639: 4036+17	0347' CD0000  	                call cwphby             ; Print A in hexadecimal
 640: 4053+6	034A' 23      	                inc hl
 641: 4059+8+5	034B' 10F9    	                djnz bch_disp_loop
 642: 4067+17	034D' CD0000  	                call cwnwln             ; Write new line characters to console
 643: 4084+10	0350' 219C04  	                ld hl, hc_found_msg     ; "found:"
 644: 4094+17	0353' CD0000  	                call conwms             ; Print $-terminated string to console
 645: 4111+10	0356' E1      	                pop hl                  ; Recover pointer to calculated hash
 646: 4121+17	0357' CD7C03  	                call bit_disp_hash      ; Display hash value in Bitcoin format
 647: 4138+17	035A' CD0000  	                call cwnwln             ; Write new line characters to console
 648: 4155+4	035D' 37      	                scf                     ; Flag error
 649:				;
 650: 4159+10	035E' C1      	bch_exit        pop bc
 651: 4169+10	035F' C9      	                ret
 652:				;
 653:				;
 654:				; Copy h0 to h7 (the hash digest) to a buffer, performing an endian swap as
 655:				; we go.
 656:				; DE - pointer to buffer
 657:				; HL - pointer to message digest (h0 to h7)
 658: 4179+11	0360' C5      	copy_hash       push bc
 659:				;
 660: 4190+7	0361' 0608    	                ld b, 8                 ; Register counter
 661: 4197+6	0363' 13      	ch_reg_loop     inc de                  ; Advance to last (MS) byte
 662: 4203+6	0364' 13      	                inc de
 663: 4209+6	0365' 13      	                inc de
 664: 4215+11	0366' D5      	                push de
 665: 4226+7	0367' 7E      	                ld a, (hl)
 666: 4233+7	0368' 12      	                ld (de), a
 667: 4240+6	0369' 23      	                inc hl
 668: 4246+6	036A' 1B      	                dec de
 669: 4252+7	036B' 7E      	                ld a, (hl)
 670: 4259+7	036C' 12      	                ld (de), a
 671: 4266+6	036D' 23      	                inc hl
 672: 4272+6	036E' 1B      	                dec de
 673: 4278+7	036F' 7E      	                ld a, (hl)
 674: 4285+7	0370' 12      	                ld (de), a
 675: 4292+6	0371' 23      	                inc hl
 676: 4298+6	0372' 1B      	                dec de
 677: 4304+7	0373' 7E      	                ld a, (hl)
 678: 4311+7	0374' 12      	                ld (de), a
 679: 4318+6	0375' 23      	                inc hl
 680: 4324+10	0376' D1      	                pop de
 681: 4334+6	0377' 13      	                inc de                  ; Advance to next longword
 682: 4340+8+5	0378' 10E9    	                djnz ch_reg_loop        ; Loop for all registers
 683:				;
 684: 4348+10	037A' C1      	                pop bc
 685: 4358+10	037B' C9      	                ret
 686:				;
 687:				;
 688:				; Display hash value. This works the same way as sh2dh in sha-256.z80, but in
 689:				; this case the bytes are displayed in reverse order to suit Bitcoin
 690:				; conventions.
 691:				; Call with:
 692:				; HL - pointer to hash (message digest [h0 to h7])
 693: 4368+11	037C' C5      	bit_disp_hash   push bc
 694:				;
 695:				; Advance address to last register (h7)
 696: 4379+10	037D' 011C00  	                ld bc, 7 * 4
 697: 4389+11	0380' 09      	                add hl, bc
 698: 4400+7	0381' 0608    	                ld b, 8                 ; Register counter
 699: 4407+11	0383' E5      	bdh_reg_loop    push hl
 700: 4418+17	0384' CD9003  	                call disp_hex32_be      ; Display big endian value
 701: 4435+10	0387' E1      	                pop hl
 702: 4445+6	0388' 2B      	                dec hl                  ; Point to next word
 703: 4451+6	0389' 2B      	                dec hl
 704: 4457+6	038A' 2B      	                dec hl
 705: 4463+6	038B' 2B      	                dec hl
 706: 4469+8+5	038C' 10F5    	                djnz bdh_reg_loop
 707:				;
 708: 4477+10	038E' C1      	                pop bc
 709: 4487+10	038F' C9      	                ret
 710:				;
 711:				;
 712:				; Display 32-bit big-endian hexadecimal value in memory. Call with:
 713:				; HL - pointer to value
 714: 4497+11	0390' C5      	disp_hex32_be   push bc
 715:				;
 716: 4508+7	0391' 0604    	                ld b, 4                 ; Byte counter
 717: 4515+7	0393' 7E      	dhb32_loop      ld a, (hl)
 718: 4522+17	0394' CD0000  	                call cwphby             ; Print A in hexadecimal
 719: 4539+6	0397' 23      	                inc hl
 720: 4545+8+5	0398' 10F9    	                djnz dhb32_loop
 721:				;
 722: 4553+10	039A' C1      	                pop bc
 723: 4563+10	039B' C9      	                ret
 724:				;
 725:				; Display OK message.
 726: 4573+10	039C' 21A504  	disp_ok         ld hl, ok_msg           ; "OK"
 727: 4583+10	039F' C30000  	                jp conwms               ; Print $-terminated string to console
 728:				;
 729:				;
 730:				;
 731:				; *************
 732:				; * Constants *
 733:				; *************
 734:				;
 735:				;
 736:     -	03A2' 2A2A2A20	signon_msg      byte "*** Bitcoin Mining V1.0 ***", 0x0d, 0x0a, "$"
	              42697463
	              6F696E20
	              4D696E69
	              6E672056
	              312E3020
	              2A2A2A0D
	              0A24
 737:     -	03C0' 5A383020	no_z80_msg      byte "Z80 CPU required", 0x0d, 0x0a, "$"
	              43505520
	              72657175
	              69726564
	              0D0A24
 738:     -	03D3' 5A415243	no_zarc_msg     byte "ZARC BIOS not detected. Timing not available."
	              2042494F
	              53206E6F
	              74206465
	              74656374
	              65642E20
	              54696D69
	              6E67206E
	              6F742061
	              7661696C
	              61626C65
	              2E
 739:     -	0400' 0D0A24  	                byte 0x0d, 0x0a, "$"
 740:     -	0403' 556E6578	op_err_msg      byte "Unexpected operand(s).$"
	              70656374
	              6564206F
	              70657261
	              6E642873
	              292E24
 741:     -	041A' 0D0A4578	break_msg       byte 0x0d, 0x0a, "Exiting due to ^C", 0x0d, 0x0a, "$"
	              6974696E
	              67206475
	              6520746F
	              205E430D
	              0A24
 742:     -	0430' 52657475	exit_msg        byte "Returning to CP/M.", 0x0d, 0x0a, "$"
	              726E696E
	              6720746F
	              2043502F
	              4D2E0D0A
	              24
 743:     -	0445' 53746172	start_msg       byte "Starting mining. Press ^C to exit.", 0x0d, 0x0a, "$"
	              74696E67
	              206D696E
	              696E672E
	              20507265
	              7373205E
	              4320746F
	              20657869
	              742E0D0A
	              24
 744:     -	046A' 0D497465	iter_msg        byte 0x0d, "Iteration: $"
	              72617469
	              6F6E3A20
	              24
 745:     -	0477' 2C206465	delta_msg       byte ", delta: $"
	              6C74613A
	              2024
 746:     -	0481' 48617368	hc_mismatch_msg byte "Hash mismatch. Expected:", 0x0d, 0x0a, "$"
	              206D6973
	              6D617463
	              682E2045
	              78706563
	              7465643A
	              0D0A24
 747:     -	049C' 666F756E	hc_found_msg    byte "found:", 0x0d, 0x0a, "$"
	              643A0D0A
	              24
 748:     -	04A5' 4F4B0D0A	ok_msg          byte "OK", 0x0d, 0x0a, "$"
	              24
 749:     -	04AA' 4E756C6C	test_null_msg   byte "Null message test: $"
	              206D6573
	              73616765
	              20746573
	              743A2024
 750:     -	04BE' 53686F72	test_short_msg  byte "Short message test: $"
	              74206D65
	              73736167
	              65207465
	              73743A20
	              24
 751:     -	04D3' 4C6F6E67	test_long_msg   byte "Long message test: $"
	              206D6573
	              73616765
	              20746573
	              743A2024
 752:     -	04E7' 4C6F6E67	test_long2_msg  byte "Long message test 2: $"
	              206D6573
	              73616765
	              20746573
	              7420323A
	              2024
 753:     -	04FD' 42697463	genesis_msg     byte "Bitcoin genesis block: $"
	              6F696E20
	              67656E65
	              73697320
	              626C6F63
	              6B3A2024
 754:     -	0515' 42697463	bitc_exam_msg   byte "Bitcoin example block: $"
	              6F696E20
	              6578616D
	              706C6520
	              626C6F63
	              6B3A2024
 755:     -	052D' 4C6F6164	load_msg        byte "Loading state from file $"
	              696E6720
	              73746174
	              65206672
	              6F6D2066
	              696C6520
	              24
 756:     -	0546' 42495443	save_fn         byte "BITCOIN SAV"
	              4F494E20
	              534156
 757:     -	0551' 4572726F	load_err_msg    byte "Error reading saved state. "
	              72207265
	              6164696E
	              67207361
	              76656420
	              73746174
	              652E20
 758:     -	056C' 5573696E	                byte "Using bitcoin genesis block.", 0x0d, 0x0a, "$"
	              67206269
	              74636F69
	              6E206765
	              6E657369
	              7320626C
	              6F636B2E
	              0D0A24
 759:     -	058B' 0D0A5361	save_msg        byte 0x0d, 0x0a, "Saving state to file $"
	              76696E67
	              20737461
	              74652074
	              6F206669
	              6C652024
 760:     -	05A3' 4572726F	save_err_msg    byte "Error saving state.", 0x0d, 0x0a, "$"
	              72207361
	              76696E67
	              20737461
	              74652E0D
	              0A24
 761:     -	05B9' 0D0A4265	best_msg        byte 0x0d, 0x0a, "Best nonce / hash found:", 0x0d, 0x0a, "$"
	              7374206E
	              6F6E6365
	              202F2068
	              61736820
	              666F756E
	              643A0D0A
	              24
 762:				;
 763:				;
 764:				; Null message test hash.
 765:				; Should be 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
 766:     -	05D6' 42C4B0E3	null_msg_hash   dword 0xe3b0c442, 0x98fc1c14, 0x9afbf4c8, 0x996fb924
	              141CFC98
	              C8F4FB9A
	              24B96F99
 767:     -	05E6' E441AE27	                dword 0x27ae41e4, 0x649b934c, 0xa495991b, 0x7852b855
	              4C939B64
	              1B9995A4
	              55B85278
 768:				;
 769:				; Short message test hash.
 770:				; Should be 0x60e76ce856c4bd873cc66e424d214ced480d77c34091aad5eb190b2cd9668bd8
 771:				; according to https://www.movable-type.co.uk/scripts/sha256.html
 772:     -	05F6' 41207465	test1_msg       byte "A test message."
	              7374206D
	              65737361
	              67652E
 773:     -	000F'         	test1_msg_len   equ $ - test1_msg
 774:     -	0605' E86CE760	test1_msg_hash  dword 0x60e76ce8, 0x56c4bd87, 0x3cc66e42, 0x4d214ced
	              87BDC456
	              426EC63C
	              ED4C214D
 775:     -	0615' C3770D48	                dword 0x480d77c3, 0x4091aad5, 0xeb190b2c, 0xd9668bd8
	              D5AA9140
	              2C0B19EB
	              D88B66D9
 776:				;
 777:				; Multi-chunk message test hash (32 bytes / line).
 778:				; Should be 0x6dcec3724b30827de24fb9a3c2ce966af5ee167d60a6d1f6751131189a4bff46
 779:				; according to https://www.movable-type.co.uk/scripts/sha256.html
 780:     -	0625' 4C6F7265	test2_msg       byte "Lorem ipsum dolor sit amet, cons"
	              6D206970
	              73756D20
	              646F6C6F
	              72207369
	              7420616D
	              65742C20
	              636F6E73
 781:     -	0645' 65637465	                byte "ectetur adipiscing elit, sed do "
	              74757220
	              61646970
	              69736369
	              6E672065
	              6C69742C
	              20736564
	              20646F20
 782:     -	0665' 65697573	                byte "eiusmod tempor incididunt ut lab"
	              6D6F6420
	              74656D70
	              6F722069
	              6E636964
	              6964756E
	              74207574
	              206C6162
 783:     -	0685' 6F726520	                byte "ore et dolore magna.    "
	              65742064
	              6F6C6F72
	              65206D61
	              676E612E
	              20202020
 784:     -	0078'         	test2_msg_len   equ $ - test2_msg
 785:     -	069D' 72C3CE6D	test2_msg_hash  dword 0x6dcec372, 0x4b30827d, 0xe24fb9a3, 0xc2ce966a
	              7D82304B
	              A3B94FE2
	              6A96CEC2
 786:     -	06AD' 7D16EEF5	                dword 0xf5ee167d, 0x60a6d1f6, 0x75113118, 0x9a4bff46
	              F6D1A660
	              18311175
	              46FF4B9A
 787:				; Test message as one line:
 788:				; Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna.    
 789:				;
 790:				; test3 uses test2 text, but is just one character shorter.
 791:				; Should be 0x0c6b0d223dd57168016f9b91749df4d83954a5ba6232b5060746e9e6b7e6b527
 792:				; according to https://www.movable-type.co.uk/scripts/sha256.html
 793:     -	0077'         	test3_msg_len   equ test2_msg_len - 1
 794:     -	06BD' 220D6B0C	test3_msg_hash  dword 0x0c6b0d22, 0x3dd57168, 0x016f9b91, 0x749df4d8
	              6871D53D
	              919B6F01
	              D8F49D74
 795:     -	06CD' BAA55439	                dword 0x3954a5ba, 0x6232b506, 0x0746e9e6, 0xb7e6b527
	              06B53262
	              E6E94607
	              27B5E6B7
 796:				; Test message as one line:
 797:				; Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna.   
 798:				;
 799:				; Time between messages in ms as a 32-bit integer.
 800:     -	06DD' 10270000	msg_per_const   dword MSG_PERIOD
 801:				;
 802:				; Raw hex version of the Genesis block (header only).
 803:     -	06E1' 01000000	genesis         byte 0x01, 0x00, 0x00, 0x00         ; Version
 804:				; Previous block hash
 805:     -	06E5' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 806:     -	06ED' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 807:     -	06F5' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 808:     -	06FD' 00000000	                byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 809:				; Merkle root
 810:     -	0705' 3BA3EDFD	                byte 0x3B, 0xA3, 0xED, 0xFD, 0x7A, 0x7B, 0x12, 0xB2
	              7A7B12B2
 811:     -	070D' 7AC72C3E	                byte 0x7A, 0xC7, 0x2C, 0x3E, 0x67, 0x76, 0x8F, 0x61
	              67768F61
 812:     -	0715' 7FC81BC3	                byte 0x7F, 0xC8, 0x1B, 0xC3, 0x88, 0x8A, 0x51, 0x32
	              888A5132
 813:     -	071D' 3A9FB8AA	                byte 0x3A, 0x9F, 0xB8, 0xAA, 0x4B, 0x1E, 0x5E, 0x4A
	              4B1E5E4A
 814:     -	0725' 29AB5F49	                byte 0x29, 0xAB, 0x5F, 0x49         ; Timestamp
 815:     -	0729' FFFF001D	                byte 0xFF, 0xFF, 0x00, 0x1D         ; Difficulty
 816:     -	072D' 1DAC2B7C	                byte 0x1D, 0xAC, 0x2B, 0x7C         ; Nonce
 817:				; End of header
 818:     -	0001'         	                assert ($ - genesis) = BH_SIZE
 819:				; Corresponding hash (in Bitcoin reversed format).
 820:     -	0731' 00000000	genesis_hash    byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xd6, 0x68
	              0019D668
 821:     -	0739' 9C085AE1	                byte 0x9c, 0x08, 0x5a, 0xe1, 0x65, 0x83, 0x1e, 0x93
	              65831E93
 822:     -	0741' 4FF763AE	                byte 0x4f, 0xf7, 0x63, 0xae, 0x46, 0xa2, 0xa6, 0xc1
	              46A2A6C1
 823:     -	0749' 72B3F1B6	                byte 0x72, 0xb3, 0xf1, 0xb6, 0x0a, 0x8c, 0xe2, 0x6f
	              0A8CE26F
 824:				;
 825:				; Bitcoin header example from:
 826:				; http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html
 827:				; Looking it up here:
 828:				; https://api.blockchair.com/bitcoin/raw/block/286819
 829:     -	0751' 02000000	bitc_example    byte 0x02, 0x00, 0x00, 0x00         ; Version
 830:				; Previous block hash (reversed), as in raw hex dump
 831:     -	0755' 17975B97	                byte 0x17, 0x97, 0x5b, 0x97, 0xc1, 0x8e, 0xd1, 0xf7
	              C18ED1F7
 832:     -	075D' E255ADF2	                byte 0xe2, 0x55, 0xad, 0xf2, 0x97, 0x59, 0x9b, 0x55
	              97599B55
 833:     -	0765' 330EDAB8	                byte 0x33, 0x0e, 0xda, 0xb8, 0x78, 0x03, 0xc8, 0x17
	              7803C817
 834:     -	076D' 01000000	                byte 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 835:				; Merkle root (reversed), as in raw hex dump
 836:     -	0775' 8A97295A	                byte 0x8a, 0x97, 0x29, 0x5a, 0x27, 0x47, 0xb4, 0xf1
	              2747B4F1
 837:     -	077D' A0B3948D	                byte 0xa0, 0xb3, 0x94, 0x8d, 0xf3, 0x99, 0x03, 0x44
	              F3990344
 838:     -	0785' C0E19FA6	                byte 0xc0, 0xe1, 0x9f, 0xa6, 0xb2, 0xb9, 0x2b, 0x3a
	              B2B92B3A
 839:     -	078D' 19C8E6BA	                byte 0x19, 0xc8, 0xe6, 0xba, 0xdc, 0x14, 0x17, 0x87
	              DC141787
 840:     -	0795' 358B0553	                byte 0x35, 0x8b, 0x05, 0x53         ; Timestamp
 841:     -	0799' 535F0119	                byte 0x53, 0x5f, 0x01, 0x19         ; Difficulty
 842:     -	079D' 48750833	                byte 0x48, 0x75, 0x08, 0x33         ; Nonce
 843:				; End of header
 844:     -	0001'         	                assert ($ - bitc_example) = BH_SIZE
 845:				; Corresponding hash (in Bitcoin reversed format).
 846:     -	07A1' 00000000	bitc_exam_hash  byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	              00000000
 847:     -	07A9' E067A478	                byte 0xe0, 0x67, 0xa4, 0x78, 0x02, 0x4a, 0xdd, 0xfe
	              024ADDFE
 848:     -	07B1' CDC93628	                byte 0xcd, 0xc9, 0x36, 0x28, 0x97, 0x8a, 0xa5, 0x2d
	              978AA52D
 849:     -	07B9' 91FABD42	                byte 0x91, 0xfa, 0xbd, 0x42, 0x92, 0x98, 0x2a, 0x50
	              92982A50
 850:				;
 851:				;
 852:				;
 853:				; *************
 854:				; * Variables *
 855:				; *************
 856:				;
 857:				;
 858:				; Note: linker "-c" option is used, so no data is initialised here.
 859:				                dseg                ; Data segment
 860:				;
 861:     -	0000"         	bdos_sp         defs 2              ; BDOS's stack pointer
 862:     -	0002"         	zarc_flag       defs 1              ; Non-zero if on a ZARC system
 863:     -	0003"         	fcbr            defs FCBR_SIZE      ; FCB and record buffer structure
 864:     -	00A9"         	msg_time        defs 4              ; Message timer (ms)
 865:     -	00AD"         	iter_delta      defs 2              ; Iterations since last report
 866:     -	00AF"         	bit_hash_buf    defs SH2_DIGEST_BYTES   ; Space for hash digest
 867:				;
 868:     -	00CF"         	save_start                          ; Start of saved variables
 869:     -	00CF"         	iter_count      defs 4              ; Iteration counter
 870:     -	00D3"         	bit_hdr_buf     defs BH_SIZE        ; Bitcoin block header buffer
 871:     -	0123"         	best_hash       defs SH2_DIGEST_BYTES   ; Smallest hash found
 872:     -	0143"         	best_nonce      defs 4              ; Nonce corresponding to above
 873:     -	0078"         	save_size       equ $ - save_start
 874:				;
 875:     -	0147"         	                defs STACK_SIZE     ; Stack space
 876:     -	0187"         	app_stack_top
 877:				;
 878:     -	0187"         	                end



Statistics:

     4	passes
     0	jr promotions
   446	symbols
  1985	bytes

   195	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BH_DIFFICULTY  =48        72
BH_MERKLE      =24        36
BH_NONCE       =4C        76
BH_PREV_HASH   =04        4
BH_SIZE        =50        80
BH_TIME_STAMP  =44        68
BH_VER         =00        0
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
BREAK_CHAR     =03        3
CCP_START      =D600      54784
CDISK          =04        4
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCBR_CONTENTS  =25        37
FCBR_FCB       =00        0
FCBR_FLAGS     =24        36
FCBR_FL_DIRTY_BIT=01        1
FCBR_FL_DIRTY_MASK=02        2
FCBR_FL_OPEN_BIT=00        0
FCBR_FL_OPEN_MASK=01        1
FCBR_RBUFF     =26        38
FCBR_SIZE      =A6        166
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MMAP_CPM_PAGES =04        4
MSG_PERIOD     =2710      10000
MSG_REP_MASK   =1F        31
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
SH2_CHUNK_BITS = 200      512
SH2_CHUNK_BYTES=40        64
SH2_CHUNK_LONGS=10        16
SH2_DIGEST_BITS= 100      256
SH2_DIGEST_BYTES=20        32
STACK_SIZE     =40        64
TPA_START      = 100      256
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
app_stack_top    187"     391
bch_byte_loop    324'     804
bch_disp_loop    346'     838
bch_exit         35E'     862
bch_miss         33A'     826
bch_reg_loop     322'     802
bdh_reg_loop     383'     899
bdos_sp         00"       0
best_hash        123"     291
best_msg         5B9'     1465
best_nonce       143"     323
bit_cmp_hashes   319'     793
bit_disp_hash    37C'     892
bit_hash_buf    AF"       175
bit_hdr_buf     D3"       211
bitc_exam_hash   7A1'     1953
bitc_exam_msg    515'     1301
bitc_example     751'     1873
break_det        27E'     638
break_msg        41A'     1050
cbdos           00        0 (extern)
cbios           00        0 (extern)
ch_exit          317'     791
ch_loop          2EB'     747
ch_miss          2F9'     761
ch_reg_loop      363'     867
cmp_hashes       2E5'     741
conrch          00        0 (extern)
const           00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
copy_hash        360'     864
crc16x          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
delta_msg        477'     1143
dhb32_loop       393'     915
disp_best        2BD'     701
disp_hex32_be    390'     912
disp_ok          39C'     924
enum_counter   =04        4
exam_tail       30'       48
exit             2AD'     685
exit_msg         430'     1072
fbfcb           00        0 (extern)
fcbr            03"       3
fclose          00        0 (extern)
fdel            00        0 (extern)
fdfcb           00        0 (extern)
fdnam           00        0 (extern)
fdsrem          00        0 (extern)
fdswem          00        0 (extern)
finit           00        0 (extern)
fmake           00        0 (extern)
fopen           00        0 (extern)
frdblk          00        0 (extern)
frdby           00        0 (extern)
frdrec          00        0 (extern)
fstfre          00        0 (extern)
fwrblk          00        0 (extern)
fwrby           00        0 (extern)
fwrrec          00        0 (extern)
genesis          6E1'     1761
genesis_hash     731'     1841
genesis_msg      4FD'     1277
hc_found_msg     49C'     1180
hc_mismatch_msg  481'     1153
hcmp_byte_loop   1C8'     456
hcmp_reg_loop    1C4'     452
init_clr_hash    15B'     347
initt_done       193'     403
iter_count      CF"       207
iter_delta      AD"       173
iter_msg         46A'     1130
jptbl_addr     =F6        246
load_done        16B'     363
load_err_msg     551'     1361
load_error       13D'     317
load_msg         52D'     1325
madbbu          00        0 (extern)
madd32          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
main_loop        19C'     412
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
mclr32          00        0 (extern)
mcop32          00        0 (extern)
mcp32           00        0 (extern)
minc32          00        0 (extern)
ml_no_break      27B'     635
msg_exit         2AA'     682
msg_per_const    6DD'     1757
msg_time        A9"       169
msub32          00        0 (extern)
mtwdli          00        0 (extern)
next_nonce       1F2'     498
no_z80_msg       3C0'     960
no_zarc_msg      3D3'     979
null_msg_hash    5D6'     1494
ok_msg           4A5'     1189
on_z80          18'       24
op_check_term   33'       51
op_err_msg       403'     1027
op_error        3A'       58
operands_ok     40'       64
panic           00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
rep_delinc_dn    20C'     524
rep_done         26B'     619
rep_not_zarc     22A'     554
rep_start        231'     561
save_err_msg     5A3'     1443
save_error       2A7'     679
save_fn          546'     1350
save_msg         58B'     1419
save_size      =78        120
save_start      CF"       207
sh2dh           00        0 (extern)
sh2ini          00        0 (extern)
sh2m            00        0 (extern)
signon_msg       3A2'     930
skpspc          00        0 (extern)
start_msg        445'     1093
str_offset     =A6        166
test1_msg        5F6'     1526
test1_msg_hash   605'     1541
test1_msg_len  =0F        15
test2_msg        625'     1573
test2_msg_hash   69D'     1693
test2_msg_len  =78        120
test3_msg_hash   6BD'     1725
test3_msg_len  =77        119
test_long2_msg   4E7'     1255
test_long_msg    4D3'     1235
test_null_msg    4AA'     1194
test_short_msg   4BE'     1214
toloca          00        0 (extern)
toupca          00        0 (extern)
z80det          00        0 (extern)
zarc_flag       02"       2
zrcdet          00        0 (extern)
