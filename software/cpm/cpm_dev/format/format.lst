   1:				; *******************************************************
   2:				; * MMC Drive Format for ZARC Z80 Computer              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 27/12/2020                          *
   5:				; *******************************************************
   6:				;
   7:				; This programme is intended to run under CP/M 2.2. It formats a "drive" on the
   8:				; MMC card ready for use by the filing system. Unlike formatters for physical
   9:				; disks, the sectors are already prepared so most of the work is done. All that is
  10:				; required it so mark the directory entries as unused.
  11:				;
  12:				; This programme reads the DPB to discover the organisation of the disk, so it
  13:				; should work for any sensible disk size or organisation. It is intended for ZARC
  14:				; systems only, and is unlikely to be useful on a system with physical floppy
  15:				; disk drives as it knows nothing about formatting sectors.
  16:				;
  17:				                title ZARC CP/M Format
  18:				;
  19:				;
  20:				;
  21:				; ************
  22:				; * Includes *
  23:				; ************
  24:				;
  25:				;
  26:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** format.z80 ****
  27:				                include "cpm.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** format.z80 ****
  28:				                include "cpm_utility.i" ; CP/M utilities
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMU         ; Inhibit for this module
  10:				; CP/M specific.
  11:				                extern cbdos    ; Call BDOS with some registers saved
  12:				                extern cbios    ; Call BIOS with some registers saved
  13:				                extern panic    ; Fatal application error
  14:				                extern zrcdet   ; Detect ZARC
  15:				                extern z80det   ; Detect Z80 (instead of 8080 / 8085)
  16:				;
  17:				; Derived from the monitor's utility.z80.
  18:				                extern conwch   ; Write character to console
  19:				                extern conrch   ; Read character from the console
  20:				                extern const    ; Fetch console input status
  21:				                extern cwnwln   ; Write new line characters to console
  22:				                extern conwms   ; Print "$" terminated string to the console
  23:				                extern conwmn   ; Print message <n> in a list
  24:				                extern skpspc   ; Step hl past spaces
  25:				                extern toupca   ; Convert character in A to upper case
  26:				                extern toloca   ; Convert character in A to lower case
  27:				                extern cwvich   ; Print only visible 7-bit characters
  28:				                extern cwpspc   ; Print a space
  29:				                extern mtwdli   ; Match word in a string against list of options
  30:				                extern cwphnb   ; Print least-significant nibble in A in hexadecimal
  31:				                extern cwphby   ; Print A in hexadecimal
  32:				                extern cwphwd   ; Print HL in hexadecimal
  33:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  34:				                extern cwpdby   ; Print A in decimal. Leading zeros are suppressed
  35:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  36:				                extern cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  37:				                extern rdhxwd   ; Read a 16-bit hexadecimal number from a string
  38:				                extern rdduwd   ; Read a 16-bit unsigned decimal number from a string
  39:				                extern rddulo   ; Read a 32-bit unsigned decimal number from a string
  40:				;
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** format.z80 ****
  29:				;
  30:				;
  31:				;
  32:				; *************
  33:				; * Constants *
  34:				; *************
  35:				;
  36:				;
  37:     -	0040'         	STACK_SIZE      equ 64                  ; Stack space allocation
  38:				;
  39:				;
  40:				;
  41:				; *************
  42:				; * Main Code *
  43:				; *************
  44:				;
  45:				;
  46:				; The CP/M transient area start address is set in the linker invokation (see
  47:				; makefile).
  48:				                cseg                    ; Code segment
  49:				;
  50:				; The default stack space is very small (8 deep), which would almost certainly
  51:				; cause issues, particularly with interrupts running. The initial code should
  52:				; not assume a Z80 so we can exit cleanly if this is run on something else.
  53:    0+10	0000' 314700  	start           ld sp, app_stack_top    ; Switch to our stack space
  54:				;
  55:				; Determine CPU type.
  56:   10+17	0003' CD0000  	                call z80det             ; Detect Z80 (instead of 8080 / 8085)
  57:   27+10	0006' D21400  	                jp nc, on_z80           ; Jump if we have a Z80
  58:				;
  59:				; 8080 / 8085 detected. Print message and exit. We can't use conwms as this
  60:				; assumes a Z80.
  61:   37+10	0009' 110C02  	                ld de, no_z80_msg       ; "Z80 CPU required"
  62:   47+7	000C' 0E09    	                ld c, BDOS_PRINT_STRING ; Print String
  63:   54+17	000E' CD0500  	                call BDOS
  64:   71+10	0011' C30000  	                jp 0                    ; Warm boot
  65:				;
  66:				; The following code is not 8080 / 8085 safe.
  67:   81+10	0014' 21E901  	on_z80          ld hl, signon_msg
  68:   91+17	0017' CD0000  	                call conwms             ; Print "$" terminated string to the console
  69:				;
  70:				; Are we running on a ZARC system?
  71:  108+17	001A' CD0000  	                call zrcdet
  72:  125+7+5	001D' 3009    	                jr nc, on_zarc          ; Jump if we are on ZARC
  73:				;
  74:  132+10	001F' 21B702  	                ld hl, no_zarc_msg      ; "ZARC BIOS not detected."
  75:  142+17	0022' CD0000  	                call conwms             ; Print "$" terminated string to the console
  76:  159+10	0025' C36501  	                jp exit
  77:				;
  78:				; Examine the command tail, looking for operands. This is stored in the default
  79:				; buffer. "The first byte at 0080H contains the length of the command tail, while
  80:				; the command tail itself begins at 0081H. The command tail is terminated by a
  81:				; byte containing a binary zero value." (http://www.cpm.z80.de/manuals/cpm22-m.pdf
  82:				; appendix H).
  83:  169+10	0028' 218100  	on_zarc         ld hl, DEF_BUFFER + 1
  84:  179+17	002B' CD0000  	                call skpspc             ; Skip spaces
  85:  196+7	002E' 7E      	                ld a, (hl)              ; This should be a drive letter
  86:				;    ld a, "B"   ; ***TEMP*** - useful when debugging
  87:  203+7	002F' D641    	                sub "A"                 ; Convert to a number
  88:				; If this carries, the byte is not a letter. It may be the zero terminator, if no
  89:				; operand were supplied.
  90:  210+7+5	0031' 3815    	                jr c, op_error
  91:  217+7	0033' FE10    	                cp NUM_DISKS_MAX
  92:  224+7+5	0035' 3011    	                jr nc, op_error
  93:				; We have a valid drive number.
  94:  231+13	0037' 320000  	                ld (drive), a           ; Save it
  95:				;
  96:				; A following colon is optional.
  97:  244+6	003A' 23      	                inc hl
  98:  250+7	003B' 7E      	                ld a, (hl)
  99:  257+7	003C' FE3A    	                cp ":"
 100:  264+7+5	003E' 2001    	                jr nz, op_check_term
 101:  271+6	0040' 23      	                inc hl                  ; Step past colon
 102:				;
 103:				; The terminator should follow.
 104:  277+17	0041' CD0000  	op_check_term   call skpspc             ; Skip spaces
 105:  294+7	0044' 7E      	                ld a, (hl)
 106:				;    ld a, 0   ; ***TEMP*** - useful when debugging
 107:  301+4	0045' A7      	                and a
 108:  305+7+5	0046' 2809    	                jr z, operands_ok
 109:				;
 110:				; Go here if we don't like the operands supplied.
 111:  312+10	0048' 211F02  	op_error        ld hl, op_err_msg
 112:  322+17	004B' CD0000  	                call conwms             ; Print "$" terminated string to the console
 113:  339+10	004E' C36501  	                jp exit
 114:				;
 115:				; Operand processing complete.
 116:  349+7	0051' 0E0D    	operands_ok     ld c, BDOS_RESET_DISK_SYS   ; Reset Disk System
 117:  356+17	0053' CD0000  	                call cbdos              ; Call BDOS with some registers saved
 118:				; Both the above reset and the reboot at the end of this application should
 119:				; make it safe to format any drive regardless of its logged in status.
 120:				;
 121:				; Note that the BDOS function BDOS_GET_DPB is not useful here as it works only
 122:				; on the current drive.
 123:				;
 124:				; Select the drive to format.
 125:  373+13	0056' 3A0000  	                ld a, (drive)
 126:  386+4	0059' 4F      	                ld c, a
 127:  390+10	005A' 110000  	                ld de, 0                ; Treat disk as new to the system
 128:  400+10	005D' 211800  	                ld hl, BIOS_SELDSK      ; Select disc drive
 129:  410+17	0060' CD0000  	                call cbios
 130:				;HL - pointer to Disc Parameter Header (DPH) or zero on error.
 131:  427+4	0063' 7C      	                ld a, h
 132:  431+4	0064' B5      	                or l
 133:  435+7+5	0065' 2009    	                jr nz, drive_sel_ok
 134:				; Can't select drive.
 135:  442+10	0067' 214D02  	                ld hl, sel_err_msg
 136:  452+17	006A' CD0000  	                call conwms             ; Print "$" terminated string to the console
 137:  469+10	006D' C36501  	                jp exit
 138:     -	0070'         	drive_sel_ok
 139:				;
 140:				; Find address of DPB.
 141:  479+10	0070' 110A00  	                ld de, DPH_DPB          ; Offset to pointer to DPB
 142:  489+11	0073' 19      	                add hl, de
 143:  500+7	0074' 5E      	                ld e, (hl)              ; Fetch pointer
 144:  507+6	0075' 23      	                inc hl
 145:  513+7	0076' 56      	                ld d, (hl)
 146:  520+11	0077' D5      	                push de
 147:  531+14	0078' DDE1    	                pop ix
 148:				;
 149:				; We know that the directory starts at the beginning of the first track of the
 150:				; data area. There are DRM + 1 directory entries.
 151:				; 
 152:				; IX - pointer to DPB
 153:				; Scan each entry, looking for valid-looking entries.
 154:  545+10	007A' 010000  	                ld bc, 0                ; Directory entry number
 155:  555+20	007D' ED430300	                ld (file_count), bc     ; Reset counts
 156:  575+20	0081' ED430500	                ld (unused_count), bc
 157:				; Set no sector loaded.
 158:  595+10	0085' 21FFFF  	                ld hl, 0xffff
 159:  605+16	0088' 220100  	                ld (loaded_sector), hl
 160:				;
 161:  621+4	008B' 60      	scan_loop       ld h, b
 162:  625+4	008C' 69      	                ld l, c
 163:  629+17	008D' CD7101  	                call get_entry
 164:				; HL - points to start of entry
 165:  646+11	0090' E5      	                push hl                 ; Move address to IY
 166:  657+14	0091' FDE1    	                pop iy
 167:				;
 168:				; Check the entry.
 169:  671+19	0093' FD7E00  	                ld a, (iy + DIRE_USER)
 170:  690+7	0096' FEE5    	                cp 0xe5
 171:  697+7+5	0098' 2009    	                jr nz, sl_not_unused
 172:				; This is an unused entry.
 173:  704+16	009A' 2A0500  	                ld hl, (unused_count)
 174:  720+6	009D' 23      	                inc hl
 175:  726+16	009E' 220500  	                ld (unused_count), hl
 176:  742+12	00A1' 183C    	                jr sl_entry_done        ; Entry done
 177:				;
 178:				; Does the filename look credible?
 179:  754+15	00A3' FDE5    	sl_not_unused   push iy
 180:  769+10	00A5' E1      	                pop hl
 181:  779+6	00A6' 23      	                inc hl
 182:				; HL - points to start of filename
 183:  785+11	00A7' C5      	                push bc                 ; Save entry number
 184:  796+7	00A8' 0608    	                ld b, 8                 ; Number of characters to check
 185:  803+7	00AA' 0E00    	                ld c, 0                 ; Oddity count
 186:  810+7	00AC' 7E      	sl_fn_check     ld a, (hl)
 187:  817+7	00AD' FE20    	                cp 0x20
 188:  824+7+5	00AF' 3804    	                jr c, sl_fn_ch_bad
 189:  831+7	00B1' FE80    	                cp 0x80
 190:  838+7+5	00B3' 3801    	                jr c, sl_fn_ch_ok
 191:  845+4	00B5' 0C      	sl_fn_ch_bad    inc c                   ; Flag oddity
 192:  849+6	00B6' 23      	sl_fn_ch_ok     inc hl
 193:  855+8+5	00B7' 10F3    	                djnz sl_fn_check
 194:				;
 195:				; Check the extension, which follows directly.
 196:  863+7	00B9' 0603    	                ld b, 3                 ; Number of characters to check
 197:  870+7	00BB' 7E      	sl_typ_check    ld a, (hl)
 198:  877+7	00BC' E67F    	                and 0x7f                ; Remove top bit (flag)
 199:  884+7	00BE' FE20    	                cp 0x20
 200:  891+7+5	00C0' 3001    	                jr nc, sl_typ_ch_ok
 201:  898+4	00C2' 0C      	                inc c                   ; Flag oddity
 202:  902+6	00C3' 23      	sl_typ_ch_ok    inc hl
 203:  908+8+5	00C4' 10F5    	                djnz sl_typ_check
 204:				;
 205:				; Examine the results
 206:  916+4	00C6' 79      	                ld a, c
 207:  920+10	00C7' C1      	                pop bc                  ; Restore entry number
 208:  930+4	00C8' A7      	                and a
 209:  934+7+5	00C9' 2014    	                jr nz, sl_entry_done    ; Complete if any oddities found
 210:				;
 211:				; Extent counter (low byte) should be 0 to 31.
 212:  941+19	00CB' FD7E0C  	                ld a, (iy + DIRE_EX)
 213:  960+7	00CE' FE20    	                cp 32
 214:  967+7+5	00D0' 300D    	                jr nc, sl_entry_done
 215:				;
 216:				; S1 should be 0.
 217:  974+19	00D2' FD7E0D  	                ld a, (iy + DIRE_S1)
 218:  993+4	00D5' A7      	                and a
 219:  997+7+5	00D6' 2007    	                jr nz, sl_entry_done
 220:				;
 221:				; If we get this far, the entry looks credible. It would be possible to check the
 222:				; allocation list, but there seems little value in doing this given the context.
 223: 1004+16	00D8' 2A0300  	                ld hl, (file_count)
 224: 1020+6	00DB' 23      	                inc hl
 225: 1026+16	00DC' 220300  	                ld (file_count), hl
 226:				;
 227:				; Entry scanned.
 228: 1042+4	00DF' 79      	sl_entry_done   ld a, c
 229: 1046+19	00E0' DDBE07  	                cp (ix + DPB_DRM)       ; Is this the last entry?
 230: 1065+7+5	00E3' 2006    	                jr nz, sl_do_next
 231: 1072+4	00E5' 78      	                ld a, b
 232: 1076+19	00E6' DDBE08  	                cp (ix + DPB_DRM + 1)
 233: 1095+7+5	00E9' 2803    	                jr z, scan_done
 234: 1102+6	00EB' 03      	sl_do_next      inc bc                  ; Next entry
 235: 1108+12	00EC' 189D    	                jr scan_loop
 236:				;
 237:				; All directory entries scanned.
 238: 1120+19	00EE' DD6E07  	scan_done       ld l, (ix + DPB_DRM)
 239: 1139+19	00F1' DD6608  	                ld h, (ix + DPB_DRM + 1)
 240: 1158+6	00F4' 23      	                inc hl
 241:				; HL - number of directory entries
 242: 1164+20	00F5' ED5B0500	                ld de, (unused_count)
 243: 1184+4	00F9' A7      	                and a
 244: 1188+15	00FA' ED52    	                sbc hl, de              ; Subtract number of unused entries
 245: 1203+20	00FC' ED5B0300	                ld de, (file_count)
 246: 1223+4	0100' A7      	                and a
 247: 1227+15	0101' ED52    	                sbc hl, de              ; Subtract number of valid-looking entries
 248:				; HL - number of odd entries (neither valid nor deleted).
 249: 1242+4	0103' 7C      	                ld a, h
 250: 1246+4	0104' B5      	                or l
 251: 1250+7+5	0105' 2019    	                jr nz, do_format        ; Format without asking if it looks bad
 252:				;
 253:				; The disk looks as if it has files on it. Ask for confirmation from the user.
 254: 1257+16	0107' 2A0300  	                ld hl, (file_count)
 255: 1273+17	010A' CD0000  	                call cwpdwd             ; Print HL in decimal
 256:				;
 257: 1290+10	010D' 217502  	                ld hl, scan_1_msg       ; " potential files found. Proceed ... ?"
 258: 1300+17	0110' CD0000  	                call conwms             ; Print "$" terminated string to the console
 259:				;
 260:				; Await a single character response from the user.
 261: 1317+17	0113' CD0000  	                call conrch             ; Read character from the console
 262: 1334+7	0116' FE59    	                cp "Y"
 263: 1341+10	0118' CA2001  	                jp z, do_format
 264: 1351+7	011B' FE79    	                cp "y"
 265: 1358+10	011D' C26501  	                jp nz, exit             ; Anything other than "Y" aborts
 266:				;
 267:				; Proceed with the format. To minimise any loss of data, entries are marked
 268:				; "unused" without changing anything else.
 269:				; IX - pointer to DPB
 270: 1368+17	0120' CD0000  	do_format       call cwnwln             ; Write new line characters to console
 271:				;
 272: 1385+10	0123' 010000  	                ld bc, 0                ; Directory entry number
 273: 1395+11	0126' C5      	fmt_loop        push bc
 274: 1406+4	0127' 60      	                ld h, b
 275: 1410+4	0128' 69      	                ld l, c
 276: 1414+17	0129' CD7101  	                call get_entry
 277:				; HL - points to start of entry
 278: 1431+11	012C' E5      	                push hl                 ; Move address to IY
 279: 1442+14	012D' FDE1    	                pop iy
 280:				;
 281:				; Mark it unused.
 282: 1456+19	012F' FD3600E5	                ld (iy + DIRE_USER), 0xe5
 283:				;
 284:				; If this was the last entry in a sector, we should write it.
 285: 1475+4	0133' 79      	                ld a, c
 286: 1479+7	0134' E603    	                and 0x03
 287: 1486+7	0136' FE03    	                cp 0x03
 288: 1493+7+5	0138' 2015    	                jr nz, fmt_entry_done   ; Skip write if not the last one
 289:				;
 290:				; Write the sector back from whence it came.
 291: 1500+16	013A' 2A0100  	                ld hl, (loaded_sector)
 292: 1516+7	013D' 0E00    	                ld c, 0
 293: 1523+4	013F' EB      	                ex de, hl
 294:				; CDE - CP/M (128-byte) sector number (offset into data area)
 295: 1527+17	0140' CDB001  	                call set_sector
 296:				; Write the sector.
 297: 1544+10	0143' 212700  	                ld hl, BIOS_WRITE       ; Write a sector
 298: 1554+7	0146' 0E00    	                ld c, 0                 ; Flag writes may be deferred
 299: 1561+17	0148' CD0000  	                call cbios
 300: 1578+4	014B' A7      	                and a
 301: 1582+10	014C' C26801  	                jp nz, disk_error
 302:				
 303: 1592+10	014F' C1      	fmt_entry_done  pop bc
 304: 1602+4	0150' 79      	                ld a, c
 305: 1606+19	0151' DDBE07  	                cp (ix + DPB_DRM)       ; Is this the last entry?
 306: 1625+7+5	0154' 2006    	                jr nz, fmt_do_next
 307: 1632+4	0156' 78      	                ld a, b
 308: 1636+19	0157' DDBE08  	                cp (ix + DPB_DRM + 1)
 309: 1655+7+5	015A' 2803    	                jr z, fmt_done
 310: 1662+6	015C' 03      	fmt_do_next     inc bc                  ; Next entry
 311: 1668+12	015D' 18C7    	                jr fmt_loop
 312:				;
 313:				; All directory entries written.
 314: 1680+10	015F' 21A402  	fmt_done        ld hl, done_msg
 315: 1690+17	0162' CD0000  	                call conwms             ; Print "$" terminated string to the console
 316:				;
 317:				; Return to CP/M.
 318: 1707+10	0165' C30000  	exit            jp 0                    ; Warm boot
 319:				;
 320:				;
 321:				; Go here if a disk error is reported.
 322: 1717+10	0168' 216302  	disk_error      ld hl, disk_err_msg
 323: 1727+17	016B' CD0000  	                call conwms             ; Print "$" terminated string to the console
 324: 1744+10	016E' C36501  	                jp exit
 325:				;
 326:				;
 327:				;
 328:				; ***************
 329:				; * Subroutines *
 330:				; ***************
 331:				;
 332:				;
 333:				; Read a directory entry from the disk and return a pointer to it.
 334:				; Call with:
 335:				; HL - required directory entry number
 336:				; IX - pointer to Disk Parameter Block (DPB)
 337:				; Returns with:
 338:				; HL - points to start of entry
 339: 1754+11	0171' C5      	get_entry       push bc
 340: 1765+11	0172' D5      	                push de
 341: 1776+11	0173' E5      	                push hl                 ; Save entry number
 342:				; Divide by four to find the sector number.
 343: 1787+4	0174' A7      	                and a
 344: 1791+8	0175' CB1C    	                rr h
 345: 1799+8	0177' CB1D    	                rr l
 346: 1807+4	0179' A7      	                and a
 347: 1811+8	017A' CB1C    	                rr h
 348: 1819+8	017C' CB1D    	                rr l
 349:				; HL - CP/M (128-byte) sector number (offset into data area)
 350:				; Is this already in the buffer?
 351: 1827+20	017E' ED5B0100	                ld de, (loaded_sector)
 352: 1847+4	0182' 7C      	                ld a, h
 353: 1851+4	0183' BA      	                cp d
 354: 1855+7+5	0184' 2004    	                jr nz, ge_load_reqd
 355: 1862+4	0186' 7D      	                ld a, l
 356: 1866+4	0187' BB      	                cp e
 357: 1870+7+5	0188' 2813    	                jr z, ge_have_sec
 358:				;
 359:				; We need to load the sector containing the required entry.
 360: 1877+16	018A' 220100  	ge_load_reqd    ld (loaded_sector), hl  ; Save sector number
 361: 1893+7	018D' 0E00    	                ld c, 0
 362: 1900+4	018F' EB      	                ex de, hl
 363:				; CDE - CP/M (128-byte) sector number (offset into data area)
 364: 1904+17	0190' CDB001  	                call set_sector
 365:				; Read the sector.
 366: 1921+10	0193' 212400  	                ld hl, BIOS_READ        ; Read a sector
 367: 1931+17	0196' CD0000  	                call cbios
 368: 1948+4	0199' A7      	                and a
 369: 1952+10	019A' C26801  	                jp nz, disk_error
 370:				;
 371:				; The required sector is loaded. Find the start address of the directory entry.
 372: 1962+10	019D' E1      	ge_have_sec     pop hl                  ; Restore directory entry number
 373: 1972+4	019E' 7D      	                ld a, l
 374: 1976+7	019F' E603    	                and 0x03
 375: 1983+4	01A1' 6F      	                ld l, a
 376: 1987+7	01A2' 2600    	                ld h, 0
 377:				; HL - number of entry within sector.
 378: 1994+11	01A4' 29      	                add hl, hl              ; Multiply by 32 to find offset
 379: 2005+11	01A5' 29      	                add hl, hl
 380: 2016+11	01A6' 29      	                add hl, hl
 381: 2027+11	01A7' 29      	                add hl, hl
 382: 2038+11	01A8' 29      	                add hl, hl
 383: 2049+10	01A9' 118000  	                ld de, DEF_BUFFER
 384: 2059+11	01AC' 19      	                add hl, de              ; Add buffer start address
 385:				;
 386: 2070+10	01AD' D1      	                pop de
 387: 2080+10	01AE' C1      	                pop bc
 388: 2090+10	01AF' C9      	                ret                     ; Return with address in HL
 389:				;
 390:				;
 391:				; Set track and sector numbers for subsequent read and / or write operations. DMA
 392:				; address is set to the default area (0x80).
 393:				; Call with:
 394:				; CDE - CP/M (128-byte) sector number (offset into data area)
 395:				; IX - pointer to Disk Parameter Block (DPB)
 396: 2100+11	01B0' C5      	set_sector      push bc
 397: 2111+11	01B1' E5      	                push hl
 398:				; Find track number. For this application, the track number is likely to be small
 399:				; (normally zero). Hence this crude algorithm is sufficient.
 400: 2122+19	01B2' DD6E0D  	                ld l, (ix + DPB_OFF)    ; Start after reserved tracks
 401: 2141+19	01B5' DD660E  	                ld h, (ix + DPB_OFF + 1)
 402: 2160+11	01B8' D5      	ss_track_loop   push de                 ; Save LS 16 bits of sector number
 403:				; Perform a trial subtraction to see if we have a complete track worth of sectors.
 404: 2171+4	01B9' 7B      	                ld a, e
 405: 2175+19	01BA' DD9600  	                sub (ix + DPB_SPT)
 406: 2194+4	01BD' 5F      	                ld e, a
 407: 2198+4	01BE' 7A      	                ld a, d
 408: 2202+19	01BF' DD9E01  	                sbc (ix + DPB_SPT + 1)
 409: 2221+4	01C2' 57      	                ld d, a
 410: 2225+4	01C3' 79      	                ld a, c
 411: 2229+7	01C4' DE00    	                sbc 0
 412: 2236+4	01C6' 4F      	                ld c, a
 413: 2240+7+5	01C7' 3805    	                jr c, ss_track_done
 414:				; No carry, so we can advance to the next track.
 415: 2247+6	01C9' 23      	                inc hl
 416: 2253+6	01CA' 33      	                inc sp                  ; Discard saved sector number
 417: 2259+6	01CB' 33      	                inc sp
 418: 2265+12	01CC' 18EA    	                jr ss_track_loop
 419:				;
 420:				; There was a carry in the last subtract, so this is the track we want.
 421:				; HL - track number
 422:				; (stacked) - sector number
 423:				; Set track.
 424: 2277+4	01CE' 44      	ss_track_done   ld b, h                 ; Move track number to BC
 425: 2281+4	01CF' 4D      	                ld c, l
 426: 2285+10	01D0' 211B00  	                ld hl, BIOS_SETTRK      ; Set track number
 427: 2295+17	01D3' CD0000  	                call cbios
 428:				;
 429:				; Set sector.
 430: 2312+10	01D6' C1      	                pop bc                  ; Fetch sector
 431: 2322+10	01D7' 211E00  	                ld hl, BIOS_SETSEC      ; Set sector number
 432: 2332+17	01DA' CD0000  	                call cbios
 433:				;
 434:				; Set DMA address.
 435: 2349+10	01DD' 018000  	                ld bc, DEF_BUFFER
 436: 2359+10	01E0' 212100  	                ld hl, BIOS_SETDMA      ; Set DMA address
 437: 2369+17	01E3' CD0000  	                call cbios
 438:				;
 439: 2386+10	01E6' E1      	                pop hl
 440: 2396+10	01E7' C1      	                pop bc
 441: 2406+10	01E8' C9      	                ret
 442:				;
 443:				;
 444:				;
 445:				; *************
 446:				; * Constants *
 447:				; *************
 448:				;
 449:     -	01E9' 2A2A2A20	signon_msg      byte "*** ZARC Disk Formatter V1.0 ***", 0x0d, 0x0a, "$"
	              5A415243
	              20446973
	              6B20466F
	              726D6174
	              74657220
	              56312E30
	              202A2A2A
	              0D0A24
 450:     -	020C' 5A383020	no_z80_msg      byte "Z80 CPU required", 0x0d, 0x0a, "$"
	              43505520
	              72657175
	              69726564
	              0D0A24
 451:     -	021F' 44726976	op_err_msg      byte "Drive letter expected.", 0x0d, 0x0a, "$"
	              65206C65
	              74746572
	              20657870
	              65637465
	              642E0D0A
	              24
 452:     -	0238' 44726976	rst_err_msg     byte "Drive reset error.", 0x0d, 0x0a, "$"
	              65207265
	              73657420
	              6572726F
	              722E0D0A
	              24
 453:     -	024D' 43616E27	sel_err_msg     byte "Can't select drive.", 0x0d, 0x0a, "$"
	              74207365
	              6C656374
	              20647269
	              76652E0D
	              0A24
 454:     -	0263' 4469736B	disk_err_msg    byte "Disk I/O error.", 0x0d, 0x0a, "$"
	              20492F4F
	              20657272
	              6F722E0D
	              0A24
 455:     -	0275' 20706F74	scan_1_msg      byte " potential files found. Proceed with format?", 0x0d, 0x0a, "$"
	              656E7469
	              616C2066
	              696C6573
	              20666F75
	              6E642E20
	              50726F63
	              65656420
	              77697468
	              20666F72
	              6D61743F
	              0D0A24
 456:     -	02A4' 466F726D	done_msg        byte "Format complete.", 0x0d, 0x0a, "$"
	              61742063
	              6F6D706C
	              6574652E
	              0D0A24
 457:     -	02B7' 5A415243	no_zarc_msg     byte "ZARC BIOS not detected.", 0x0d, 0x0a, "$"
	              2042494F
	              53206E6F
	              74206465
	              74656374
	              65642E0D
	              0A24
 458:				;
 459:				;
 460:				;
 461:				; *************
 462:				; * Variables *
 463:				; *************
 464:				;
 465:				; Private monitor variables located in bank 1.
 466:				; Note: linker "-c" option is used, so no data is initialised here.
 467:				                dseg                ; Data segment
 468:				;
 469:     -	0000"         	drive           defs 1              ; Drive number.
 470:     -	0001"         	loaded_sector   defs 2              ; Currently loaded sector
 471:     -	0003"         	file_count      defs 2              ; Valid-looking directory entry count
 472:     -	0005"         	unused_count    defs 2              ; Unused entry count
 473:				;
 474:     -	0007"         	                defs STACK_SIZE     ; Stack space
 475:     -	0047"         	app_stack_top
 476:				;
 477:     -	0047"         	                end



Statistics:

     4	passes
     0	jr promotions
   237	symbols
   721	bytes

    94	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
CCP_START      =D600      54784
CDISK          =04        4
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MMAP_CPM_PAGES =04        4
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
STACK_SIZE     =40        64
TPA_START      = 100      256
app_stack_top   47"       71
cbdos           00        0 (extern)
cbios           00        0 (extern)
conrch          00        0 (extern)
const           00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
disk_err_msg     263'     611
disk_error       168'     360
do_format        120'     288
done_msg         2A4'     676
drive           00"       0
drive_sel_ok    70'       112
exit             165'     357
file_count      03"       3
fmt_do_next      15C'     348
fmt_done         15F'     351
fmt_entry_done   14F'     335
fmt_loop         126'     294
ge_have_sec      19D'     413
ge_load_reqd     18A'     394
get_entry        171'     369
jptbl_addr     =7E        126
loaded_sector   01"       1
mtwdli          00        0 (extern)
no_z80_msg       20C'     524
no_zarc_msg      2B7'     695
on_z80          14'       20
on_zarc         28'       40
op_check_term   41'       65
op_err_msg       21F'     543
op_error        48'       72
operands_ok     51'       81
panic           00        0 (extern)
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
rst_err_msg      238'     568
scan_1_msg       275'     629
scan_done       EE'       238
scan_loop       8B'       139
sel_err_msg      24D'     589
set_sector       1B0'     432
signon_msg       1E9'     489
skpspc          00        0 (extern)
sl_do_next      EB'       235
sl_entry_done   DF'       223
sl_fn_ch_bad    B5'       181
sl_fn_ch_ok     B6'       182
sl_fn_check     AC'       172
sl_not_unused   A3'       163
sl_typ_ch_ok    C3'       195
sl_typ_check    BB'       187
ss_track_done    1CE'     462
ss_track_loop    1B8'     440
start           00'       0
str_offset     =24        36
toloca          00        0 (extern)
toupca          00        0 (extern)
unused_count    05"       5
z80det          00        0 (extern)
zrcdet          00        0 (extern)
