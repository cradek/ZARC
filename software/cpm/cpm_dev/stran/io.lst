   1:				; *******************************************************
   2:				; * I/O Routines for STran                              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 22/3/2021                           *
   5:				; *******************************************************
   6:				;
   7:				                title STran I/O
   8:				;
   9:				;
  10:				;
  11:				; ************
  12:				; * Includes *
  13:				; ************
  14:				;
  15:				;
  16:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** io.z80 ****
  17:				                include "cpm.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** io.z80 ****
  18:				                include "stran.i"       ; Project include file
**** stran.i ****
   1:				; *******************************************************
   2:				; * Serial File Transfer for ZARC Z80 Computer (STran)  *
   3:				; * Include file                                        *
   4:				; * Written by: Merlin Skinner                          *
   5:				; * Date Started: 22/3/2021                             *
   6:				; *******************************************************
   7:				;
   8:				;
   9:				;
  10:				; *************
  11:				; * Constants *
  12:				; *************
  13:				;
  14:				;
  15:				;DEBUG           equ 1               ; Define to enable debug messages
  16:				;
  17:     -	0040'         	STACK_SIZE      equ 64              ; Stack space allocation
  18:     -	0003'         	BREAK_CHAR      equ 'C' - 0x40
  19:     -	0200'         	BLKLEN          equ 512             ; Maximum data block size
  20:     -	FFFF'         	FLUSH_TIMER     equ 0xffff          ; Receive buffer flush time
  21:				;
  22:				; Receive error codes.
  23:     -	        	                ENUM_START
  24:     -	        	                ENUM RXERR_OK       ; No error
  25:     -	        	                ENUM RXERR_BREAK    ; Break detected
  26:     -	        	                ENUM RXERR_ENC      ; 3 to 4 coding error
  27:     -	        	                ENUM RXERR_CRC      ; CRC error
  28:     -	        	                ENUM_END RXERR_NUM  ; Number of possible values
  29:				;
  30:				;
  31:				;
  32:				;
  33:				; **************
  34:				; * Structures *
  35:				; **************
  36:				;
  37:				;
  38:				; Packet format (header).
  39:     -	        	                STRUCT
  40:				; Start of packet "*" is hard coded, and not stored in the structure.
  41:     -	        	                STR_BYTE PKT_TYPE   ; Packet type
  42:     -	        	                STR_WORD PKT_PSN    ; Packet Sequence Number
  43:     -	        	                STR_WORD PKT_LENGTH ; Data length (0 to BLKLEN).
  44:     -	        	                STR_BLOCK PKT_DATA, BLKLEN  ; Data (PKT_LENGTH bytes)
  45:				; 1 or 2 bytes of padding to align to 3-byte boundary.
  46:				; 16-bit CRC
  47:				; 1 byte pad to align to 3-byte boundary.
  48:     -	        	                STR_END PKT_SIZE
  49:				;
  50:				; File path (for command packets).
  51:     -	        	                STRUCT
  52:     -	        	                STR_BYTE FPTH_DRIVE     ; Drive letter
  53:     -	        	                STR_BLOCK FPTH_NAME, 8  ; File name
  54:     -	        	                STR_BLOCK FPTH_EXT, 3   ; File extension
  55:     -	        	                STR_END FPTH_SIZE
  56:				;
  57:				; PKT_TYPE can have any of the following values:
  58:     -	        	                ENUM_START
  59:     -	        	                ENUM PKTYP_NULL     ; Skip zero
  60:     -	        	                ENUM PKTYP_ACK      ; Positive acknowledgement
  61:     -	        	                ENUM PKTYP_NAK      ; Negative acknowledgement
  62:     -	        	                ENUM PKTYP_EXIT     ; Exit CP/M stran and return to CP/M
  63:     -	        	                ENUM PKTYP_TX       ; Transmit file (PC to CP/M)
  64:     -	        	                ENUM PKTYP_RX       ; Receive file (CP/M to PC)
  65:     -	        	                ENUM PKTYP_END      ; Normal end of transfer
  66:     -	        	                ENUM PKTYP_ABORT    ; Abort transfer
  67:     -	        	                ENUM PKTYP_DIR      ; Read directory
  68:     -	        	                ENUM_END PKTYP_NUM  ; Number of possible values
  69:				; Zero is skipped to avoid a completely null packet appearing valid. This would
  70:				; have a zero checksum, so a string of nulls could cause confusion.
  71:				;
  72:				; NAK reason codes:
  73:     -	        	                ENUM_START
  74:     -	        	                ENUM NAK_CRC        ; CRC error
  75:     -	        	                ENUM NAK_PSN        ; Unexpected PSN
  76:     -	        	                ENUM NAK_CMD        ; Unexpected command
  77:     -	        	                ENUM NAK_OPEN       ; Can’t open file
  78:     -	        	                ENUM NAK_RW_ERR     ; BDOS file read / write error
  79:     -	        	                ENUM NAK_NO_TRAN    ; Abort when no transfer is underway
  80:     -	        	                ENUM_END NAK_NUM    ; Number of possible values
  81:				
**** io.z80 ****
  19:				                include "cpm_utility.i" ; CP/M utilities
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMU         ; Inhibit for this module
  10:				; CP/M specific.
  11:				                extern cbdos    ; Call BDOS with some registers saved
  12:				                extern cbios    ; Call BIOS with some registers saved
  13:				                extern panic    ; Fatal application error
  14:				                extern zrcdet   ; Detect ZARC
  15:				                extern z80det   ; Detect Z80 (instead of 8080 / 8085)
  16:				;
  17:				; Derived from the monitor's utility.z80.
  18:				                extern conwch   ; Write character to console
  19:				                extern conrch   ; Read character from the console
  20:				                extern const    ; Fetch console input status
  21:				                extern cwnwln   ; Write new line characters to console
  22:				                extern conwms   ; Print "$" terminated string to the console
  23:				                extern conwmn   ; Print message <n> in a list
  24:				                extern skpspc   ; Step hl past spaces
  25:				                extern toupca   ; Convert character in A to upper case
  26:				                extern toloca   ; Convert character in A to lower case
  27:				                extern cwvich   ; Print only visible 7-bit characters
  28:				                extern cwpspc   ; Print a space
  29:				                extern mtwdli   ; Match word in a string against list of options
  30:				                extern cwphnb   ; Print least-significant nibble in A in hexadecimal
  31:				                extern cwphby   ; Print A in hexadecimal
  32:				                extern cwphwd   ; Print HL in hexadecimal
  33:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  34:				                extern cwpdby   ; Print A in decimal. Leading zeros are suppressed
  35:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  36:				                extern cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  37:				                extern rdhxwd   ; Read a 16-bit hexadecimal number from a string
  38:				                extern rdduwd   ; Read a 16-bit unsigned decimal number from a string
  39:				                extern rddulo   ; Read a 32-bit unsigned decimal number from a string
  40:				;
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** io.z80 ****
  20:				                include "cpm_maths.i"   ; Integer mathematics
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm_maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for CP/M Applications         *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 10/9/2022                           *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMM         ; Inhibit for this module
  10:				; CP/M specific.
  11:				; 32-bit arithmetic.
  12:				                extern mclr32       ; 32-bit clear (zero)
  13:				                extern mcop32       ; 32-bit copy from (hl) to (de)
  14:				                extern minc32       ; 32-bit increment
  15:				                extern mcp32        ; 32-bit compare (hl) - (de)
  16:				                extern madd32       ; 32-bit add (hl) <- (hl) + (de)
  17:				                extern msub32       ; 32-bit sub (hl) <- (hl) - (de)
  18:				;
  19:				; Derived from the monitor's maths.z80.
  20:				                extern madlbu       ; 32-bit / 8-bit unsigned divide
  21:				                extern madwbu       ; 16-bit / 8-bit unsigned divide
  22:				                extern madbbu       ; 8-bit / 8-bit unsigned divide
  23:				                extern mamwwu       ; 16-bit * 16-bit unsigned multiply
  24:				                extern mamlbu       ; 32-bit * 8-bit unsigned multiply
  25:				                extern crc16x       ; Software CRC-16 (XMODEM)
  26:				;
  27:				            endif
  28:				;
**** io.z80 ****
  21:				;
  22:				;
  23:				;
  24:				; *************
  25:				; * Externals *
  26:				; *************
  27:				;
  28:				;
  29:				; Variables
  30:				                extern spoflg   ; Non-zero if in single port mode
  31:				                extern zrcflg   ; Non-zero if on a ZARC system
  32:				                extern brkflg   ; Non-zero if break character detected
  33:				;
  34:				; Functions
  35:				                public flush    ; Flush data port receive buffer
  36:				                public rxpkt    ; Receive a packet
  37:				                public txpkt    ; Transmit a packet
  38:				                public txdch    ; Transmit a character to the data port
  39:				                public rxdch    ; Read a character from the data port
  40:				;
  41:				;
  42:				                cseg                    ; Code segment
  43:				;
  44:				;
  45:				;
  46:				; ************
  47:				; * Transmit *
  48:				; ************
  49:				;
  50:				;
  51:				; Transmit a packet. The packet is assumed to be fully built, with all fields
  52:				; populated except the CRC.
  53:				; Call with:
  54:				; IY - pointer to packet buffer
  55:    0+11	0000' C5      	txpkt           push bc
  56:   11+11	0001' D5      	                push de
  57:   22+11	0002' E5      	                push hl
  58:				;
  59:   33+15	0003' FDE5    	                push iy
  60:   48+10	0005' E1      	                pop hl
  61:				;
  62:				; Send start of packet character ("*" - not encoded)
  63:   58+7	0006' 3E2A    	                ld a, "*"
  64:   65+17	0008' CD8A00  	                call txdch
  65:				;
  66:				; Calculate total number of unencoded bytes to send.
  67:   82+4	000B' EB      	                ex de, hl
  68:   86+10	000C' 210500  	                ld hl, PKT_DATA         ; Number of header bytes to send
  69:   96+19	000F' FD4604  	                ld b, (iy + PKT_LENGTH + 1) ; Fetch data length in bytes
  70:  115+19	0012' FD4E03  	                ld c, (iy + PKT_LENGTH)
  71:  134+11	0015' 09      	                add hl, bc
  72:  145+11	0016' E5      	                push hl                 ; Copy length to BC
  73:  156+10	0017' C1      	                pop bc
  74:  166+4	0018' EB      	                ex de, hl
  75:  170+10	0019' 110000  	                ld de, 0                ; Set initial CRC
  76:				; BC - total bytes of header + data.
  77:				; DE - CRC
  78:				; HL - pointer to next byte to send (PSN).
  79:  180+11	001C' C5      	txp_send_loop   push bc                 ; Save byte counter
  80:  191+11	001D' D5      	                push de                 ; Save CRC
  81:				;
  82:				; Send data
  83:  202+7	001E' 4E      	                ld c, (hl)
  84:  209+6	001F' 23      	                inc hl
  85:  215+7	0020' 56      	                ld d, (hl)
  86:  222+6	0021' 23      	                inc hl
  87:  228+7	0022' 5E      	                ld e, (hl)
  88:  235+17	0023' CD4F00  	                call tx_data_enc        ; Send 3 to 4 bytes encoded data
  89:  252+10	0026' D1      	                pop de                  ; Restore CRC
  90:				;
  91:				; Update CRC.
  92:  262+6	0027' 2B      	                dec hl
  93:  268+6	0028' 2B      	                dec hl
  94:  274+4	0029' EB      	                ex de, hl
  95:				
  96:				; DE - pointer to next byte to send (PSN).
  97:				; HL - CRC
  98:  278+7	002A' 1A      	                ld a, (de)              ; Fetch byte 0
  99:  285+17	002B' CD0000  	                call crc16x             ; Add to CRC
 100:  302+6	002E' 13      	                inc de
 101:				;
 102:  308+7	002F' 1A      	                ld a, (de)              ; Fetch byte 1
 103:  315+17	0030' CD0000  	                call crc16x             ; Add to CRC
 104:  332+6	0033' 13      	                inc de
 105:				;
 106:  338+7	0034' 1A      	                ld a, (de)              ; Fetch byte 2
 107:  345+17	0035' CD0000  	                call crc16x             ; Add to CRC
 108:  362+6	0038' 13      	                inc de
 109:				;
 110:  368+4	0039' EB      	                ex de, hl
 111:  372+10	003A' C1      	                pop bc
 112:				; BC - total bytes of header + data.
 113:				; DE - CRC
 114:				; HL - pointer to next byte to send (PSN).
 115:  382+6	003B' 0B      	                dec bc                  ; Update byte counter
 116:  388+6	003C' 0B      	                dec bc
 117:  394+6	003D' 0B      	                dec bc
 118:				; If BC is zero or negative there is no more data to send.
 119:  400+6	003E' 0B      	                dec bc
 120:				; Now we can look for negative in all cases.
 121:  406+4	003F' 78      	                ld a, b
 122:  410+6	0040' 03      	                inc bc                  ; Restore decrement by 3 result
 123:  416+4	0041' A7      	                and a
 124:  420+10	0042' F21C00  	                jp p, txp_send_loop     
 125:				; Data sent, complete with padding (if required) to align to a 3-byte boundary.
 126:				;
 127:				; Send CRC
 128:  430+4	0045' 4B      	                ld c, e
 129:  434+7	0046' 1E00    	                ld e, 0                 ; Pad byte
 130:  441+17	0048' CD4F00  	                call tx_data_enc        ; Send 3 to 4 bytes encoded data
 131:				;
 132:  458+10	004B' E1      	                pop hl
 133:  468+10	004C' D1      	                pop de
 134:  478+10	004D' C1      	                pop bc
 135:  488+10	004E' C9      	                ret
 136:				;
 137:				;
 138:				; Transmit 3 bytes using the 3 to 4 bytes encoding scheme.
 139:				; Call with:
 140:				; CDE - data to transmit (C first)
 141:  498+11	004F' C5      	tx_data_enc     push bc
 142:  509+4	0050' 79      	                ld a, c
 143:  513+8	0051' CB3F    	                srl a
 144:  521+8	0053' CB3F    	                srl a
 145:  529+7	0055' F640    	                or 0x40
 146:				; A - <0, 1> <byte 0 bits 7 to 2>
 147:  536+17	0057' CD8A00  	                call txdch
 148:  553+4	005A' 79      	                ld a, c
 149:  557+4	005B' 07      	                rlca
 150:  561+4	005C' 07      	                rlca
 151:  565+4	005D' 07      	                rlca
 152:  569+4	005E' 07      	                rlca
 153:  573+7	005F' E630    	                and 0x30                ; Isolate byte 0 bits 1 to 0
 154:  580+4	0061' 47      	                ld b, a
 155:  584+4	0062' 7A      	                ld a, d
 156:  588+4	0063' 0F      	                rrca
 157:  592+4	0064' 0F      	                rrca
 158:  596+4	0065' 0F      	                rrca
 159:  600+4	0066' 0F      	                rrca
 160:  604+7	0067' E60F    	                and 0x0f                ; Isolate byte 1 bits 7 to 4
 161:  611+4	0069' B0      	                or b
 162:  615+7	006A' F640    	                or 0x40
 163:				; A - <0, 1> <byte 0 bits 1 to 0> <byte 1 bits 7 to 4>
 164:  622+17	006C' CD8A00  	                call txdch
 165:  639+4	006F' 7A      	                ld a, d
 166:  643+4	0070' 07      	                rlca
 167:  647+4	0071' 07      	                rlca
 168:  651+7	0072' E63C    	                and 0x3c                ; Isolate byte 1 bits 3 to 0
 169:  658+4	0074' 47      	                ld b, a
 170:  662+4	0075' 7B      	                ld a, e
 171:  666+4	0076' 07      	                rlca
 172:  670+4	0077' 07      	                rlca
 173:  674+7	0078' E603    	                and 0x03                ; Isolate byte 2 bits 7 to 6
 174:  681+4	007A' B0      	                or b
 175:  685+7	007B' F640    	                or 0x40
 176:				; A - <0, 1> <byte 1 bits 3 to 0> <byte 2 bits 7 to 6>
 177:  692+17	007D' CD8A00  	                call txdch
 178:  709+4	0080' 7B      	                ld a, e
 179:  713+7	0081' E63F    	                and 0x3f                ; Isolate byte 2 bits 5 to 0
 180:  720+7	0083' F640    	                or 0x40
 181:				; A - <0, 1> <byte 2 bits 5 to 0>
 182:  727+17	0085' CD8A00  	                call txdch
 183:  744+10	0088' C1      	                pop bc
 184:  754+10	0089' C9      	                ret
 185:				;
 186:				;
 187:				; Transmit a character to the data port. CP/M does not provide a method for reading
 188:				; the PUNCH device port status, so this routine will wait if the transmitter is
 189:				; busy.
 190:				; Call with:
 191:				; A - character to send.
 192:  764+11	008A' C5      	txdch           push bc
 193:  775+11	008B' D5      	                push de
 194:  786+11	008C' E5      	                push hl
 195:				;
 196:  797+4	008D' 4F      	                ld c, a
 197:  801+10	008E' 210F00  	                ld hl, BIOS_PUNCH       ; Paper tape punch output
 198:  811+17	0091' CD0000  	                call cbios
 199:				;
 200:  828+10	0094' E1      	                pop hl
 201:  838+10	0095' D1      	                pop de
 202:  848+10	0096' C1      	                pop bc
 203:  858+10	0097' C9      	                ret
 204:				;
 205:				;
 206:				;
 207:				; ***********
 208:				; * Receive *
 209:				; ***********
 210:				;
 211:				;
 212:				; Receive a packet.
 213:				; Call with:
 214:				; IY - pointer to packet buffer
 215:				; Returns with:
 216:				; A - 0x00 if OK or RXERR_...
 217:  868+11	0098' C5      	rxpkt           push bc
 218:  879+11	0099' D5      	                push de
 219:  890+11	009A' E5      	                push hl
 220:  901+20	009B' ED730000	                ld (ret_sp), sp         ; Save stack for error exits
 221:				;
 222:				; Await start of packet character.
 223:  921+20	009F' ED7B0000	rxp_wait_start  ld sp, (ret_sp)         ; Restore saved stack pointer
 224:  941+17	00A3' CD8401  	                call rxdch
 225:  958+4	00A6' 47      	                ld b, a
 226:  962+13	00A7' 3A0000  	                ld a, (brkflg)          ; Check break flag
 227:  975+4	00AA' A7      	                and a
 228:  979+7+5	00AB' 2054    	                jr nz, rxp_break
 229:  986+4	00AD' 78      	                ld a, b
 230:  990+7	00AE' FE2A    	                cp "*"
 231:  997+7+5	00B0' 20ED    	                jr nz, rxp_wait_start
 232:				;
 233:				; Start character found.
 234:     -	0000'         	                ifdef DEBUG
 237:				                endif
 238: 1004+10	00B2' 010000  	                ld bc, 0                ; Byte count
 239: 1014+10	00B5' 110000  	                ld de, 0                ; Initial CRC
 240: 1024+15	00B8' FDE5    	                push iy
 241: 1039+10	00BA' E1      	                pop hl
 242:				;
 243:				; BC - total bytes of header + data
 244:				; DE - CRC
 245:				; HL - receive buffer pointer
 246: 1049+17	00BB' CD0901  	rxp_loop        call rxp_read           ; Read three bytes
 247: 1066+7	00BE' FE01    	                cp RXERR_BREAK
 248: 1073+7+5	00C0' 283F    	                jr z, rxp_break
 249: 1080+4	00C2' A7      	                and a
 250: 1084+7+5	00C3' 20DA    	                jr nz, rxp_wait_start   ; Restart on other errors
 251:				;
 252:				; Handle length.
 253: 1091+6	00C5' 03      	                inc bc                  ; Three more bytes
 254: 1097+6	00C6' 03      	                inc bc
 255: 1103+6	00C7' 03      	                inc bc
 256:				; Read until the entire packet is in the buffer.
 257: 1109+4	00C8' 78      	                ld a, b
 258: 1113+4	00C9' A7      	                and a
 259: 1117+7+5	00CA' 2005    	                jr nz, rxp_have_len
 260: 1124+4	00CC' 79      	                ld a, c
 261: 1128+7	00CD' FE05    	                cp PKT_LENGTH + 2
 262: 1135+7+5	00CF' 38EA    	                jr c, rxp_loop          ; Keep reading if no data length yet
 263:				; The length bytes are in the buffer.
 264: 1142+11	00D1' E5      	rxp_have_len    push hl
 265: 1153+11	00D2' D5      	                push de
 266: 1164+10	00D3' 210500  	                ld hl, PKT_DATA         ; Number of header bytes
 267: 1174+19	00D6' FD5E03  	                ld e, (iy + PKT_LENGTH) ; Fetch data length
 268: 1193+19	00D9' FD5604  	                ld d, (iy + PKT_LENGTH + 1)
 269: 1212+11	00DC' 19      	                add hl, de
 270:				; HL - number of bytes to read.
 271: 1223+6	00DD' 2B      	                dec hl                  ; Subtract 1 to catch equal case
 272: 1229+4	00DE' A7      	                and a
 273: 1233+15	00DF' ED42    	                sbc hl, bc
 274: 1248+10	00E1' D1      	                pop de
 275: 1258+10	00E2' E1      	                pop hl
 276: 1268+7+5	00E3' 30D6    	                jr nc, rxp_loop
 277:				;
 278:				; Read the CRC
 279: 1275+11	00E5' D5      	                push de
 280: 1286+17	00E6' CD2D01  	                call rx_data_enc        ; Receive three bytes
 281:				; A - 0x00 if OK or RXERR_...
 282:				; CDE - received data (C first) unless brkflg is set.
 283: 1303+7	00E9' FE01    	                cp RXERR_BREAK
 284: 1310+7+5	00EB' 2814    	                jr z, rxp_break
 285: 1317+4	00ED' A7      	                and a
 286: 1321+7+5	00EE' 20AF    	                jr nz, rxp_wait_start   ; Restart on other errors
 287:				; CD - received checksum
 288: 1328+4	00F0' 69      	                ld l, c
 289: 1332+4	00F1' 62      	                ld h, d
 290: 1336+10	00F2' D1      	                pop de
 291:     -	0000'         	                ifdef DEBUG
 302:				                endif
 303: 1346+4	00F3' A7      	                and a
 304: 1350+15	00F4' ED52    	                sbc hl, de
 305: 1365+7+5	00F6' 200D    	                jr nz, rxp_crc_err
 306:     -	0000'         	                ifdef DEBUG
 309:				                endif
 310: 1372+4	00F8' AF      	                xor a                   ; Success code
 311:				;
 312:				; Return with error code in A.
 313: 1376+20	00F9' ED7B0000	rxp_exit        ld sp, (ret_sp)         ; Restore saved stack pointer
 314: 1396+10	00FD' E1      	                pop hl
 315: 1406+10	00FE' D1      	                pop de
 316: 1416+10	00FF' C1      	                pop bc
 317: 1426+10	0100' C9      	                ret
 318:				;
 319:				; Break (^C) detected.
 320: 1436+7	0101' 3E01    	rxp_break       ld a, RXERR_BREAK       ; Break detected
 321: 1443+12	0103' 18F4    	                jr rxp_exit
 322:				; 
 323: 1455+7	0105' 3E03    	rxp_crc_err     ld a, RXERR_CRC         ; CRC error
 324: 1462+12	0107' 18F0    	                jr rxp_exit
 325:				;
 326:				;
 327:				; Read three bytes and store them in the buffer. Update the CRC.
 328:				; Call and returns with:
 329:				; DE - CRC
 330:				; HL - buffer pointer
 331:				; Returns with:
 332:				; A - 0x00 if OK or RXERR_...
 333: 1474+11	0109' C5      	rxp_read        push bc
 334:				;
 335: 1485+11	010A' D5      	                push de                 ; Save CRC
 336: 1496+17	010B' CD2D01  	                call rx_data_enc        ; Receive three bytes
 337:				; A - 0x00 if OK or RXERR_...
 338:				; CDE - received data (C first) unless brkflg is set.
 339: 1513+7	010E' 71      	                ld (hl), c              ; Save the data
 340: 1520+6	010F' 23      	                inc hl
 341: 1526+7	0110' 72      	                ld (hl), d
 342: 1533+6	0111' 23      	                inc hl
 343: 1539+7	0112' 73      	                ld (hl), e
 344: 1546+10	0113' D1      	                pop de                  ; Restore CRC
 345: 1556+4	0114' A7      	                and a
 346: 1560+7+5	0115' 2014    	                jr nz, rxpr_exit        ; Exit on error
 347:				;
 348:				; Update CRC.
 349: 1567+6	0117' 2B      	                dec hl                  ; Point to first byte again
 350: 1573+6	0118' 2B      	                dec hl
 351: 1579+4	0119' EB      	                ex de, hl
 352:				; DE - pointer to next byte in buffer
 353:				; HL - CRC
 354: 1583+7	011A' 1A      	                ld a, (de)              ; Fetch byte 0
 355: 1590+17	011B' CD0000  	                call crc16x             ; Add to CRC
 356: 1607+6	011E' 13      	                inc de
 357:				;
 358: 1613+7	011F' 1A      	                ld a, (de)              ; Fetch byte 1
 359: 1620+17	0120' CD0000  	                call crc16x             ; Add to CRC
 360: 1637+6	0123' 13      	                inc de
 361:				;
 362: 1643+7	0124' 1A      	                ld a, (de)              ; Fetch byte 2
 363: 1650+17	0125' CD0000  	                call crc16x             ; Add to CRC
 364: 1667+6	0128' 13      	                inc de
 365:				;
 366: 1673+4	0129' EB      	                ex de, hl
 367:				; DE - CRC
 368:				; HL - pointer to next byte in buffer
 369: 1677+4	012A' AF      	                xor a                   ; Success code
 370:				;
 371:				; Exit with zero or error code (RXERR_...) in A.
 372: 1681+10	012B' C1      	rxpr_exit       pop bc
 373: 1691+10	012C' C9      	                ret
 374:				;
 375:				;
 376:				; Receive 3 bytes using the 3 to 4 bytes encoding scheme.
 377:				; Returns with:
 378:				; A - 0x00 if OK or RXERR_...
 379:				; CDE - received data (C first) if A = 0x00
 380: 1701+11	012D' E5      	rx_data_enc     push hl
 381: 1712+4	012E' 68      	                ld l, b                 ; Preserve B (only)
 382:				;
 383: 1716+17	012F' CD6401  	                call rde_char           ; Read character 0
 384:				; A - <byte 0 bits 7 to 2>
 385: 1733+4	0132' 87      	                add a
 386: 1737+4	0133' 87      	                add a
 387: 1741+4	0134' 4F      	                ld c, a
 388: 1745+17	0135' CD6401  	                call rde_char           ; Read character 1
 389:				; A - <byte 0 bits 1 to 0> <byte 1 bits 7 to 4>
 390: 1762+4	0138' 47      	                ld b, a
 391: 1766+4	0139' 0F      	                rrca
 392: 1770+4	013A' 0F      	                rrca
 393: 1774+4	013B' 0F      	                rrca
 394: 1778+4	013C' 0F      	                rrca
 395: 1782+7	013D' E603    	                and 0x03                ; Isolate byte 0 bits 1 to 0
 396: 1789+4	013F' B1      	                or c
 397: 1793+4	0140' 4F      	                ld c, a
 398:				; C - decoded byte 0.
 399:				; B - 6 data bits recovered from character 1
 400: 1797+4	0141' 78      	                ld a, b
 401: 1801+4	0142' 07      	                rlca
 402: 1805+4	0143' 07      	                rlca
 403: 1809+4	0144' 07      	                rlca
 404: 1813+4	0145' 07      	                rlca
 405: 1817+7	0146' E6F0    	                and 0xf0                ; Isolate byte 1 bits 7 to 4
 406: 1824+4	0148' 57      	                ld d, a
 407: 1828+17	0149' CD6401  	                call rde_char           ; Read character 2
 408:				; A - <byte 1 bits 3 to 0> <byte 2 bits 7 to 6>
 409: 1845+4	014C' 47      	                ld b, a
 410: 1849+4	014D' 0F      	                rrca
 411: 1853+4	014E' 0F      	                rrca
 412: 1857+7	014F' E60F    	                and 0x0f                ; Isolate byte 1 bits 3 to 0
 413: 1864+4	0151' B2      	                or d
 414: 1868+4	0152' 57      	                ld d, a
 415:				; D - decoded byte 1.
 416:				; B - 6 data bits recovered from character 2
 417: 1872+4	0153' 78      	                ld a, b
 418: 1876+4	0154' 0F      	                rrca
 419: 1880+4	0155' 0F      	                rrca
 420: 1884+7	0156' E6C0    	                and 0xc0                ; Isolate byte byte 2 bits 7 to 6
 421: 1891+4	0158' 5F      	                ld e, a
 422: 1895+17	0159' CD6401  	                call rde_char           ; Read character 3
 423:				; A - <byte 2 bits 5 to 0>
 424: 1912+7	015C' E63F    	                and 0x3f                ; Isolate byte 2 bits 5 to 0
 425: 1919+4	015E' B3      	                or e
 426: 1923+4	015F' 5F      	                ld e, a
 427:				; E - decoded byte 2.
 428:				; CDE - received data (C first)
 429:     -	0000'         	                ifdef DEBUG
 445:				                endif
 446: 1927+4	0160' AF      	                xor a                   ; Set success code
 447:				;
 448: 1931+4	0161' 45      	rde_exit        ld b, l
 449: 1935+10	0162' E1      	                pop hl
 450: 1945+10	0163' C9      	                ret
 451:				;
 452:				; Read a character. For use by rx_data_enc as it makes direct jumps for error
 453:				; handling. B register is not preserved.
 454:				; A - bits 5 to 0 contain the 6 data bits recovered from this encoded character.
 455: 1955+17	0164' CD8401  	rde_char        call rxdch
 456: 1972+4	0167' 47      	                ld b, a
 457: 1976+13	0168' 3A0000  	                ld a, (brkflg)          ; Check break flag
 458: 1989+4	016B' A7      	                and a
 459: 1993+7+5	016C' 200A    	                jr nz, rdec_break
 460: 2000+4	016E' 78      	                ld a, b
 461: 2004+7	016F' D640    	                sub 0x40
 462: 2011+7+5	0171' 380B    	                jr c, rdec_enc          ; Error if < 0x40
 463: 2018+7	0173' FE40    	                cp 0x40
 464: 2025+7+5	0175' 3007    	                jr nc, rdec_enc         ; Error if character was >= 0x80
 465: 2032+10	0177' C9      	                ret
 466:				;
 467: 2042+6	0178' 33      	rdec_break      inc sp                  ; Discard rde_char return address
 468: 2048+6	0179' 33      	                inc sp
 469: 2054+7	017A' 3E01    	                ld a, RXERR_BREAK       ; Break detected
 470: 2061+12	017C' 18E3    	                jr rde_exit
 471:				;
 472: 2073+6	017E' 33      	rdec_enc        inc sp                  ; Discard rde_char return address
 473: 2079+6	017F' 33      	                inc sp
 474: 2085+7	0180' 3E02    	                ld a, RXERR_ENC         ; 3 to 4 encoding error
 475: 2092+12	0182' 18DD    	                jr rde_exit
 476:				;
 477:				;
 478:				; Fetch a received character from the data port. If no character is available,
 479:				; wait until one arrives. CP/M 2.2 does not provide a method for reading the
 480:				; READER device port status, but we can do this using ZARC extensions if we are
 481:				; running on a ZARC system. This code also checks for break (^C) characters on
 482:				; the console port, whether this is the same as the data port or not. If a break
 483:				; is detected, brkflg is set.
 484:				; Returns with:
 485:				; A - received character.
 486: 2104+11	0184' C5      	rxdch           push bc
 487: 2115+11	0185' D5      	                push de
 488: 2126+11	0186' E5      	                push hl
 489:				;
 490: 2137+13	0187' 3A0000  	                ld a, (spoflg)          ; Non-zero if in single port mode
 491: 2150+4	018A' A7      	                and a
 492: 2154+7+5	018B' 2016    	                jr nz, rdc_read         ; Read character or ^C
 493:				; We are in two port mode. We should preferably check that a character is ready
 494:				; before committing to a blocking read.
 495: 2161+13	018D' 3A0000  	                ld a, (zrcflg)          ; Non-zero if on a ZARC system
 496: 2174+4	0190' A7      	                and a
 497: 2178+7+5	0191' 2810    	                jr z, rdc_read          ; Jump if non-ZARC as we can't help
 498:				; We are in two port mode on ZARC. Wait until a character is ready, polling
 499:				; for break as we do so. Note, the auxiliary input is called READER in CP/M 2.x.
 500: 2185+10	0193' 213300  	rdc_wait        ld hl, BIOS_AUXIST      ; Status of auxiliary input
 501: 2195+17	0196' CD0000  	                call cbios
 502: 2212+4	0199' A7      	                and a
 503: 2216+7+5	019A' 2007    	                jr nz, rdc_read         ; Jump if a character awaits
 504: 2223+17	019C' CDCC01  	                call rdc_con_break
 505: 2240+7+5	019F' 381F    	                jr c, rdc_break         ; Jump if break detected
 506: 2247+12	01A1' 18F0    	                jr rdc_wait
 507:				;
 508:				; Read a character, waiting if required. In single port mode, it doesn't matter
 509:				; that this blocks as the returned character will either be data or a break.
 510: 2259+10	01A3' 211200  	rdc_read        ld hl, BIOS_READER      ; Reader input
 511: 2269+17	01A6' CD0000  	                call cbios
 512: 2286+13	01A9' 320200  	                ld (rdc_char), a        ; Save it for later
 513:     -	0000'         	                ifdef DEBUG
 521:				                endif
 522:				;
 523:				; Perform break (^C) checks. How we do this depends on the mode.
 524: 2299+13	01AC' 3A0000  	                ld a, (spoflg)
 525: 2312+4	01AF' A7      	                and a
 526: 2316+7+5	01B0' 2007    	                jr nz, rdc_one_port
 527:				;
 528:				; In two port mode, we should check the console device for break characters.
 529:				; This is somewhat redundant if on ZARC as we have checked previously, but
 530:				; is harmless.
 531: 2323+17	01B2' CDCC01  	                call rdc_con_break
 532: 2340+7+5	01B5' 3809    	                jr c, rdc_break         ; Jump if break detected
 533: 2347+12	01B7' 180C    	                jr rdc_break_done
 534:				;
 535:				; In single port mode, we just check the received character.
 536: 2359+13	01B9' 3A0200  	rdc_one_port    ld a, (rdc_char)        ; Fetch received character
 537: 2372+7	01BC' FE03    	rdc_chk_char    cp BREAK_CHAR
 538: 2379+7+5	01BE' 2005    	                jr nz, rdc_break_done   ; Exit if not a break
 539:				;
 540:				; Break character detected.
 541: 2386+7	01C0' 3EFF    	rdc_break       ld a, 0xff
 542: 2393+13	01C2' 320000  	                ld (brkflg), a          ; Flag break detected
 543:				;
 544: 2406+13	01C5' 3A0200  	rdc_break_done  ld a, (rdc_char)        ; Fetch received character
 545: 2419+10	01C8' E1      	                pop hl
 546: 2429+10	01C9' D1      	                pop de
 547: 2439+10	01CA' C1      	                pop bc
 548: 2449+10	01CB' C9      	                ret
 549:				;
 550:				; Check console port for break character.
 551:				; Returns with:
 552:				; Carry flag - set if break detected.
 553: 2459+10	01CC' 210300  	rdc_con_break   ld hl, BIOS_CONST       ; Console status
 554: 2469+17	01CF' CD0000  	                call cbios
 555: 2486+4	01D2' A7      	                and a
 556: 2490+7+5	01D3' 280A    	                jr z, rdcb_no_break     ; Exit if no character awaits
 557: 2497+10	01D5' 210600  	                ld hl, BIOS_CONIN       ; Console input
 558: 2507+17	01D8' CD0000  	                call cbios
 559: 2524+7	01DB' FE03    	                cp BREAK_CHAR
 560: 2531+7+5	01DD' 2802    	                jr z, rdcb_break
 561: 2538+4	01DF' A7      	rdcb_no_break   and a                   ; Flag no break detected
 562: 2542+10	01E0' C9      	                ret
 563:				;
 564: 2552+4	01E1' 37      	rdcb_break      scf                     ; Flag break detected
 565: 2556+10	01E2' C9      	                ret
 566:				;
 567:				;
 568:				; Flush data port receive buffer. This works when the console port is the
 569:				; data port (single port mode) and / or when running on a ZARC system. CP/M 2.2
 570:				; does not provide a method for reading the READER device port status, so this
 571:				; doesn't work on a non-ZARC system in dual port mode. This code keeps reading
 572:				; and discarding data until no data is received for a reasonable period,
 573:				; defined by FLUSH_TIMER. This behaviour allows for delays caused by additional
 574:				; upstream buffers, such as those in a RS-232 to USB adaptor.
 575: 2566+13	01E3' 3A0000  	flush           ld a, (spoflg)          ; Non-zero if in single port mode
 576: 2579+4	01E6' A7      	                and a
 577: 2583+7+5	01E7' 2005    	                jr nz, flu_doit         ; Jump if in single port mode
 578: 2590+13	01E9' 3A0000  	                ld a, (zrcflg)          ; Non-zero if on a ZARC system
 579: 2603+4	01EC' A7      	                and a
 580: 2607+5+6	01ED' C8      	                ret z                   ; Return if not ZARC
 581:				;
 582: 2612+11	01EE' C5      	flu_doit        push bc
 583: 2623+11	01EF' D5      	                push de
 584: 2634+11	01F0' E5      	                push hl
 585:				;
 586: 2645+10	01F1' 212002  	                ld hl, flushing_msg     ; "Flushing serial port receive buffer"
 587: 2655+17	01F4' CD0000  	                call conwms             ; Print $-terminated string to the console
 588:				;
 589:				; The timer is crude in that it really only sets the number of checks made
 590:				; before declaring the buffer empty. The actual time will depend on processor
 591:				; speed.
 592: 2672+10	01F7' 01FFFF  	flu_reset       ld bc, FLUSH_TIMER
 593: 2682+11	01FA' C5      	flu_loop        push bc
 594:				;
 595:				; Check the port status. This will determine whether we use CONST or AUXIST
 596:				; to check whether or not there is a character to read.
 597: 2693+10	01FB' 210300  	                ld hl, BIOS_CONST       ; Console status (single port mode)
 598: 2703+13	01FE' 3A0000  	                ld a, (spoflg)          ; Non-zero if in single port mode
 599: 2716+4	0201' A7      	                and a
 600: 2720+7+5	0202' 2003    	                jr nz, flu_check        ; Jump if in single port mode
 601: 2727+10	0204' 213300  	                ld hl, BIOS_AUXIST      ; Status of auxiliary input
 602:				; Check the port status using the appropriate function.
 603: 2737+17	0207' CD0000  	flu_check       call cbios
 604: 2754+4	020A' A7      	                and a
 605: 2758+7+5	020B' 2809    	                jr z, flu_no_char       ; Exit if no character awaits
 606:				;
 607:				; There is a character awaiting, so read it.
 608: 2765+10	020D' 211200  	                ld hl, BIOS_READER      ; Reader input
 609: 2775+17	0210' CD0000  	                call cbios
 610: 2792+10	0213' C1      	                pop bc                  ; Recover timer
 611:				; The received character is discarded.
 612: 2802+12	0214' 18E1    	                jr flu_reset            ; Reset timer and keep checking
 613:				;
 614: 2814+10	0216' C1      	flu_no_char     pop bc                  ; Recover timer
 615: 2824+6	0217' 0B      	                dec bc
 616: 2830+4	0218' 78      	                ld a, b
 617: 2834+4	0219' B1      	                or c
 618: 2838+7+5	021A' 20DE    	                jr nz, flu_loop
 619:				;
 620:				; Best effort flushing complete.
 621: 2845+10	021C' E1      	flu_done        pop hl
 622: 2855+10	021D' D1      	                pop de
 623: 2865+10	021E' C1      	                pop bc
 624: 2875+10	021F' C9      	                ret
 625:				;
 626:				;
 627:				;
 628:				; *************
 629:				; * Constants *
 630:				; *************
 631:				;
 632:				;
 633:     -	0220' 466C7573	flushing_msg    byte "Flushing serial port receive buffer", 0x0d, 0x0a, "$"
	              68696E67
	              20736572
	              69616C20
	              706F7274
	              20726563
	              65697665
	              20627566
	              6665720D
	              0A24
 634:				;
 635:				;
 636:				;
 637:				; *************
 638:				; * Variables *
 639:				; *************
 640:				;
 641:				;
 642:				; Note: linker "-c" option is used, so no data is initialised here.
 643:				                dseg                ; Data segment
 644:				;
 645:     -	0000"         	ret_sp          defs 2              ; Saved stack for error exits
 646:     -	0002"         	rdc_char        defs 1              ; Temporary character store for rxdch
 647:				;
 648:     -	0003"         	                end



Statistics:

     4	passes
     0	jr promotions
   281	symbols
   582	bytes

   130	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
BLKLEN         = 200      512
BREAK_CHAR     =03        3
CCP_START      =D600      54784
CDISK          =04        4
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
FLUSH_TIMER    =FFFF      65535
FPTH_DRIVE     =00        0
FPTH_EXT       =09        9
FPTH_NAME      =01        1
FPTH_SIZE      =0C        12
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MMAP_CPM_PAGES =04        4
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NAK_CMD        =02        2
NAK_CRC        =00        0
NAK_NO_TRAN    =05        5
NAK_NUM        =06        6
NAK_OPEN       =03        3
NAK_PSN        =01        1
NAK_RW_ERR     =04        4
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
PKTYP_ABORT    =07        7
PKTYP_ACK      =01        1
PKTYP_DIR      =08        8
PKTYP_END      =06        6
PKTYP_EXIT     =03        3
PKTYP_NAK      =02        2
PKTYP_NULL     =00        0
PKTYP_NUM      =09        9
PKTYP_RX       =05        5
PKTYP_TX       =04        4
PKT_DATA       =05        5
PKT_LENGTH     =03        3
PKT_PSN        =01        1
PKT_SIZE       = 205      517
PKT_TYPE       =00        0
RXERR_BREAK    =01        1
RXERR_CRC      =03        3
RXERR_ENC      =02        2
RXERR_NUM      =04        4
RXERR_OK       =00        0
STACK_SIZE     =40        64
TPA_START      = 100      256
brkflg          00        0 (extern)
cbdos           00        0 (extern)
cbios           00        0 (extern)
conrch          00        0 (extern)
const           00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
crc16x          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
enum_counter   =06        6
flu_check        207'     519
flu_doit         1EE'     494
flu_done         21C'     540
flu_loop         1FA'     506
flu_no_char      216'     534
flu_reset        1F7'     503
flush            1E3'     483 (public)
flushing_msg     220'     544
jptbl_addr     =7E        126
madbbu          00        0 (extern)
madd32          00        0 (extern)
madlbu          00        0 (extern)
madwbu          00        0 (extern)
mamlbu          00        0 (extern)
mamwwu          00        0 (extern)
mclr32          00        0 (extern)
mcop32          00        0 (extern)
mcp32           00        0 (extern)
minc32          00        0 (extern)
msub32          00        0 (extern)
mtwdli          00        0 (extern)
panic           00        0 (extern)
rdc_break        1C0'     448
rdc_break_done   1C5'     453
rdc_char        02"       2
rdc_chk_char     1BC'     444
rdc_con_break    1CC'     460
rdc_one_port     1B9'     441
rdc_read         1A3'     419
rdc_wait         193'     403
rdcb_break       1E1'     481
rdcb_no_break    1DF'     479
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rde_char         164'     356
rde_exit         161'     353
rdec_break       178'     376
rdec_enc         17E'     382
rdhxwd          00        0 (extern)
ret_sp          00"       0
rx_data_enc      12D'     301
rxdch            184'     388 (public)
rxp_break        101'     257
rxp_crc_err      105'     261
rxp_exit        F9'       249
rxp_have_len    D1'       209
rxp_loop        BB'       187
rxp_read         109'     265
rxp_wait_start  9F'       159
rxpkt           98'       152 (public)
rxpr_exit        12B'     299
skpspc          00        0 (extern)
spoflg          00        0 (extern)
str_offset     =0C        12
toloca          00        0 (extern)
toupca          00        0 (extern)
tx_data_enc     4F'       79
txdch           8A'       138 (public)
txp_send_loop   1C'       28
txpkt           00'       0 (public)
z80det          00        0 (extern)
zrcdet          00        0 (extern)
zrcflg          00        0 (extern)
