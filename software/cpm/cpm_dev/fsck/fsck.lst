   1:				; *******************************************************
   2:				; * CP/M File System Checker                            *
   3:				; * Version: V1.1                                       *
   4:				; * Merlin Skinner-Oakes, 16/2/2022                     *
   5:				; *******************************************************
   6:				;
   7:				; V1.0 - 16/2/2022, initial version.
   8:				; V1.1 - 4/11/2022, added option to skip the surface scan on request from
   9:				;        "alank2" at https://forum.vcfed.org/
  10:				;
  11:				; CP/M 2.2 file system checker. It is intended for ZARC but avoids using
  12:				; any special facilities so should run elsewhere. It reads the DPB to discover
  13:				; the organisation of the disk, so it should work for any sensible disk size or
  14:				; organisation.
  15:				;
  16:				; Each directory entry is scanned in turn, and a list (files_info) is
  17:				; constructed with one entry per file. This contains a bitmap of physical
  18:				; extents encountered, so it is possible to discover "holes" (sparse files)
  19:				; as well as duplicated extents.
  20:				;
  21:				; As files are discovered, files_info will grow by FI_SIZE each time. In
  22:				; addition, it will grow by a single byte each time more extent flags are
  23:				; required for any file.
  24:				;
  25:				; Note that there is a difference between logical and physical extents. A
  26:				; logical extent always contains 16 KB bytes of data. Each physical extent
  27:				; (directory entry) can contain one or more logical extents. (EXM + 1) is the
  28:				; number of logical extents per physical one. For ZARC (at least in its present
  29:				; form, EXM is zero so both logical and physical extents are 16 KB long. Useful
  30:				; reference:
  31:				; Ref. https://dflund.se/~pi/cpm/files/ftp.mayn.de/pub/cpm/archive/cpminfo/cpm-dir1.not.txt
  32:				;
  33:				; From this example:
  34:				; BLS = 2K so BSH = 4 and BLM = 15
  35:				; It uses 8-bit allocation numbers, so DSM < 256 and EXM = 1
  36:				;
  37:				; From: https://www.seasip.info/Cpm/format22.html
  38:				; (Physical) entry number (PEXTENT) = ((32*S2)+EX) / (EXM+1)
  39:				; There are two physical extents shown,
  40:				; S2 = 0 and EX = 1, which gives ((32*0)+1) / (2) = 0
  41:				; S2 = 0 and EX = 3, which gives ((32*0)+3) / (2) = 1
  42:				; So the above equation gives the physical extent number of a given directory
  43:				; entry. This is what we want to construct a bitmap of physical extents.
  44:				;
  45:				;
  46:				                title CP/M File System Checker
  47:				;
  48:				;
  49:				;
  50:				; ************
  51:				; * Includes *
  52:				; ************
  53:				;
  54:				;
  55:				                include "macros.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes/macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** fsck.z80 ****
  56:				                include "cpm.i"
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes/cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000'         	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004'         	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0'         	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200'         	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600'         	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06'         	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00'         	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C'         	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000'         	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100'         	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003'         	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004'         	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C'         	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C'         	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080'         	DEF_BUFFER          equ 0x80
  66:     -	0080'         	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003'         	IOB_CON_MASK        equ 0x03
  70:     -	000C'         	IOB_RDR_MASK        equ 0x0c
  71:     -	0030'         	IOB_PUN_MASK        equ 0x30
  72:     -	00C0'         	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080'         	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010'         	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010'         	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000'         	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000'         	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008'         	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003'         	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A'         	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F'         	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001'         	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005'         	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000'         	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001'         	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002'         	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003'         	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004'         	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005'         	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006'         	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007'         	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008'         	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009'         	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A'         	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B'         	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C'         	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D'         	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E'         	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F'         	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010'         	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011'         	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012'         	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013'         	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014'         	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015'         	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016'         	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017'         	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018'         	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019'         	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A'         	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B'         	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C'         	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D'         	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E'         	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F'         	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020'         	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021'         	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022'         	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023'         	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024'         	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025'         	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028'         	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** fsck.z80 ****
  57:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes/terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005'         	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008'         	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009'         	ASCII_HT            equ 0x09
  12:     -	000A'         	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B'         	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C'         	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D'         	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016'         	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A'         	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B'         	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E'         	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F'         	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F'         	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E'         	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006'         	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001'         	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002'         	ZKEY_HOME           equ 0x02
  29:     -	0016'         	ZKEY_INSERT         equ 0x16
  30:     -	007F'         	ZKEY_DELETE         equ 0x7f
  31:     -	0004'         	ZKEY_END            equ 0x04
  32:     -	001D'         	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C'         	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** fsck.z80 ****
  58:				                include "fsck.i"        ; Project include file
**** fsck.i ****
   1:				; *******************************************************
   2:				; * CP/M File System Checker                            *
   3:				; * Include file                                        *
   4:				; * Written by: Merlin Skinner                          *
   5:				; * Date Started: 16/2/2022                             *
   6:				; *******************************************************
   7:				;
   8:				;
   9:				;
  10:				; *************
  11:				; * Constants *
  12:				; *************
  13:				;
  14:				;
  15:				; DEBUG           equ 1                   ; Define to enable debugging mode
  16:				;
  17:     -	0040'         	STACK_SIZE      equ 64                  ; Stack space allocation
  18:     -	0003'         	BREAK_CHAR      equ 'C' - 0x40
  19:     -	03C0'         	BDIS_CHARS_MAX  equ (VT100_ROWS / 2) * VT100_COLS ; Maximum display area for block usage display
  20:				;
  21:				; Allocation counter and flags
  22:     -	        	BITDEF ALLCF_UNUSED, 7                  ; Set if any allocation is unused
  23:     -	        	BITDEF ALLCF_SPARSE, 6                  ; Set file contains a hole
  24:				; LS bits serve as a counter.
  25:     -	000F'         	ALLCF_COUNT     equ 0x0f                ; Used allocation counter
  26:				;
  27:				;
  28:				;
  29:				; **************
  30:				; * Structures *
  31:				; **************
  32:				;
  33:				;
  34:				; File information structure. User, name and type must match the directory
  35:				; entry structure (DIRE_xxx).
  36:     -	        	                STRUCT
  37:     -	        	                STR_BYTE FI_USER                    ; User number. 0xe5 if entry unused
  38:     -	        	                STR_BLOCK FI_NAME, FILENAME_SIZE    ; Filename in ASCII upper-case
  39:     -	        	                STR_BLOCK FI_TYP, FILEEXT_SIZE      ; File type
  40:     -	        	                STR_WORD FI_LAST_PEXT               ; Highest physical extent number found
  41:     -	        	                STR_BYTE FI_LAST_RC                 ; RC associated with the extent in FI_LAST_PEXT
  42:     -	        	                STR_BYTE FI_EX_FL_LEN               ; No. of extent flag bytes
  43:     -	        	                STR_BLOCK FI_EX_FLAGS, 0            ; Start of extent flags
  44:     -	        	                STR_END FI_SIZE
  45:				
**** fsck.z80 ****
  59:				                include "cpm_utility.i" ; CP/M utilities
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes/cpm_utility.i ****
   1:				; *******************************************************
   2:				; * Utility Routines for CP/M Applications              *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:     -	0001'         	            ifndef CPMU         ; Inhibit for this module
  10:				; CP/M specific.
  11:				                extern cbdos    ; Call BDOS with some registers saved
  12:				                extern cbios    ; Call BIOS with some registers saved
  13:				                extern panic    ; Fatal application error
  14:				                extern zrcdet   ; Detect ZARC
  15:				                extern z80det   ; Detect Z80 (instead of 8080 / 8085)
  16:				;
  17:				; Derived from the monitor's utility.z80.
  18:				                extern conwch   ; Write character to console
  19:				                extern conrch   ; Read character from the console
  20:				                extern const    ; Fetch console input status
  21:				                extern cwnwln   ; Write new line characters to console
  22:				                extern conwms   ; Print "$" terminated string to the console
  23:				                extern conwmn   ; Print message <n> in a list
  24:				                extern skpspc   ; Step hl past spaces
  25:				                extern toupca   ; Convert character in A to upper case
  26:				                extern toloca   ; Convert character in A to lower case
  27:				                extern cwvich   ; Print only visible 7-bit characters
  28:				                extern cwpspc   ; Print a space
  29:				                extern mtwdli   ; Match word in a string against list of options
  30:				                extern cwphnb   ; Print least-significant nibble in A in hexadecimal
  31:				                extern cwphby   ; Print A in hexadecimal
  32:				                extern cwphwd   ; Print HL in hexadecimal
  33:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  34:				                extern cwpdby   ; Print A in decimal. Leading zeros are suppressed
  35:				                extern cwpdwd   ; Print HL in decimal. Leading zeros are suppressed
  36:				                extern cwpdlo   ; Print DEHL in decimal. Leading zeros are suppressed
  37:				                extern rdhxwd   ; Read a 16-bit hexadecimal number from a string
  38:				                extern rdduwd   ; Read a 16-bit unsigned decimal number from a string
  39:				                extern rddulo   ; Read a 32-bit unsigned decimal number from a string
  40:				;
  41:				            endif
  42:				;
  43:				;
  44:				; mtwdli (match word in a string against list of options) option bits. Each bit
  45:				; has the described effect if set.
  46:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  47:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  48:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  49:				
**** fsck.z80 ****
  60:				                include "cpm_terminal.i"; Terminal control
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes/cpm_terminal.i ****
   1:				; *******************************************************
   2:				; * Terminal Control Routines for CP/M Applications     *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; These routines provide more complex control over the terminal than is offered
   8:				; by the simple generic character read / write used by the monitor and CP/M.
   9:				;
  10:				; Note that ld80 only considers the first six characters of labels significant.
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0001'         	            ifndef cpm_terminal ; Inhibit for this module
  18:				                extern concap   ; Console capabilities (CONCAP_xxx)
  19:				                extern ccinit   ; Determine terminal capabilities
  20:				                extern cldcur   ; Load cursor position
  21:				                extern conuln   ; Set underline
  22:				                extern conrev   ; Set reverse video
  23:				                extern csrvis   ; Show or hide cursor
  24:				                extern ccls     ; Clear screen
  25:				                extern cscrup   ; Scroll screen up
  26:				            endif
  27:				;
  28:				;
  29:     -	0018'         	VT100_ROWS          equ 24
  30:     -	0050'         	VT100_COLS          equ 80
  31:				;
  32:				;
  33:				; The concap (determine terminal capabilities) routine returns a byte
  34:				; indicating various capabilities of the attached terminal. The bits are
  35:				; defined here.
  36:     -	        	BITDEF CONCAP_ZARC, 0           ; ZARC BIOS present
  37:     -	        	BITDEF CONCAP_ANSI, 1           ; ANSI control codes, e.g. VT100
  38:     -	        	BITDEF CONCAP_UNICODE, 2        ; Terminal is capable of Unicode characters
  39:				;
  40:				; Note that Minicom by default emulates a VT102, and is capable of Unicode. If
  41:				; this terminal is detected, both CONCAP_VT100 and CONCAP_UNICODE are set.
  42:				;
  43:				;
  44:				; ANSI graphical rendition (SGR) codes. From https://en.wikipedia.org/wiki/ANSI_escape_code
  45:     -	0000'         	ANSI_SGR_NORMAL     equ 0           ; All attributes off
  46:     -	0001'         	ANSI_SGR_BOLD       equ 1           ; Bold or increased intensity
  47:     -	0002'         	ANSI_SGR_FAINT      equ 2           ; Faint, decreased intensity, or dim
  48:     -	0004'         	ANSI_SGR_ULINE      equ 4           ; Underline
  49:     -	0005'         	ANSI_SGR_SBLINK     equ 5           ; Slow blink
  50:     -	0006'         	ANSI_SGR_RBLINK     equ 6           ; Rapid blink
  51:     -	0007'         	ANSI_SGR_REV        equ 7           ; Reverse video or invert
  52:     -	0009'         	ANSI_SGR_STRIKE     equ 9           ; Characters legible but marked as if for deletion
  53:     -	000A'         	ANSI_SGR_PRI_FONT   equ 10          ; Primary (default) font
  54:     -	000B'         	ANSI_SGR_FONT_1     equ 11          ; Alternative fonts
  55:     -	000C'         	ANSI_SGR_FONT_2     equ 12
  56:     -	000D'         	ANSI_SGR_FONT_3     equ 13
  57:     -	000E'         	ANSI_SGR_FONT_4     equ 14
  58:     -	000F'         	ANSI_SGR_FONT_5     equ 15
  59:     -	0010'         	ANSI_SGR_FONT_6     equ 16
  60:     -	0011'         	ANSI_SGR_FONT_7     equ 17
  61:     -	0012'         	ANSI_SGR_FONT_8     equ 18
  62:     -	0013'         	ANSI_SGR_FONT_9     equ 19
  63:     -	0014'         	ANSI_SGR_GOTHIC     equ 20          ; Fraktur (Gothic) (not widely supported)
  64:     -	0015'         	ANSI_SGR_DULINE     equ 21          ; Doubly underlined *or* not bold
  65:     -	0016'         	ANSI_SGR_NORM_INTEN equ 22          ; Normal intensity
  66:     -	0017'         	ANSI_SGR_ITAL_OFF   equ 23          ; Neither italic, nor blackletter
  67:     -	0018'         	ANSI_SGR_ULINE_OFF  equ 24          ; Underline off
  68:     -	0019'         	ANSI_SGR_BLINK_OFF  equ 25          ; Blinking off
  69:     -	001B'         	ANSI_SGR_REV_OFF    equ 27          ; Reverse image off
  70:     -	001C'         	ANSI_SGR_HIDE_OFF   equ 28          ; Reveal (not concealed)
  71:     -	001D'         	ANSI_SGR_STRIKE_OFF equ 29
  72:				
**** fsck.z80 ****
  61:				                include "cpm_top.i"     ; CP/M dummy top module
**** /home/merlin/Technical/ZARC_Z80_Box/git/software/includes/cpm_top.i ****
   1:				; *******************************************************
   2:				; * Dummy Module to find the Last Location in Use.      *
   3:				; * Version: V1.0                                       *
   4:				; * Merlin Skinner, 16/12/2021                          *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				                extern fstfre       ; First location after end of data segment
  10:				
**** fsck.z80 ****
  62:				;
  63:				;
  64:				;
  65:				; *************
  66:				; * Externals *
  67:				; *************
  68:				;
  69:				;
  70:				; Variables
  71:				;                public brkflg   ; Non-zero if break character detected
  72:				;
  73:				;
  74:				;
  75:				; *************
  76:				; * Main Code *
  77:				; *************
  78:				;
  79:				;
  80:				; The CP/M transient area start address is set in the linker invokation (see makefile).
  81:				                cseg                    ; Code segment
  82:				;
  83:				; The default stack space is very small (8 deep), which would almost certainly
  84:				; cause issues, particularly with interrupts running. The initial code should
  85:				; not assume a Z80 so we can exit cleanly if this is run on something else.
  86:    0+20	0000' ED730000	                ld (bdos_sp), sp
  87:   20+10	0004' 316F00  	                ld sp, app_stack_top    ; Switch to our stack space
  88:				;
  89:				; Determine CPU type.
  90:   30+17	0007' CD0000  	                call z80det             ; Detect Z80 (instead of 8080 / 8085)
  91:   47+10	000A' D21800  	                jp nc, on_z80           ; Jump if we have a Z80
  92:				;
  93:				; 8080 / 8085 detected. Print message and exit. We can't use conwms as this
  94:				; assumes a Z80.
  95:   57+10	000D' 114B07  	                ld de, no_z80_msg       ; "Z80 CPU required"
  96:   67+7	0010' 0E09    	                ld c, BDOS_PRINT_STRING ; Print String
  97:   74+17	0012' CD0500  	                call BDOS
  98:   91+10	0015' C30000  	                jp 0                    ; Warm boot
  99:				;
 100:				; Sign on.
 101:  101+10	0018' 212107  	on_z80          ld hl, signon_msg
 102:  111+17	001B' CD0000  	                call conwms             ; Print $-terminated string to console
 103:				;
 104:				; Examine the command tail, looking for operands. This is stored in the default
 105:				; buffer. "The first byte at 0080H contains the length of the command tall, while
 106:				; the command tail itself begins at 0081H. The command tail is terminated by a
 107:				; byte containing a binary zero value." (http://www.cpm.z80.de/manuals/cpm22-m.pdf
 108:				; appendix H).
 109:  128+10	001E' 218100  	                ld hl, DEF_BUFFER + 1
 110:  138+17	0021' CD0000  	                call skpspc             ; Skip spaces
 111:  155+7	0024' 7E      	                ld a, (hl)              ; This should be a drive letter
 112:  162+6	0025' 23      	                inc hl
 113:     -	0000'         	                ifdef DEBUG
 115:				                endif
 116:  168+7	0026' D641    	                sub "A"                 ; Convert to a number
 117:				; If this carries, the byte is not a letter. It may be the zero terminator, if no
 118:				; operand were supplied.
 119:  175+7+5	0028' 3846    	                jr c, op_error
 120:  182+7	002A' FE10    	                cp NUM_DISKS_MAX
 121:  189+7+5	002C' 3042    	                jr nc, op_error
 122:				; We have a valid drive number.
 123:  196+13	002E' 320200  	                ld (drive), a           ; Save it
 124:				;
 125:				; A following colon is optional.
 126:  209+7	0031' 7E      	                ld a, (hl)
 127:  216+7	0032' FE3A    	                cp ":"
 128:  223+7+5	0034' 2001    	                jr nz, op_options
 129:  230+6	0036' 23      	                inc hl                  ; Step past colon
 130:				;
 131:				; Set default options. These may be modified as the command tail is processed.
 132:  236+4	0037' AF      	op_options      xor a
 133:  240+13	0038' 320300  	                ld (scan_enable), a     ; Disable surface scan
 134:				;
 135:				; Check for options. These may begin with "[", "/" or "$", to match all
 136:				; conventions I have found used with CP/M.
 137:  253+17	003B' CD0000  	                call skpspc             ; Skip spaces
 138:				; Options 
 139:  270+7	003E' 7E      	                ld a, (hl)
 140:  277+6	003F' 23      	                inc hl
 141:  283+4	0040' 4F      	                ld c, a                 ; Save for later
 142:  287+4	0041' A7      	                and a
 143:  291+7+5	0042' 2832    	                jr z, operands_ok       ; Jump if no options
 144:  298+7	0044' FE5B    	                cp "["
 145:  305+7+5	0046' 2808    	                jr z, op_found
 146:  312+7	0048' FE2F    	                cp "/"
 147:  319+7+5	004A' 2804    	                jr z, op_found
 148:  326+7	004C' FE24    	                cp "$"
 149:  333+7+5	004E' 2020    	                jr nz, op_error         ; Jump if not an option
 150:				; Option introducer found.
 151:				; C - option character
 152:				; HL - pointer to command tail
 153:  340+7	0050' 7E      	op_found        ld a, (hl)
 154:  347+6	0051' 23      	                inc hl
 155:  353+4	0052' A7      	                and a
 156:  357+7+5	0053' 281B    	                jr z, op_error          ; Error if option missing
 157:				; At present, there is just one option.
 158:  364+7	0055' FE53    	                cp "S"
 159:  371+7+5	0057' 2017    	                jr nz, op_error         ; C
 160:				; "S" option enables surface scan.
 161:  378+7	0059' 3EFF    	                ld a, 0xff
 162:  385+13	005B' 320300  	                ld (scan_enable), a     ; Enable surface scan
 163:				; Options processed. Check for "]" if appropriate.
 164:  398+4	005E' 79      	                ld a, c
 165:  402+7	005F' FE5B    	                cp "["
 166:  409+7+5	0061' 2006    	                jr nz, op_check_term    ; Jump if we didn't start with "["
 167:  416+7	0063' 7E      	                ld a, (hl)
 168:  423+6	0064' 23      	                inc hl
 169:  429+7	0065' FE5D    	                cp "]"
 170:  436+7+5	0067' 2007    	                jr nz, op_error         ; Jump if terminator or anything else
 171:				;
 172:				; The terminator should follow.
 173:  443+17	0069' CD0000  	op_check_term   call skpspc             ; Skip spaces
 174:  460+7	006C' 7E      	                ld a, (hl)
 175:     -	0000'         	                ifdef DEBUG
 177:				                endif
 178:  467+4	006D' A7      	                and a
 179:  471+7+5	006E' 2806    	                jr z, operands_ok
 180:				;
 181:				; Go here if we don't like the operands supplied.
 182:  478+10	0070' 215E07  	op_error        ld hl, op_err_msg
 183:  488+10	0073' C3E204  	                jp msg_exit
 184:				;
 185:				; Operand processing complete.
 186:  498+7	0076' 0E0D    	operands_ok     ld c, BDOS_RESET_DISK_SYS   ; Reset Disk System
 187:  505+17	0078' CD0000  	                call cbdos              ; Call BDOS with some registers saved
 188:				; Both the above reset and the reboot at the end of this application should
 189:				; make it safe to test any drive regardless of its logged in status.
 190:				;
 191:				; Select the drive to analyse.
 192:  522+13	007B' 3A0200  	                ld a, (drive)
 193:  535+4	007E' 4F      	                ld c, a
 194:  539+10	007F' 110000  	                ld de, 0                ; Treat disk as new to the system
 195:  549+10	0082' 211800  	                ld hl, BIOS_SELDSK      ; Select disc drive
 196:  559+17	0085' CD0000  	                call cbios              ; Call BIOS with some registers saved
 197:				;HL - pointer to Disc Parameter Header (DPH) or zero on error.
 198:  576+4	0088' 7C      	                ld a, h
 199:  580+4	0089' B5      	                or l
 200:  584+7+5	008A' 2009    	                jr nz, drive_sel_ok
 201:				; Can't select drive.
 202:  591+10	008C' 21C007  	                ld hl, sel_err_msg
 203:  601+17	008F' CD0000  	                call conwms             ; Print $-terminated string to console
 204:  618+10	0092' C3E504  	                jp exit
 205:     -	0095'         	drive_sel_ok
 206:				;
 207:				; Find address of DPB.
 208:  628+10	0095' 110A00  	                ld de, DPH_DPB          ; Offset to pointer to DPB
 209:  638+11	0098' 19      	                add hl, de
 210:  649+7	0099' 5E      	                ld e, (hl)              ; Fetch pointer
 211:  656+6	009A' 23      	                inc hl
 212:  662+7	009B' 56      	                ld d, (hl)
 213:  669+20	009C' ED531900	                ld (dpb), de            ; Save for later
 214:  689+11	00A0' D5      	                push de
 215:  700+14	00A1' DDE1    	                pop ix
 216:				; IX - pointer to DPB (DPB_xxx)
 217:				;
 218:				; Initialise variables.
 219:  714+10	00A3' 210000  	                ld hl, 0                ; Directory entry number
 220:  724+16	00A6' 221100  	                ld (file_count), hl     ; Reset counts
 221:  740+16	00A9' 221300  	                ld (unused_count), hl
 222:  756+16	00AC' 221500  	                ld (blocks_used), hl
 223:  772+16	00AF' 220F00  	                ld (error_count), hl
 224:				;
 225:				; Initialise buffers.
 226:				; Set start of flags to first location after this programme and its variables.
 227:  788+10	00B2' 210000  	                ld hl, fstfre           ; First location after end of data
 228:  798+16	00B5' 220400  	                ld (blk_flags), hl
 229:				;
 230:				; Calculate the number of blocks on disk. This will determine blk_flags_size,
 231:				; which requires one bit per block.
 232:  814+19	00B8' DD6E05  	                ld l, (ix + DPB_DSM)    ; Maximum block number
 233:  833+19	00BB' DD6606  	                ld h, (ix + DPB_DSM + 1)
 234:				; Number of bytes required is (DSM/8) + 1
 235:  852+7	00BE' 0603    	                ld b, 3
 236:  859+8	00C0' CB3C    	init_blk_div    srl h
 237:  867+8	00C2' CB1D    	                rr l
 238:  875+8+5	00C4' 10FA    	                djnz init_blk_div
 239:  883+6	00C6' 23      	                inc hl
 240:				; HL - number of bytes.
 241:  889+16	00C7' 220600  	                ld (blk_flags_size), hl
 242:				;
 243:				; Mark all blocks as free.
 244:  905+4	00CA' 44      	                ld b, h
 245:  909+4	00CB' 4D      	                ld c, l
 246:  913+16	00CC' 2A0400  	                ld hl, (blk_flags)
 247:  929+4	00CF' 78      	bfc_loop        ld a, b
 248:  933+4	00D0' B1      	                or c
 249:  937+7+5	00D1' 280C    	                jr z, bfc_done          ; Exit if done
 250:  944+17	00D3' CDCC05  	                call chk_mem_lim        ; Check HL is not too high
 251:  961+10	00D6' DADF04  	                jp c, out_of_memory
 252:  971+10	00D9' 3600    	                ld (hl), 0
 253:  981+6	00DB' 23      	                inc hl
 254:  987+6	00DC' 0B      	                dec bc
 255:  993+12	00DD' 18F0    	                jr bfc_loop
 256:				;
 257:				; Initialise file information area pointers.
 258:				; HL - first location after block flags.
 259: 1005+17	00DF' CDCC05  	bfc_done        call chk_mem_lim        ; Check HL is not too high
 260: 1022+10	00E2' DADF04  	                jp c, out_of_memory
 261: 1032+16	00E5' 220800  	                ld (files_info), hl     ; Set start address of FI structures
 262: 1048+16	00E8' 220A00  	                ld (free_start), hl     ; No files yet
 263:				; As files are discovered, files_info will grow by FI_SIZE each time. In
 264:				; addition, it will grow by a single byte each time more physical extent flags
 265:				; are required for any file.
 266:				;
 267:				; The directory starts at the beginning of the first track of the
 268:				; data area. There are DRM + 1 directory entries.
 269:				; Calculate the number of blocks used by the directory. This is given by
 270:				; the number of high bits set in DPB.AL0 and DPB.AL1. Reference:
 271:				; http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch6.htm#Figure_6-5
 272: 1064+19	00EB' DD6609  	                ld h, (ix + DPB_AL0)    ; Fetch directory allocation bits
 273: 1083+19	00EE' DD6E0A  	                ld l, (ix + DPB_AL1)
 274:				; Count the "1" bits.
 275: 1102+7	00F1' 0610    	                ld b, 16                ; Bit counter
 276: 1109+7	00F3' 0E00    	                ld c, 0
 277: 1116+8	00F5' CB7C    	id_al_loop      bit 7, h                ; Test MS bit
 278: 1124+7+5	00F7' 2804    	                jr z, id_al_done        ; Exit if "0" found
 279: 1131+4	00F9' 0C      	                inc c                   ; Count 1 bits
 280: 1135+11	00FA' 29      	                add hl, hl              ; Shift left
 281: 1146+8+5	00FB' 10F8    	                djnz id_al_loop
 282:				; We end up here if either all bits are tested or a "0" bit was encountered.
 283: 1154+4	00FD' 79      	id_al_done      ld a, c
 284: 1158+13	00FE' 320E00  	                ld (dir_blocks), a
 285: 1171+4	0101' A7      	                and a
 286: 1175+10+7	0102' CC0000  	                call z, panic           ; Panic if directory has no blocks
 287:				;
 288:				; Mark the directory blocks as used.
 289:				; C - number of directory blocks
 290: 1185+10	0105' 210000  	                ld hl, 0                ; Directory starts at block 0
 291: 1195+4	0108' 41      	                ld b, c
 292: 1199+11	0109' E5      	id_mark_used_lp push hl
 293: 1210+17	010A' CD4B05  	                call flag_block         ; Mark block used
 294: 1227+10+7	010D' DC0000  	                call c, panic           ; Panic if already used
 295: 1237+10	0110' E1      	                pop hl
 296: 1247+6	0111' 23      	                inc hl
 297: 1253+8+5	0112' 10F5    	                djnz id_mark_used_lp
 298:				; 
 299:				; IX - pointer to DPB (DPB_xxx)
 300: 1261+10	0114' 21FFFF  	                ld hl, 0xffff
 301: 1271+16	0117' 220C00  	                ld (loaded_sector), hl  ; Set no sector loaded.
 302:				;
 303:				; Scan each entry, looking for valid-looking entries.
 304: 1287+10	011A' 210000  	                ld hl, 0                ; Start at first entry
 305: 1297+16	011D' 221F00  	scan_loop       ld (dir_entry_num), hl  ; Loop counter
 306: 1313+17	0120' CD9E06  	                call get_entry
 307:				; HL - points to start of entry
 308: 1330+11	0123' E5      	                push hl                 ; Move address to IY
 309: 1341+14	0124' FDE1    	                pop iy
 310: 1355+20	0126' FD221B00	                ld (dire), iy           ; Save pointer to directory entry structure
 311:				;
 312:				; *** Examine the directory entry ***
 313:				; IX - pointer to DPB (DPB_xxx)
 314:				; IY - pointer to directory entry structure (DIRE_xxx)
 315: 1375+19	012A' FD7E00  	                ld a, (iy + DIRE_USER)
 316: 1394+7	012D' FEE5    	                cp 0xe5
 317: 1401+7+5	012F' 200A    	                jr nz, sl_not_unused
 318:				; This is an unused entry.
 319: 1408+16	0131' 2A1300  	                ld hl, (unused_count)
 320: 1424+6	0134' 23      	                inc hl
 321: 1430+16	0135' 221300  	                ld (unused_count), hl
 322: 1446+10	0138' C3E502  	                jp sl_entry_done        ; Entry done
 323:				;
 324:				; Calculate physical extent. Adapted from
 325:				; https://www.seasip.info/Cpm/format22.html:
 326:				; An extent is the portion of a file controlled by one directory entry. If a
 327:				; file takes up more blocks than can be listed in one directory entry, it is
 328:				; given multiple entries, distinguished by their EX and S2 bytes.  A logical
 329:				; extent is always 16 KB long, but there can be multiple logical extents in a
 330:				; physical extent (directory entry). This is defined by DPB.EXM. The formula
 331:				; is: directory number (physical extent) = ((32 * S2) + EX) / (exm + 1) where
 332:				; EXM is the extent mask value from the Disc Parameter Block.
 333: 1456+19	013B' FD6E0E  	sl_not_unused   ld l, (iy + DIRE_S2)        ; Extent counter, high byte
 334: 1475+7	013E' 2600    	                ld h, 0
 335: 1482+11	0140' 29      	                add hl, hl
 336: 1493+11	0141' 29      	                add hl, hl
 337: 1504+11	0142' 29      	                add hl, hl
 338: 1515+11	0143' 29      	                add hl, hl
 339: 1526+11	0144' 29      	                add hl, hl
 340:				; HL is (32 * S2)
 341: 1537+19	0145' FD5E0C  	                ld e, (iy + DIRE_EX)    ; Extent counter, low byte (0-31)
 342: 1556+7	0148' 1600    	                ld d, 0
 343: 1563+11	014A' 19      	                add hl, de
 344:				; HL is (32 * S2) + EX
 345: 1574+19	014B' DD4E04  	                ld c, (ix + DPB_EXM)    ; Extent mask
 346:				; A is 0, 1, 3, 7 or 15. We need to divide by one greater than each of these.
 347: 1593+4	014E' 79      	sl_calc_ext_lp  ld a, c
 348: 1597+4	014F' A7      	                and a
 349: 1601+7+5	0150' 2808    	                jr z, sl_calc_ext_dn
 350: 1608+8	0152' CB3C    	                srl h                   ; Divide by two
 351: 1616+8	0154' CB1D    	                rr l
 352: 1624+8	0156' CB39    	                srl c                   ; Reduce mask
 353: 1632+12	0158' 18F4    	                jr sl_calc_ext_lp
 354:				; HL - physical extent
 355: 1644+16	015A' 221700  	sl_calc_ext_dn  ld (phys_extent), hl    ; Save calculated extent
 356:				;
 357:				; Check user number
 358: 1660+10	015D' 11FD08  	                ld de, bad_user_msg     ; " - bad user number"
 359: 1670+19	0160' FD7E00  	                ld a, (iy + DIRE_USER)
 360: 1689+7	0163' FE10    	                cp MAX_USER + 1
 361: 1696+10+7	0165' D4F204  	                call nc, sl_err_cont    ; Report any error and continue
 362:				;
 363:				; Check name. A flag is used to avoid one error message per bad character.
 364: 1706+15	0168' FDE5    	sl_user_ok      push iy
 365: 1721+10	016A' E1      	                pop hl
 366: 1731+10	016B' 010100  	                ld bc, DIRE_NAME
 367: 1741+11	016E' 09      	                add hl, bc
 368:				; HL - start address of name.
 369: 1752+7	016F' 0608    	                ld b, FILENAME_SIZE
 370: 1759+7	0171' 0E00    	                ld c, 0                 ; Error flag
 371: 1766+7	0173' 7E      	sl_name_chk     ld a, (hl)
 372: 1773+7	0174' FE20    	                cp ' '
 373: 1780+10+7	0176' DC4805  	                call c, set_c_reg       ; < ' ' is a control character
 374: 1790+7	0179' FE7F    	                cp ascii_del
 375: 1797+10+7	017B' D44805  	                call nc, set_c_reg      ; >= DEL isn't visible either
 376: 1807+6	017E' 23      	                inc hl
 377: 1813+8+5	017F' 10F2    	                djnz sl_name_chk
 378:				;
 379:				; Check type.
 380: 1821+19	0181' FD7E09  	                ld a, (iy + DIRE_TYP)
 381: 1840+7	0184' E67F    	                and 0x7f                ; Ignore read-only bit
 382: 1847+7	0186' FE20    	                cp ' '
 383: 1854+10+7	0188' DC4805  	                call c, set_c_reg       ; < ' ' is a control character
 384: 1864+7	018B' FE7F    	                cp ascii_del
 385: 1871+10+7	018D' D44805  	                call nc, set_c_reg      ; >= DEL isn't visible either
 386:				;
 387: 1881+19	0190' FD7E0A  	                ld a, (iy + DIRE_TYP + 1)
 388: 1900+7	0193' E67F    	                and 0x7f                ; Ignore system file bit
 389: 1907+7	0195' FE20    	                cp ' '
 390: 1914+10+7	0197' DC4805  	                call c, set_c_reg       ; < ' ' is a control character
 391: 1924+7	019A' FE7F    	                cp ascii_del
 392: 1931+10+7	019C' D44805  	                call nc, set_c_reg      ; >= DEL isn't visible either
 393:				;
 394: 1941+19	019F' FD7E0B  	                ld a, (iy + DIRE_TYP + 2)
 395:				; Bit 7 has no defined meaning for this character.
 396: 1960+7	01A2' FE20    	                cp ' '
 397: 1967+10+7	01A4' DC4805  	                call c, set_c_reg       ; < ' ' is a control character
 398: 1977+7	01A7' FE7F    	                cp ascii_del
 399: 1984+10+7	01A9' D44805  	                call nc, set_c_reg      ; >= DEL isn't visible either
 400:				;
 401:				; Report error if one or more issues were found.
 402: 1994+10	01AC' 111009  	                ld de, bad_name_msg     ; " - bad file name"
 403: 2004+4	01AF' 79      	                ld a, c
 404: 2008+4	01B0' A7      	                and a
 405: 2012+10+7	01B1' C4F204  	                call nz, sl_err_cont    ; Report any error and continue
 406:				;
 407:				; Check extent counter.
 408: 2022+10	01B4' 112109  	                ld de, bad_ex_cnt_msg   ; " - bad extent count"
 409: 2032+19	01B7' FD7E0C  	                ld a, (iy + DIRE_EX)    ; Extent counter, low byte (0-31)
 410: 2051+7	01BA' FE20    	                cp 32
 411: 2058+10+7	01BC' D4F204  	                call nc, sl_err_cont    ; Report any error and continue
 412:				;
 413:				; Check S1.
 414: 2068+10	01BF' 113509  	                ld de, bad_s1_msg       ; " - bad S1"
 415: 2078+19	01C2' FD7E0D  	                ld a, (iy + DIRE_S1)    ; Reserved, set to 0
 416: 2097+4	01C5' A7      	                and a
 417: 2101+10+7	01C6' C4F204  	                call nz, sl_err_cont    ; Report any error and continue
 418:				;
 419:				; *** Look for the file in the file information structure buffer ***
 420: 2111+20	01C9' DD2A0800	                ld ix, (files_info)     ; Start address of FI structures
 421:				; IX - address in files_info structure.
 422: 2131+20	01CD' ED5B0A00	sl_find_loop    ld de, (free_start)     ; First free location
 423: 2151+15	01D1' DDE5    	                push ix
 424: 2166+10	01D3' E1      	                pop hl
 425: 2176+4	01D4' A7      	                and a
 426: 2180+15	01D5' ED52    	                sbc hl, de
 427: 2195+10	01D7' D2F301  	                jp nc, slf_no_match     ; Jump if buffer exhausted
 428:				; There is an entry to examine.
 429: 2205+15	01DA' DDE5    	                push ix
 430: 2220+10	01DC' D1      	                pop de
 431: 2230+15	01DD' FDE5    	                push iy
 432: 2245+10	01DF' E1      	                pop hl
 433:				; DE - pointer to file information structure.
 434:				; HL - pointer to directory entry structure.
 435: 2255+17	01E0' CD7306  	                call match_files
 436:				; Carry flag set if files don't match.
 437: 2272+7+5	01E3' 3049    	                jr nc, slf_found_fi     ; Matching structure found
 438:				;
 439:				; Advance pointer by the length of this structure. We must include the length
 440:				; of the extent flags section (FI_EX_FL_LEN).
 441: 2279+19	01E5' DD5E0F  	                ld e, (ix + FI_EX_FL_LEN)
 442: 2298+7	01E8' 1600    	                ld d, 0
 443:				; DE - extent flags length.
 444: 2305+15	01EA' DD19    	                add ix, de              ; Add length to base
 445: 2320+10	01EC' 111000  	                ld de, FI_SIZE
 446: 2330+15	01EF' DD19    	                add ix, de              ; Add structure size
 447: 2345+12	01F1' 18DA    	                jr sl_find_loop
 448:				;
 449:				; File information structure buffer seach complete and no matching entry was
 450:				; found. Create a new entry.
 451: 2357+16	01F3' 2A0A00  	slf_no_match    ld hl, (free_start)     ; Insert point
 452: 2373+10	01F6' 111000  	                ld de, FI_SIZE          ; Number of bytes required
 453: 2383+17	01F9' CDD905  	                call fi_make_room       ; Make room in the FI structures store
 454: 2400+10	01FC' DADF04  	                jp c, out_of_memory
 455:				;
 456:				; Copy the relevant fields.
 457: 2410+11	01FF' E5      	                push hl
 458: 2421+14	0200' DDE1    	                pop ix
 459: 2435+15	0202' FDE5    	                push iy
 460: 2450+10	0204' D1      	                pop de
 461:				; HL & IX - pointer to file information structure (FI_xxx)
 462:				; DE & IY - pointer to directory entry structure (DIRE_xxx)
 463:				; Copy user number.
 464:     -	0001'         	                assert FI_USER = 0
 465:     -	0001'         	                assert DIRE_USER = 0
 466: 2460+7	0205' 1A      	                ld a, (de)
 467: 2467+7	0206' 77      	                ld (hl), a
 468: 2474+6	0207' 13      	                inc de
 469: 2480+6	0208' 23      	                inc hl
 470:				;
 471:				; Copy filename.
 472:     -	0001'         	                assert FI_NAME = 1
 473:     -	0001'         	                assert DIRE_NAME = 1
 474: 2486+7	0209' 0608    	                ld b, FILENAME_SIZE
 475: 2493+7	020B' 1A      	slf_name_loop   ld a, (de)
 476: 2500+7	020C' 77      	                ld (hl), a
 477: 2507+6	020D' 13      	                inc de
 478: 2513+6	020E' 23      	                inc hl
 479: 2519+8+5	020F' 10FA    	                djnz slf_name_loop
 480:				;
 481:				; Copy type. Ignore read-only and hidden flags.
 482:     -	0001'         	                assert FI_TYP = 9
 483:     -	0001'         	                assert DIRE_TYP = 9
 484: 2527+7	0211' 0603    	                ld b, FILEEXT_SIZE
 485: 2534+7	0213' 1A      	slf_typ_loop    ld a, (de)
 486: 2541+7	0214' E67F    	                and 0x7f
 487: 2548+7	0216' 77      	                ld (hl), a
 488: 2555+6	0217' 13      	                inc de
 489: 2561+6	0218' 23      	                inc hl
 490: 2567+8+5	0219' 10F8    	                djnz slf_typ_loop
 491:				;
 492: 2575+19	021B' DD360F00	                ld (ix + FI_EX_FL_LEN), 0   ; No flags initially
 493: 2594+19	021F' DD360C00	                ld (ix + FI_LAST_PEXT), 0   ; Last extent
 494: 2613+19	0223' DD360D00	                ld (ix + FI_LAST_PEXT + 1), 0   ; Last extent
 495:				;
 496:				; Count new files.
 497: 2632+16	0227' 2A1100  	                ld hl, (file_count)
 498: 2648+6	022A' 23      	                inc hl
 499: 2654+16	022B' 221100  	                ld (file_count), hl
 500:				;
 501:				; Go here after either locating an existing structure, or creating a new one.
 502:				; IX - pointer to file information structure.
 503:				; IY - pointer to directory entry structure (DIRE_xxx)
 504: 2670+20	022E' DD221D00	slf_found_fi    ld (fie), ix            ; Save pointer to file information structure
 505:				; IX - pointer to file information structure (FI_xxx)
 506:				; IY - pointer to directory entry structure (DIRE_xxx)
 507:				;
 508:				; Set the relevant physical extent flag, expanding the length of the extent
 509:				; flags if required.
 510: 2690+16	0232' 2A1700  	                ld hl, (phys_extent)    ; Fetch extent number
 511: 2706+17	0235' CD8005  	                call flag_extent        ; Mark block used
 512: 2723+10	0238' 113F09  	                ld de, ext_dup_msg      ; " - duplicated physical extent"
 513: 2733+10	023B' DAFC02  	                jp c, sl_err_stop       ; Error and stop if already used
 514:				;
 515:				; Mark the blocks used. Entries may be 8 or 16-bit, depending on the number of
 516:				; blocks on the disk.
 517: 2743+20	023E' DD2A1900	slf_ext_done    ld ix, (dpb)
 518: 2763+7	0242' 0E00    	                ld c, 0                 ; Reset flags (ALLCF_xxx) and counter
 519:				; IX - pointer to DPB (DPB_xxx)
 520:				; IY - pointer to directory entry structure (DIRE_xxx)
 521:				; C - flags and counter
 522: 2770+19	0244' DD7E06  	                ld a, (ix + DPB_DSM + 1)    ; Fetch MS byte of DSM
 523: 2789+4	0247' A7      	                and a
 524: 2793+7+5	0248' 2825    	                jr z, slf_bytes         ; Jump if > 255 blocks
 525:				;
 526:				; The maximum block number is >= 256, so the allocation list is in words.
 527: 2800+7	024A' 0608    	                ld b, 8
 528: 2807+19	024C' FD6E10  	slf_wd_alu_lp   ld l, (iy + DIRE_ALLOC) ; Fetch next allocation
 529: 2826+19	024F' FD6611  	                ld h, (iy + DIRE_ALLOC + 1)
 530: 2845+4	0252' 7C      	                ld a, h
 531: 2849+4	0253' B5      	                or l
 532: 2853+7+5	0254' 2004    	                jr nz, slf_wd_alu_used
 533:				; Unused entry.
 534: 2860+8	0256' CBF9    	                set ALLCF_UNUSED_BIT, c ; Flag unused entry found
 535: 2868+12	0258' 180D    	                jr slf_wd_alu_dn
 536:				; Used entry.
 537: 2880+4	025A' 0C      	slf_wd_alu_used inc c                   ; Keep count
 538: 2884+17	025B' CD4B05  	                call flag_block         ; Mark block used
 539: 2901+10	025E' DAFC02  	                jp c, sl_err_stop       ; Error if already used
 540: 2911+8	0261' CB79    	                bit ALLCF_UNUSED_BIT, c
 541: 2919+7+5	0263' 2802    	                jr z, slf_wd_alu_dn     ; Jump if no unused entries encountered
 542:				; This used entry is preceeded by an unused one. This means we have a holed, or
 543:				; "sparse" file.
 544: 2926+8	0265' CBF1    	                set ALLCF_SPARSE_BIT, c ; Hole detected
 545:				;
 546:				; Allocation entry done.
 547: 2934+10	0267' FD23    	slf_wd_alu_dn   inc iy
 548: 2944+10	0269' FD23    	                inc iy
 549: 2954+8+5	026B' 10DF    	                djnz slf_wd_alu_lp
 550: 2962+12	026D' 1820    	                jr slf_alu_dn
 551:				;
 552:				; The maximum block number is < 256, so the allocation list is in bytes.
 553: 2974+7	026F' 0610    	slf_bytes       ld b, 16
 554: 2981+19	0271' FD7E10  	slf_by_alu_lp   ld a, (iy + DIRE_ALLOC) ; Fetch next allocation
 555: 3000+4	0274' A7      	                and a
 556: 3004+7+5	0275' 2004    	                jr nz, slf_by_alu_used
 557:				; Unused entry.
 558: 3011+8	0277' CBF9    	                set ALLCF_UNUSED_BIT, c ; Flag unused entry found
 559: 3019+12	0279' 1810    	                jr slf_by_alu_dn
 560:				; Used entry.
 561: 3031+4	027B' 0C      	slf_by_alu_used inc c                   ; Keep count
 562: 3035+7	027C' 2600    	                ld h, 0
 563: 3042+4	027E' 6F      	                ld l, a
 564: 3046+17	027F' CD4B05  	                call flag_block         ; Mark block used
 565: 3063+10	0282' DAFC02  	                jp c, sl_err_stop       ; Error if already used
 566: 3073+8	0285' CB79    	                bit ALLCF_UNUSED_BIT, c
 567: 3081+7+5	0287' 28DE    	                jr z, slf_wd_alu_dn     ; Jump if no unused entries encountered
 568:				; This used entry is preceeded by an unused one. This means we have a holed, or
 569:				; "sparse" file.
 570: 3088+8	0289' CBF1    	                set ALLCF_SPARSE_BIT, c ; Hole detected
 571:				;
 572:				; Allocation entry done.
 573: 3096+10	028B' FD23    	slf_by_alu_dn   inc iy
 574: 3106+8+5	028D' 10E2    	                djnz slf_by_alu_lp
 575:				;
 576:				; Blocks flagged appropriately.
 577: 3114+20	028F' FD2A1B00	slf_alu_dn      ld iy, (dire)           ; Restore pointer to directory entry structure
 578: 3134+8	0293' CB71    	                bit ALLCF_SPARSE_BIT, c
 579:				; A sparse file (one with a hole) is not necessarily an error, as discussed in
 580:				; http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm function 35 (description).
 581: 3142+10	0295' 117109  	                ld de, sparse_msg       ; " - is sparse (holed) [warning]"
 582: 3152+10+7	0298' C4F204  	                call nz, sl_err_cont    ; Error if hole detected
 583:				;
 584:				; Check for blocks with no allocations at all.
 585: 3162+4	029B' 79      	                ld a, c
 586: 3166+7	029C' E60F    	                and ALLCF_COUNT         ; Isolate count
 587: 3173+10	029E' 11AD09  	                ld de, no_alloc_msg     ; " - no allocations in physical extent [warning]"
 588: 3183+10+7	02A1' CCF204  	                call z, sl_err_cont     ; Error if no allocations
 589:				;
 590:				; Checking record count (RC). This should be 0x80 (128 * 128 = 18 KB) for
 591:				; anything but the last extent. Note that FI_LAST_PEXT could be derived from
 592:				; the bitmap, but it is easier to store it.
 593:				; Note: the illegal case PEXT = FI_LAST_PEXT will be picked up in the extent
 594:				; flagging code.
 595: 3193+20	02A4' DD2A1D00	                ld ix, (fie)            ; Fetch pointer to file information structure
 596:				; IX - pointer to file information structure (FI_xxx)
 597:				; IY - pointer to directory entry structure (DIRE_xxx)
 598: 3213+16	02A8' 2A1700  	                ld hl, (phys_extent)
 599: 3229+19	02AB' DD5E0C  	                ld e, (ix + FI_LAST_PEXT)   ; Last extent
 600: 3248+19	02AE' DD560D  	                ld d, (ix + FI_LAST_PEXT + 1)
 601: 3267+4	02B1' A7      	                and a
 602: 3271+15	02B2' ED52    	                sbc hl, de
 603: 3286+7+5	02B4' 300D    	                jr nc, slfrc_not_last
 604:				; Not the highest extent found so far, so RC should be 0x80.
 605: 3293+19	02B6' FD7E10  	                ld a, (iy + DIRE_ALLOC)
 606: 3312+7	02B9' FE80    	                cp 0x80
 607: 3319+10	02BB' 11DC09  	                ld de, bad_rc_msg       ; " - RC not 0x80 in intermediate extent"
 608: 3329+10+7	02BE' C4F204  	                call nz, sl_err_cont
 609: 3339+12	02C1' 1822    	                jr slfrc_done
 610:				;
 611:				; This is the highest extent encountered so far or it is the first extent
 612:				; encountered (FI_LAST_PEXT = 0).
 613: 3351+19	02C3' DD7E0C  	slfrc_not_last  ld a, (ix + FI_LAST_PEXT)   ; Last extent
 614: 3370+19	02C6' DDB60D  	                or (ix + FI_LAST_PEXT + 1)
 615: 3389+7+5	02C9' 280B    	                jr z, slfrc_update
 616:				;
 617:				; This isn’t the first extent, so the previous one should have RC = 0x80.
 618: 3396+19	02CB' DD7E0E  	                ld a, (ix + FI_LAST_RC)
 619: 3415+7	02CE' FE80    	                cp 0x80
 620: 3422+10	02D0' 11DC09  	                ld de, bad_rc_msg       ; " - RC not 0x80 in intermediate extent"
 621: 3432+10+7	02D3' C4F204  	                call nz, sl_err_cont
 622:				;
 623:				; RC checks complete. Update the FI_LAST_PEXT and FI_LAST_RC fields for next
 624:				; time.
 625: 3442+16	02D6' 2A1700  	slfrc_update    ld hl, (phys_extent)    ; Set FI_LAST_PEXT = PEXTENT
 626: 3458+19	02D9' DD750C  	                ld (ix + FI_LAST_PEXT), l
 627: 3477+19	02DC' DD740D  	                ld (ix + FI_LAST_PEXT + 1), h
 628: 3496+19	02DF' FD7E0F  	                ld a, (iy + DIRE_RC)    ; Set FI_LAST_RC = RC
 629: 3515+19	02E2' DD770E  	                ld (ix + FI_LAST_RC), a
 630:     -	02E5'         	slfrc_done
 631:				;
 632:				; Entry scanned.
 633: 3534+20	02E5' DD2A1900	sl_entry_done   ld ix, (dpb)
 634:				; IX - pointer to DPB (DPB_xxx)
 635:				; IY - pointer to directory entry structure (DIRE_xxx)
 636: 3554+16	02E9' 2A1F00  	                ld hl, (dir_entry_num)  ; Loop counter
 637: 3570+4	02EC' 7D      	                ld a, l
 638: 3574+19	02ED' DDBE07  	                cp (ix + DPB_DRM)       ; Is this the last entry?
 639: 3593+7+5	02F0' 2006    	                jr nz, sl_do_next
 640: 3600+4	02F2' 7C      	                ld a, h
 641: 3604+19	02F3' DDBE08  	                cp (ix + DPB_DRM + 1)
 642: 3623+7+5	02F6' 2809    	                jr z, scan_done
 643: 3630+6	02F8' 23      	sl_do_next      inc hl                  ; Next entry
 644: 3636+10	02F9' C31D01  	                jp scan_loop
 645:				;
 646:				;
 647:				; Error found. Display the entry and an appropriate message, then skip any
 648:				; remaining checks. Call with:
 649:				; DE - pointer to message
 650: 3646+17	02FC' CDF204  	sl_err_stop     call sl_err_cont
 651: 3663+12	02FF' 18E4    	                jr sl_entry_done
 652:				;
 653:				;
 654:				; *** Check for missing extents ***
 655:				; All directory entries scanned. Examine each file in files_info, ensuring
 656:				; there are no missing extents. This is different from the previous sparse
 657:				; check, as this looks for missing allocations within each physical extent.
 658: 3675+20	0301' FD2A0800	scan_done       ld iy, (files_info)
 659: 3695+20	0305' ED5B0A00	spck_loop       ld de, (free_start)     ; First free location
 660: 3715+15	0309' FDE5    	                push iy
 661: 3730+10	030B' E1      	                pop hl
 662: 3740+4	030C' A7      	                and a
 663: 3744+15	030D' ED52    	                sbc hl, de
 664: 3759+10	030F' D25F03  	                jp nc, spck_done        ; Jump if buffer exhausted
 665:				;
 666:				; There is an entry to examine. All extries except the last one should be 0xff.
 667:				; The last should consist of zero or more "1" bits extending from the LS end
 668:				; with no gaps.
 669: 3769+15	0312' FDE5    	                push iy
 670: 3784+10	0314' E1      	                pop hl
 671: 3794+10	0315' 111000  	                ld de, FI_EX_FLAGS
 672: 3804+11	0318' 19      	                add hl, de
 673:				; HL - pointer to first extent flag byte.
 674: 3815+19	0319' FD7E0F  	                ld a, (iy + FI_EX_FL_LEN)
 675: 3834+4	031C' A7      	                and a
 676: 3838+7+5	031D' 2009    	                jr nz, spck_not_empty
 677:				;
 678: 3845+10	031F' 11020A  	                ld de, empty_msg        ; " - has no data"
 679: 3855+17	0322' CD1005  	                call spck_error         ; Error if no extents at all
 680: 3872+10	0325' C35103  	                jp spck_file_done
 681:				;
 682:				; File as at least one extent.
 683: 3882+4	0328' 4F      	spck_not_empty  ld c, a
 684: 3886+7	0329' 0600    	                ld b, 0                 ; Error flag
 685:				;
 686:				; B - sparse flag (zero if OK)
 687:				; C - length remaining
 688:				; HL - pointer to extent flag byte
 689:				; IY - pointer to files_info entry (FI_xxx)
 690: 3893+4	032B' 79      	spck_byte_loop  ld a, c
 691: 3897+7	032C' FE01    	                cp 1
 692: 3904+7+5	032E' 280B    	                jr z, spck_last_byte
 693:				; Not the last byte.
 694: 3911+7	0330' 7E      	                ld a, (hl)
 695: 3918+7	0331' FEFF    	                cp 0xff
 696: 3925+7+5	0333' 2802    	                jr z, spck_byte_ok
 697:				; We have encountered a hole.
 698: 3932+7	0335' 0601    	spck_sp_err     ld b, 1                 ; Flag sparseness
 699: 3939+6	0337' 23      	spck_byte_ok    inc hl
 700: 3945+4	0338' 0D      	                dec c
 701: 3949+12	0339' 18F0    	                jr spck_byte_loop
 702:				;
 703:				; Process the last byte. This should not be zero, as flag bytes are only
 704:				; created when required to flag an extent.
 705: 3961+7	033B' 7E      	spck_last_byte  ld a, (hl)
 706: 3968+4	033C' A7      	                and a
 707: 3972+10+7	033D' CC0000  	                call z, panic           ; Panic if flag is all zeroes
 708: 3982+4	0340' 4F      	                ld c, a
 709:				; Keep shifting until no "1" bit falls off the end.
 710: 3986+8	0341' CB39    	spck_bit_loop   srl c                   ; Shift LS bit to carry
 711: 3994+7+5	0343' 38FC    	                jr c, spck_bit_loop
 712:				; The result should be zero.
 713: 4001+7+5	0345' 2802    	                jr z, spck_last_ok
 714: 4008+7	0347' 0601    	                ld b, 1                 ; Flag sparseness
 715:				;
 716:				; File checks complete.
 717:				; B - sparse flag (zero if OK)
 718: 4015+4	0349' 78      	spck_last_ok    ld a, b
 719: 4019+4	034A' A7      	                and a
 720: 4023+10	034B' 117109  	                ld de, sparse_msg       ; " - is sparse (holed) [warning]"
 721: 4033+10+7	034E' C41005  	                call nz, spck_error     ; Error if hole detected
 722:				;
 723:				; Advance pointer by the length of this structure. We must include the length
 724:				; of the extent flags section (FI_EX_FL_LEN).
 725: 4043+19	0351' FD5E0F  	spck_file_done  ld e, (iy + FI_EX_FL_LEN)
 726: 4062+7	0354' 1600    	                ld d, 0
 727:				; DE - extent flags length.
 728: 4069+15	0356' FD19    	                add iy, de              ; Add length to base
 729: 4084+10	0358' 111000  	                ld de, FI_SIZE
 730: 4094+15	035B' FD19    	                add iy, de              ; Add structure size
 731: 4109+12	035D' 18A6    	                jr spck_loop
 732:				;
 733:				;
 734:				; All checks complete.
 735: 4121+20	035F' DD2A1900	spck_done       ld ix, (dpb)
 736:				; IX - pointer to DPB (DPB_xxx)
 737:				;
 738: 4141+10	0363' 21E807  	                ld hl, dir_done_msg     ; "Directory checks complete"
 739: 4151+17	0366' CD0000  	                call conwms             ; Print $-terminated string to console
 740:				;
 741: 4168+10	0369' 217608  	                ld hl, errors_msg       ; "Errors and warnings: "
 742: 4178+17	036C' CD0000  	                call conwms             ; Print $-terminated string to console
 743: 4195+16	036F' 2A0F00  	                ld hl, (error_count)
 744: 4211+17	0372' CD0000  	                call cwpdwd             ; Print HL in decimal
 745: 4228+17	0375' CD0000  	                call cwnwln             ; Write new line characters to console
 746:				;
 747: 4245+10	0378' 210408  	                ld hl, files_msg        ; "Files found: "
 748: 4255+17	037B' CD0000  	                call conwms             ; Print $-terminated string to console
 749: 4272+16	037E' 2A1100  	                ld hl, (file_count)
 750: 4288+17	0381' CD0000  	                call cwpdwd             ; Print HL in decimal
 751: 4305+17	0384' CD0000  	                call cwnwln             ; Write new line characters to console
 752:				;
 753: 4322+10	0387' 211208  	                ld hl, unused_msg        ; "Unused directory entries: "
 754: 4332+17	038A' CD0000  	                call conwms             ; Print $-terminated string to console
 755: 4349+16	038D' 2A1300  	                ld hl, (unused_count)
 756: 4365+17	0390' CD0000  	                call cwpdwd             ; Print HL in decimal
 757: 4382+17	0393' CD0000  	                call cwnwln             ; Write new line characters to console
 758:				;
 759: 4399+10	0396' 212D08  	                ld hl, blocks_used_msg  ; "Blocks used: "
 760: 4409+17	0399' CD0000  	                call conwms             ; Print $-terminated string to console
 761: 4426+16	039C' 2A1500  	                ld hl, (blocks_used)
 762: 4442+17	039F' CD0000  	                call cwpdwd             ; Print HL in decimal
 763: 4459+17	03A2' CD0000  	                call cwnwln             ; Write new line characters to console
 764:				;
 765:				;
 766:				; *** Display block usage map ***
 767:				; Blocks go from 0 to DPB.DSM. Scale this to the display. Scaling will be one
 768:				; block per character, unless this won't fit in a reasonable space. In that
 769:				; case, the scaling is progressively halved until it does fit.
 770: 4476+10	03A5' 213B08  	                ld hl, block_map_msg    ; "Block map ..."
 771: 4486+17	03A8' CD0000  	                call conwms             ; Print $-terminated string to console
 772:				;
 773: 4503+7	03AB' 0E00    	                ld c, 0                 ; Initial shift (scaling)
 774: 4510+7	03AD' 0601    	                ld b, 1                 ; Scale factor
 775:				; Scaling loop.
 776: 4517+19	03AF' DD6E05  	bdis_scale_loop ld l, (ix + DPB_DSM)    ; Maximum block number
 777: 4536+19	03B2' DD6606  	                ld h, (ix + DPB_DSM + 1)
 778: 4555+6	03B5' 23      	                inc hl
 779:				; HL - total number of blocks
 780: 4561+11	03B6' C5      	                push bc
 781: 4572+17	03B7' CD3E05  	                call rshift_word        ; Shift HL >> C
 782: 4589+10	03BA' C1      	                pop bc
 783: 4599+10	03BB' 11C003  	                ld de, BDIS_CHARS_MAX
 784: 4609+4	03BE' A7      	                and a
 785: 4613+15	03BF' ED52    	                sbc hl, de
 786: 4628+7+5	03C1' 3809    	                jr c, bdis_scale_done   ; Jump if scaling OK
 787:				; Halve size
 788: 4635+4	03C3' 0C      	                inc c                   ; One more shift
 789: 4639+4	03C4' A7      	                and a
 790: 4643+8	03C5' CB10    	                rl b                    ; Double scale
 791: 4651+10+7	03C7' DC0000  	                call c, panic           ; Panic on overflow
 792: 4661+12	03CA' 18E3    	                jr bdis_scale_loop
 793:				;
 794: 4673+4	03CC' 79      	bdis_scale_done ld a, c
 795: 4677+13	03CD' 322100  	                ld (bdis_shift), a      ; Set shift (scaling)
 796: 4690+4	03D0' 78      	                ld a, b
 797: 4694+13	03D1' 322200  	                ld (bdis_scale), a      ; Set scale
 798:				;;
 799:				; Display loop.
 800: 4707+10	03D4' 210000  	                ld hl, 0                ; Start at first block
 801: 4717+4	03D7' AF      	                xor a
 802: 4721+13	03D8' 322300  	                ld (bdis_s_count), a    ; Scale counter
 803: 4734+13	03DB' 322400  	                ld (bdis_col), a        ; Display column
 804: 4747+7	03DE' 062D    	                ld b, "-"               ; Default character
 805:				; B - character
 806:				; HL - block number
 807:				; Is this a directory block?
 808: 4754+4	03E0' 7C      	bdis_loop       ld a, h
 809: 4758+4	03E1' A7      	                and a
 810: 4762+7+5	03E2' 200D    	                jr nz, bdis_not_dir     ; Not a directory block
 811: 4769+13	03E4' 3A0E00  	                ld a, (dir_blocks)      ; Number of blocks used by the directory
 812: 4782+4	03E7' 5F      	                ld e, a
 813: 4786+4	03E8' 7D      	                ld a, l
 814: 4790+4	03E9' BB      	                cp e
 815: 4794+7+5	03EA' 3005    	                jr nc, bdis_not_dir     ; Not a directory block
 816:				; This is a directory block.
 817: 4801+7	03EC' 3E44    	                ld a, "D"
 818: 4808+4	03EE' 47      	                ld b, a
 819: 4812+12	03EF' 1810    	                jr bdis_blk_done
 820:				;
 821:				; Not a directory block. Is this block allocated?
 822: 4824+11	03F1' E5      	bdis_not_dir    push hl                 ; Save block number
 823: 4835+20	03F2' ED5B0400	                ld de, (blk_flags)      ; Base address of bit map
 824: 4855+17	03F6' CD2605  	                call BitAddrMask        ; Find address and mask
 825:				; A – bit mask (one bit set)
 826:				; HL – address
 827: 4872+7	03F9' 5E      	                ld e, (hl)
 828: 4879+10	03FA' E1      	                pop hl                  ; Restore block number
 829: 4889+4	03FB' A3      	                and e
 830: 4893+7+5	03FC' 2803    	                jr z, bdis_blk_done     ; Jump if unused
 831:				;
 832:				; This is a file block
 833: 4900+7	03FE' 3E46    	                ld a, "F"
 834: 4907+4	0400' 47      	                ld b, a
 835:				;
 836:				; Block processing complete. Have we reached the end of the displayed
 837:				; character?
 838: 4911+13	0401' 3A2300  	bdis_blk_done   ld a, (bdis_s_count)    ; Scale (block) counter
 839: 4924+4	0404' 3C      	                inc a
 840: 4928+4	0405' 4F      	                ld c, a
 841: 4932+13	0406' 3A2200  	                ld a, (bdis_scale)      ; Scale (n:1)
 842: 4945+4	0409' B9      	                cp c
 843: 4949+7+5	040A' 2017    	                jr nz, bdis_entry_done
 844:				;
 845:				; Display the character.
 846: 4956+4	040C' 78      	                ld a, b
 847: 4960+17	040D' CD0000  	                call conwch             ; Write character to console
 848: 4977+7	0410' 062D    	                ld b, "-"               ; Default character
 849:				;
 850:				; Update display column and start a newline if required.
 851: 4984+13	0412' 3A2400  	                ld a, (bdis_col)
 852: 4997+4	0415' 3C      	                inc a
 853: 5001+7	0416' FE50    	                cp VT100_COLS           ; Assume a VT-100 for this purpose
 854: 5008+7+5	0418' 3804    	                jr c, bdis_col_done
 855:				; We are at the end of the line.
 856: 5015+17	041A' CD0000  	                call cwnwln             ; Write new line characters to console
 857: 5032+4	041D' AF      	                xor a
 858: 5036+13	041E' 322400  	bdis_col_done   ld (bdis_col), a        ; Save updated column
 859: 5049+7	0421' 0E00    	                ld c, 0                 ; Reset scale divider
 860:				;
 861:				; C - scale (block) counter
 862:				; HL - block number
 863:				; IX - pointer to DPB (DPB_xxx)
 864: 5056+4	0423' 79      	bdis_entry_done ld a, c
 865: 5060+13	0424' 322300  	                ld (bdis_s_count), a    ; Save updated scale (block) counter
 866: 5073+6	0427' 23      	                inc hl                  ; Next block
 867: 5079+19	0428' DD5E05  	                ld e, (ix + DPB_DSM)    ; Maximum block number
 868: 5098+19	042B' DD5606  	                ld d, (ix + DPB_DSM + 1)
 869: 5117+6	042E' 13      	                inc de
 870:				; DE - total number of blocks
 871: 5123+11	042F' E5      	                push hl
 872: 5134+4	0430' A7      	                and a
 873: 5138+15	0431' ED52    	                sbc hl, de
 874: 5153+10	0433' E1      	                pop hl
 875: 5163+7+5	0434' 38AA    	                jr c, bdis_loop
 876: 5170+17	0436' CD0000  	                call cwnwln             ; Write new line characters to console
 877:				;
 878:				; Should we perform the surface scan?
 879: 5187+13	0439' 3A0300  	                ld a, (scan_enable)     ; Surface scan enable flag
 880: 5200+4	043C' A7      	                and a
 881: 5204+7+5	043D' 2006    	                jr nz, surface_scan
 882: 5211+10	043F' 218C08  	                ld hl, no_ss_msg        ; "Surface scan skipped ..."
 883: 5221+10	0442' C3E204  	                jp msg_exit
 884:				;
 885:				;
 886:				; *** Surface scan ***
 887:				; Read every block to ensure that they are readable. The reserved (system) area
 888:				; is not read, as this may have a different geometry to the files area and this
 889:				; may cause trouble. Blocks extend from 0 (the beginning of the directory) to
 890:				; DPB.DSM. Each block consists of DPB.BLM + 1 sectors. Alternatively, shifting
 891:				; the number of blocks by DPB.BSH gives the number of sectors.
 892: 5231+10	0445' 21A308  	surface_scan    ld hl, surf_scan_msg    ; "Checking all blocks are readable (surface scan)"
 893: 5241+17	0448' CD0000  	                call conwms             ; Print $-terminated string to console
 894:				; Find number of sectors in file system.
 895: 5258+19	044B' DD5E05  	                ld e, (ix + DPB_DSM)    ; Maximum block number
 896: 5277+19	044E' DD5606  	                ld d, (ix + DPB_DSM + 1)
 897: 5296+6	0451' 13      	                inc de
 898: 5302+7	0452' 0E00    	                ld c, 0                 ; Extend to 24 bits
 899:				; CDE - number of blocks
 900: 5309+19	0454' DD4602  	                ld b, (ix + DPB_BSH)    ; Block shift factor
 901:				; Valid BSH values are 3 to 7.
 902: 5328+8	0457' CB23    	ss_find_sec_lp  sla e
 903: 5336+8	0459' CB12    	                rl d
 904: 5344+8	045B' CB11    	                rl c
 905: 5352+10+7	045D' DC0000  	                call c, panic           ; Panic on overflow
 906: 5362+8+5	0460' 10F5    	                djnz ss_find_sec_lp
 907:				; CDE - number of sectors in file system area (does not include reserved
 908:				; (system) area.
 909: 5370+10	0462' 212C00  	                ld hl, total_sectors    ; Number of sectors in file system
 910: 5380+7	0465' 73      	                ld (hl), e
 911: 5387+6	0466' 23      	                inc hl
 912: 5393+7	0467' 72      	                ld (hl), d
 913: 5400+6	0468' 23      	                inc hl
 914: 5406+7	0469' 71      	                ld (hl), c
 915:				;
 916:				; All blocks are read, including the directory blocks processed earlier. It
 917:				; seems easier this way.
 918: 5413+10	046A' 21FFFF  	                ld hl, 0xffff
 919: 5423+16	046D' 222800  	                ld (disp_track), hl     ; Force display of first track
 920: 5439+10	0470' 110000  	                ld de, 0                ; Set initial sector
 921: 5449+7	0473' 0E00    	                ld c, 0
 922: 5456+11	0475' D5      	ss_loop         push de                 ; Save sector
 923: 5467+11	0476' C5      	                push bc
 924:				; CDE - CP/M (128-byte) sector number (offset into data area)
 925: 5478+17	0477' CDE006  	                call set_sector
 926:				;
 927:				; Display the track if it has changed. This is to avoid repeatedly writing the
 928:				; same track number, as this slows the scan greatly.
 929: 5495+16	047A' 2A2600  	                ld hl, (track)
 930: 5511+20	047D' ED5B2800	                ld de, (disp_track)
 931: 5531+4	0481' 7D      	                ld a, l
 932: 5535+4	0482' BB      	                cp e
 933: 5539+7+5	0483' 2004    	                jr nz, ss_disp_track    ; Jump on mismatch
 934: 5546+4	0485' 7C      	                ld a, h
 935: 5550+4	0486' BA      	                cp d
 936: 5554+7+5	0487' 280E    	                jr z, ss_nodisp         ; Jump match
 937: 5561+11	0489' E5      	ss_disp_track   push hl                 ; Save track
 938: 5572+10	048A' 21D708  	                ld hl, track_msg        ; "<CR>Track: "
 939: 5582+17	048D' CD0000  	                call conwms             ; Print $-terminated string to console
 940: 5599+10	0490' E1      	                pop hl
 941: 5609+16	0491' 222800  	                ld (disp_track), hl     ; Save for next time
 942: 5625+17	0494' CD0000  	                call cwpdwd             ; Print HL in decimal
 943:				;
 944:				; Read the sector.
 945: 5642+10	0497' 212400  	ss_nodisp       ld hl, BIOS_READ        ; Read a sector
 946: 5652+17	049A' CD0000  	                call cbios              ; Call BIOS with some registers saved
 947: 5669+4	049D' A7      	                and a
 948: 5673+7+5	049E' 2815    	                jr z, ss_sec_done
 949:				; I/O error!
 950: 5680+10	04A0' 21E008  	                ld hl, sector_msg       ; ", sector: "
 951: 5690+17	04A3' CD0000  	                call conwms             ; Print $-terminated string to console
 952: 5707+16	04A6' 2A2A00  	                ld hl, (sector)
 953: 5723+17	04A9' CD0000  	                call cwpdwd             ; Print HL in decimal
 954:				;
 955: 5740+17	04AC' CD0000  	                call cwpspc             ; Print a space
 956: 5757+10	04AF' 21D607  	                ld hl, disk_err_msg     ; "Disk I/O error."
 957: 5767+17	04B2' CD0000  	                call conwms             ; Print $-terminated string to console
 958:				; This message ends in a CR / LF sequence, so it will remain visible.
 959:				;
 960:				; Sector done. Write a carriage return only, so the next message will overwrite
 961:				; the current one except after an error.
 962: 5784+10	04B5' C1      	ss_sec_done     pop bc
 963: 5794+10	04B6' D1      	                pop de
 964:				; Find next sector (in CDE).
 965: 5804+4	04B7' 7B      	                ld a, e
 966: 5808+7	04B8' C601    	                add 1
 967: 5815+4	04BA' 5F      	                ld e, a
 968: 5819+4	04BB' 7A      	                ld a, d
 969: 5823+7	04BC' CE00    	                adc 0                   ; Propagate carry
 970: 5830+4	04BE' 57      	                ld d, a
 971: 5834+4	04BF' 79      	                ld a, c
 972: 5838+7	04C0' CE00    	                adc 0
 973: 5845+4	04C2' 4F      	                ld c, a
 974: 5849+10+7	04C3' DC0000  	                call c, panic           ; Panic on overflow
 975:				;
 976:				; Is there more to do?
 977: 5859+10	04C6' 212C00  	                ld hl, total_sectors    ; Number of sectors in file system
 978: 5869+4	04C9' 7B      	                ld a, e
 979: 5873+7	04CA' BE      	                cp (hl)
 980: 5880+7+5	04CB' 20A8    	                jr nz, ss_loop
 981: 5887+6	04CD' 23      	                inc hl
 982: 5893+4	04CE' 7A      	                ld a, d
 983: 5897+7	04CF' BE      	                cp (hl)
 984: 5904+7+5	04D0' 20A3    	                jr nz, ss_loop
 985: 5911+6	04D2' 23      	                inc hl
 986: 5917+4	04D3' 79      	                ld a, c
 987: 5921+7	04D4' BE      	                cp (hl)
 988: 5928+7+5	04D5' 209E    	                jr nz, ss_loop
 989:				;
 990: 5935+10	04D7' 21EB08  	                ld hl, scan_done_msg    ; "Scan complete"
 991: 5945+17	04DA' CD0000  	                call conwms             ; Print $-terminated string to console
 992:				;
 993: 5962+12	04DD' 1806    	                jr exit
 994:				;
 995: 5974+10	04DF' 21AA07  	out_of_memory   ld hl, memory_msg       ; "Insufficient memory"
 996:				;
 997:				; Print message pointed to by HL, then exit.
 998: 5984+17	04E2' CD0000  	msg_exit        call conwms             ; Print $-terminated string to console
 999:				;
1000:				; Return to CP/M.
1001: 6001+10	04E5' 219507  	exit            ld hl, exit_msg         ; "Returning to CP/M."
1002: 6011+17	04E8' CD0000  	                call conwms             ; Print $-terminated string to console
1003: 6028+20	04EB' ED7B0000	                ld sp, (bdos_sp)
1004:				; For this application a warm boot is required as we may have overwritten the
1005:				; CCP.
1006:				;                ret                     ; Return to BDOS
1007: 6048+10	04EF' C30000  	                jp 0                    ; Warm boot
1008:				;
1009:				;
1010:				;
1011:				; ***************
1012:				; * Subroutines *
1013:				; ***************
1014:				;
1015:				;
1016:				; Error found during directory scan. Display the entry and an appropriate
1017:				; message, then return to continue checking. Call with:
1018:				; DE - pointer to message
1019: 6058+11	04F2' D5      	sl_err_cont     push de
1020: 6069+11	04F3' E5      	                push hl
1021: 6080+15	04F4' FDE5    	                push iy
1022:				;
1023: 6095+20	04F6' FD2A1B00	                ld iy, (dire)           ; Pointer to directory entry structure
1024: 6115+17	04FA' CD3706  	                call disp_file          ; Display filename etc.
1025: 6132+4	04FD' EB      	                ex de, hl
1026: 6136+17	04FE' CD0000  	                call conwms             ; Print $-terminated string to console
1027: 6153+17	0501' CD0000  	                call cwnwln             ; Write new line characters to console
1028:				;
1029: 6170+16	0504' 2A0F00  	                ld hl, (error_count)
1030: 6186+6	0507' 23      	                inc hl
1031: 6192+16	0508' 220F00  	                ld (error_count), hl
1032:				;
1033: 6208+14	050B' FDE1    	                pop iy
1034: 6222+10	050D' E1      	                pop hl
1035: 6232+10	050E' D1      	                pop de
1036: 6242+10	050F' C9      	                ret
1037:				;
1038:				;
1039:				; Error found during files infomation structure scan. Display the entry and an
1040:				; appropriate message, then return to continue checking. Call with:
1041:				; DE - pointer to message
1042:				; IY - pointer to files_info entry (FI_xxx)
1043: 6252+11	0510' D5      	spck_error      push de
1044: 6263+11	0511' E5      	                push hl
1045:				;
1046: 6274+17	0512' CD3706  	                call disp_file          ; Display filename etc.
1047: 6291+4	0515' EB      	                ex de, hl
1048: 6295+17	0516' CD0000  	                call conwms             ; Print $-terminated string to console
1049: 6312+17	0519' CD0000  	                call cwnwln             ; Write new line characters to console
1050:				;
1051: 6329+16	051C' 2A0F00  	                ld hl, (error_count)
1052: 6345+6	051F' 23      	                inc hl
1053: 6351+16	0520' 220F00  	                ld (error_count), hl
1054:				;
1055: 6367+10	0523' E1      	                pop hl
1056: 6377+10	0524' D1      	                pop de
1057: 6387+10	0525' C9      	                ret
1058:				;
1059:				;
1060:				; Find address and mask in a bit mapped array. Call with:
1061:				; DE - base address
1062:				; HL – bit address
1063:				; Returns with:
1064:				; A – bit mask (one bit set)
1065:				; HL – address
1066: 6397+11	0526' C5      	BitAddrMask     push bc
1067:				;
1068:				; Find bit mask.
1069: 6408+4	0527' 7D      	                ld a, l
1070: 6412+7	0528' E607    	                and 7
1071: 6419+4	052A' 3C      	                inc a                   ; Make range 1 to 8
1072: 6423+4	052B' 47      	                ld b, a
1073: 6427+7	052C' 0E80    	                ld c, 0x80
1074: 6434+8	052E' CB01    	bam_mask_loop   rlc c
1075: 6442+8+5	0530' 10FC    	                djnz bam_mask_loop
1076:				;
1077:				; Find byte offset.
1078: 6450+7	0532' 0603    	                ld b, 3
1079: 6457+8	0534' CB3C    	bam_div_loop    srl h                   ; Divide by two
1080: 6465+8	0536' CB1D    	                rr l
1081: 6473+8+5	0538' 10FA    	                djnz bam_div_loop
1082:				;
1083:				; DE – bit address
1084:				; HL - byte offset
1085:				; C - bit mask
1086: 6481+11	053A' 19      	                add hl, de              ; Add base address
1087: 6492+4	053B' 79      	                ld a, c                 ; bit mask
1088:				;
1089: 6496+10	053C' C1      	                pop bc
1090: 6506+10	053D' C9      	                ret
1091:				;
1092:				;
1093:				; Shift a 16-bit value by a number of bits, which can be zero (Shift HL >> C).
1094:				; Call with:
1095:				; C - displacement
1096:				; HL - value
1097:				; Returns with:
1098:				; HL - displaced value
1099: 6516+4	053E' 79      	rshift_word     ld a, c
1100: 6520+4	053F' A7      	rshw_loop       and a
1101: 6524+5+6	0540' C8      	                ret z                   ; Return if complete
1102: 6529+8	0541' CB3C    	                srl h                   ; Divide by two
1103: 6537+8	0543' CB1D    	                rr l
1104: 6545+4	0545' 3D      	                dec a
1105: 6549+12	0546' 18F7    	                jr rshw_loop
1106:				;
1107:				;
1108:				; Set C to non-zero. This provides a conditional flagging mechanism for use
1109:				; when error checking. For example, "call c, set_c_reg".
1110: 6561+7	0548' 0EFF    	set_c_reg       ld c, 0xff
1111: 6568+10	054A' C9      	                ret
1112:				;
1113:				;
1114:				; Mark block as used. Call with:
1115:				; HL - block number (0 to DSM).
1116:				; IX - pointer to DPB (DPB_xxx)
1117:				; Returns with:
1118:				; Carry clear if all went well. Carry will be set if there was an error.
1119:				; DE - points to an appropriate error message if there was an error.
1120: 6578+11	054B' C5      	flag_block      push bc
1121: 6589+11	054C' D5      	                push de
1122:				;
1123:				; Check DE is within range.
1124: 6600+11	054D' E5      	                push hl
1125: 6611+19	054E' DD5E05  	                ld e, (ix + DPB_DSM)    ; Maximum block number
1126: 6630+19	0551' DD5606  	                ld d, (ix + DPB_DSM + 1)
1127: 6649+6	0554' 13      	                inc de
1128: 6655+4	0555' A7      	                and a
1129: 6659+15	0556' ED52    	                sbc hl, de
1130: 6674+10	0558' E1      	                pop hl                  ; Restore block number
1131: 6684+10	0559' 119009  	                ld de, blk_too_big_msg  ; " - block number out of range"
1132: 6694+7+5	055C' 301D    	                jr nc, fb_error
1133:				;
1134:				; Block number is OK. Find bit mask.
1135: 6701+20	055E' ED5B0400	                ld de, (blk_flags)      ; Start of blocks used flags
1136: 6721+17	0562' CD2605  	                call BitAddrMask        ; Find address and mask
1137:				; A – bit mask (one bit set)
1138:				; HL – address
1139:				; Is the flag already set?
1140: 6738+4	0565' 4F      	                ld c, a
1141: 6742+7	0566' 7E      	                ld a, (hl)
1142: 6749+4	0567' A1      	                and c
1143: 6753+10	0568' 115D09  	                ld de, dble_blk_msg     ; " - block not unique"
1144: 6763+7+5	056B' 200E    	                jr nz, fb_error
1145:				; No duplicate found, so set the bit.
1146: 6770+7	056D' 7E      	                ld a, (hl)
1147: 6777+4	056E' B1      	                or c
1148: 6781+7	056F' 77      	                ld (hl), a
1149:				;
1150: 6788+16	0570' 2A1500  	                ld hl, (blocks_used)    ; Increment count
1151: 6804+6	0573' 23      	                inc hl
1152: 6810+16	0574' 221500  	                ld (blocks_used), hl
1153:				;
1154:				; Normal exit with carry reset.
1155: 6826+10	0577' D1      	                pop de
1156: 6836+10	0578' C1      	                pop bc
1157: 6846+4	0579' A7      	                and a
1158: 6850+10	057A' C9      	                ret
1159:				;
1160:				; Return with carry set and message pointer in DE.
1161: 6860+6	057B' 33      	fb_error        inc sp                  ; Discard DE on stack
1162: 6866+6	057C' 33      	                inc sp
1163: 6872+10	057D' C1      	                pop bc
1164: 6882+4	057E' 37      	                scf
1165: 6886+10	057F' C9      	                ret
1166:				;
1167:				;
1168:				; Mark physical extent found in FI structure. The flags space will be extended
1169:				; if required. Call with:
1170:				; HL - physical extent number (0 to 511).
1171:				; IX - pointer to file information structure (FI_xxx)
1172:				; Returns with carry set if extent flag was already set.
1173: 6896+11	0580' C5      	flag_extent     push bc
1174: 6907+11	0581' D5      	                push de
1175:				;
1176: 6918+10	0582' 110000  	                ld de, 0                ; No offset
1177: 6928+17	0585' CD2605  	                call BitAddrMask        ; Find address and mask
1178: 6945+4	0588' 4F      	                ld c, a
1179:				; HL - byte offset
1180:				; C - bit mask
1181:				; Offset should be < FI_EX_FL_LEN, or we will have to make more space.
1182: 6949+11	0589' E5      	                push hl
1183: 6960+19	058A' DD5E0F  	                ld e, (ix + FI_EX_FL_LEN)
1184: 6979+7	058D' 1600    	                ld d, 0
1185: 6986+4	058F' A7      	                and a
1186: 6990+15	0590' ED52    	                sbc hl, de
1187: 7005+7+5	0592' 3822    	                jr c, fe_have_space
1188:				;
1189:				; Make room in the FI structures store.
1190: 7012+4	0594' EB      	                ex de, hl
1191: 7016+6	0595' 13      	                inc de
1192:				; DE - number of bytes required
1193: 7022+15	0596' DDE5    	                push ix                 ; Structure base
1194: 7037+10	0598' E1      	                pop hl
1195: 7047+11	0599' C5      	                push bc                 ; Save bit mask
1196: 7058+10	059A' 011000  	                ld bc, FI_EX_FLAGS      ; Offset to flags
1197: 7068+11	059D' 09      	                add hl, bc              ; Add byte offset
1198: 7079+19	059E' DD4E0F  	                ld c, (ix + FI_EX_FL_LEN)
1199: 7098+7	05A1' 0600    	                ld b, 0
1200: 7105+11	05A3' 09      	                add hl, bc              ; Add length
1201:				; BC - current length.
1202:				; DE - number of bytes required.
1203:				; HL - pointer to byte after last FI_EX_FLAGS byte.
1204: 7116+11	05A4' D5      	                push de
1205: 7127+17	05A5' CDD905  	                call fi_make_room
1206: 7144+10	05A8' DADF04  	                jp c, out_of_memory
1207:				; Adjust length by number of bytes extended.
1208: 7154+10	05AB' E1      	                pop hl
1209:				; BC - current length.
1210:				; HL - number of bytes required.
1211: 7164+11	05AC' 09      	                add hl, bc
1212: 7175+19	05AD' DD750F  	                ld (ix + FI_EX_FL_LEN), l
1213: 7194+4	05B0' 7C      	                ld a, h
1214: 7198+4	05B1' A7      	                and a
1215: 7202+10+7	05B2' C40000  	                call nz, panic          ; Panic at absurd lengths
1216: 7212+10	05B5' C1      	                pop bc                  ; Restore bit mask
1217:				;
1218:				; There is space in the buffer.
1219:				; C - bit mask
1220: 7222+10	05B6' E1      	fe_have_space   pop hl                  ; Fetch byte offset
1221: 7232+10	05B7' 111000  	                ld de, FI_EX_FLAGS      ; Offset to flags
1222: 7242+11	05BA' 19      	                add hl, de              ; Add byte offset
1223: 7253+15	05BB' DDE5    	                push ix
1224: 7268+10	05BD' D1      	                pop de
1225: 7278+11	05BE' 19      	                add hl, de              ; Add structure base
1226:				; Is the bit already set?
1227: 7289+7	05BF' 7E      	                ld a, (hl)
1228: 7296+4	05C0' A1      	                and c
1229: 7300+7+5	05C1' 2005    	                jr nz, fe_dup_err
1230:				; No duplicate found, so set the bit.
1231: 7307+7	05C3' 7E      	                ld a, (hl)
1232: 7314+4	05C4' B1      	                or c
1233: 7318+7	05C5' 77      	                ld (hl), a
1234: 7325+12	05C6' 1801    	                jr fe_exit              ; Exit with carry reset
1235:				;
1236:				; Extent flag is already set, so we have a duplicate.
1237: 7337+4	05C8' 37      	fe_dup_err      scf                     ; Flag error
1238: 7341+10	05C9' D1      	fe_exit         pop de
1239: 7351+10	05CA' C1      	                pop bc
1240: 7361+10	05CB' C9      	                ret
1241:				;
1242:				;
1243:				; Check pointer is lower than the start of BDOS so we don't overwrite CP/M.
1244:				; Call with:
1245:				; HL - address to be checked.
1246:				; Returns with:
1247:				; Carry flag set if HL >= start of BDOS.
1248:				; HL is preserved.
1249: 7371+11	05CC' E5      	chk_mem_lim     push hl
1250: 7382+11	05CD' D5      	                push de
1251: 7393+20	05CE' ED5B0600	                ld de, (BDOS + 1)       ; Fetch first unusable address
1252: 7413+4	05D2' A7      	                and a
1253: 7417+15	05D3' ED52    	                sbc hl, de              ; This should carry
1254: 7432+4	05D5' 3F      	                ccf
1255: 7436+10	05D6' D1      	                pop de
1256: 7446+10	05D7' E1      	                pop hl
1257: 7456+10	05D8' C9      	                ret
1258:				;
1259:				;
1260:				; Make room in the FI structures store. The new space is created at HL, and
1261:				; everything from this address upwards is copied by DE bytes.
1262:				; Call with:
1263:				; HL - insert point
1264:				; DE - number of bytes required
1265:				; Returns with:
1266:				; Carry flag set if out of memory.
1267:				; HL is preserved.
1268: 7466+11	05D9' C5      	fi_make_room    push bc
1269: 7477+11	05DA' D5      	                push de
1270: 7488+11	05DB' E5      	                push hl
1271:				;
1272:				; Check the insert point is within the buffer. Panic if not.
1273: 7499+11	05DC' D5      	                push de
1274: 7510+11	05DD' E5      	                push hl
1275: 7521+20	05DE' ED5B0A00	                ld de, (free_start)     ; First free location
1276: 7541+6	05E2' 13      	                inc de
1277: 7547+4	05E3' A7      	                and a
1278: 7551+15	05E4' ED52    	                sbc hl, de
1279: 7566+10+7	05E6' D40000  	                call nc, panic          ; Panic if insert > end
1280: 7576+10	05E9' E1      	                pop hl
1281:				;
1282: 7586+11	05EA' E5      	                push hl
1283: 7597+20	05EB' ED5B0800	                ld de, (files_info)     ; Start address of FI structures
1284: 7617+4	05EF' A7      	                and a
1285: 7621+15	05F0' ED52    	                sbc hl, de
1286: 7636+10+7	05F2' DC0000  	                call c, panic           ; Panic if insert < start
1287: 7646+10	05F5' E1      	                pop hl
1288: 7656+10	05F6' D1      	                pop de
1289:				;
1290:				; Find new start of free space if the allocation is successful.
1291: 7666+16	05F7' 2A0A00  	                ld hl, (free_start)     ; First free location
1292: 7682+11	05FA' 19      	                add hl, de
1293:				; HL - adjusted free_start
1294: 7693+17	05FB' CDCC05  	                call chk_mem_lim        ; Check HL < BDOS start
1295: 7710+7+5	05FE' 381E    	                jr c, fimr_exit         ; Return with carry set on error
1296:				; Find out how much we have to copy (free_start - insert point)
1297: 7717+4	0600' EB      	                ex de, hl
1298:				; DE - adjusted free_start
1299: 7721+16	0601' 2A0A00  	                ld hl, (free_start)     ; First free location
1300: 7737+10	0604' C1      	                pop bc                  ; Insert point
1301: 7747+11	0605' C5      	                push bc
1302: 7758+4	0606' A7      	                and a
1303: 7762+15	0607' ED42    	                sbc hl, bc
1304: 7777+10+7	0609' DC0000  	                call c, panic
1305:				; BC - insert point
1306:				; DE - adjusted free_start
1307:				; HL - number of bytes required
1308:				; Note: there is nothing to copy if we are inserting at the end of the buffer.
1309: 7787+4	060C' 7C      	                ld a, h
1310: 7791+4	060D' B5      	                or l
1311: 7795+7+5	060E' 2820    	                jr z, fimr_no_copy
1312:				;
1313:				; We have data to move.
1314: 7802+4	0610' 44      	                ld b, h                 ; Number of bytes required
1315: 7806+4	0611' 4D      	                ld c, l
1316: 7810+16	0612' 2A0A00  	                ld hl, (free_start)     ; First free location
1317: 7826+20	0615' ED530A00	                ld (free_start), de     ; Save updated free_start
1318: 7846+6	0619' 2B      	                dec hl
1319: 7852+6	061A' 1B      	                dec de
1320:				;
1321:				; HL = FreeStart - 1 (source)
1322:				; DE = adjusted free_start - 1 (destination)
1323:				; BC = number of bytes required
1324: 7858+16+5	061B' EDB8    	                lddr
1325: 7874+4	061D' A7      	                and a                   ; Flag success
1326:				;
1327:				; Clear the newly created space.
1328: 7878+10	061E' E1      	fimr_exit       pop hl                  ; Fetch insert point and length
1329: 7888+10	061F' D1      	                pop de
1330: 7898+11	0620' D5      	                push de
1331: 7909+11	0621' E5      	                push hl
1332:				;
1333: 7920+4	0622' 7A      	fimr_clr_loop   ld a, d
1334: 7924+4	0623' B3      	                or e
1335: 7928+7+5	0624' 2806    	                jr z, fimr_clr_done
1336: 7935+10	0626' 3600    	                ld (hl), 0
1337: 7945+6	0628' 23      	                inc hl
1338: 7951+6	0629' 1B      	                dec de
1339: 7957+12	062A' 18F6    	                jr fimr_clr_loop
1340:				;
1341: 7969+10	062C' E1      	fimr_clr_done   pop hl
1342: 7979+10	062D' D1      	                pop de
1343: 7989+10	062E' C1      	                pop bc
1344: 7999+10	062F' C9      	                ret
1345:				;
1346:				; The insert point is at the end of the buffer, so there is nothing to copy.
1347: 8009+20	0630' ED530A00	fimr_no_copy    ld (free_start), de     ; Save updated free_start
1348: 8029+4	0634' A7      	                and a                   ; Flag success
1349: 8033+12	0635' 18E7    	                jr fimr_exit
1350:				;
1351:				;
1352:				; Display filename etc. from directory entry OR file information structure.
1353:				; Format is:
1354:				; U<user> <name>.<type>
1355:				; IY - pointer to directory entry structure (DIRE_xxx)
1356:				; IY is preserved.
1357: 8045+11	0637' C5      	disp_file       push bc
1358: 8056+11	0638' E5      	                push hl
1359:				;
1360:				; Ensure the offsets are the same for both structures.
1361:     -	0001'         	                assert DIRE_USER = FI_USER
1362:     -	0001'         	                assert DIRE_NAME = FI_NAME
1363:     -	0001'         	                assert DIRE_TYP = FI_TYP
1364:				;
1365:				; Display user.
1366: 8067+7	0639' 3E55    	                ld a, "U"
1367: 8074+17	063B' CD0000  	                call conwch             ; Write character to console
1368: 8091+19	063E' FD7E00  	                ld a, (iy + DIRE_USER)  ; User number
1369: 8110+17	0641' CD0000  	                call cwpdby             ; Print A in decimal
1370: 8127+17	0644' CD0000  	                call cwpspc             ; Print a space
1371:				;
1372:				; Display name.
1373: 8144+15	0647' FDE5    	                push iy
1374: 8159+10	0649' E1      	                pop hl
1375: 8169+10	064A' 010100  	                ld bc, DIRE_NAME
1376: 8179+11	064D' 09      	                add hl, bc
1377:				; HL - start address of name.
1378: 8190+7	064E' 0608    	                ld b, FILENAME_SIZE
1379: 8197+7	0650' 0E3F    	                ld c, "?"               ; Substitution character
1380: 8204+7	0652' 7E      	df_name_loop    ld a, (hl)
1381: 8211+17	0653' CD0000  	                call cwvich             ; Print only visible 7-bit characters
1382: 8228+6	0656' 23      	                inc hl
1383: 8234+8+5	0657' 10F9    	                djnz df_name_loop
1384:				;
1385:				; Display type.
1386: 8242+7	0659' 3E2E    	                ld a, "."
1387: 8249+17	065B' CD0000  	                call conwch             ; Write character to console
1388: 8266+15	065E' FDE5    	                push iy
1389: 8281+10	0660' E1      	                pop hl
1390: 8291+10	0661' 010900  	                ld bc, DIRE_TYP
1391: 8301+11	0664' 09      	                add hl, bc
1392:				; HL - start address of type.
1393: 8312+7	0665' 0603    	                ld b, FILEEXT_SIZE
1394: 8319+7	0667' 0E3F    	                ld c, "?"               ; Substitution character
1395: 8326+7	0669' 7E      	df_type_loop    ld a, (hl)
1396: 8333+17	066A' CD0000  	                call cwvich             ; Print only visible 7-bit characters
1397: 8350+6	066D' 23      	                inc hl
1398: 8356+8+5	066E' 10F9    	                djnz df_type_loop
1399:				;
1400: 8364+10	0670' E1      	                pop hl
1401: 8374+10	0671' C1      	                pop bc
1402: 8384+10	0672' C9      	                ret
1403:				;
1404:				;
1405:				; Compare file in directory entry structure with one in a file information
1406:				; structure. The comparison includes the user number, filename and extension.
1407:				; Call with:
1408:				; DE - pointer to file information structure.
1409:				; HL - pointer to directory entry structure.
1410:				; Returns with:
1411:				; Carry flag set if files don't match.
1412:				; DE and HL are preserved.
1413: 8394+11	0673' C5      	match_files     push bc
1414: 8405+11	0674' D5      	                push de
1415: 8416+11	0675' E5      	                push hl
1416:				;
1417:				; Compare user number.
1418:     -	0001'         	                assert FI_USER = 0
1419:     -	0001'         	                assert DIRE_USER = 0
1420: 8427+7	0676' 1A      	                ld a, (de)
1421: 8434+7	0677' BE      	                cp (hl)
1422: 8441+7+5	0678' 2021    	                jr nz, mf_no_match
1423: 8448+6	067A' 13      	                inc de
1424: 8454+6	067B' 23      	                inc hl
1425:				;
1426:				; Compare filename.
1427:     -	0001'         	                assert FI_NAME = 1
1428:     -	0001'         	                assert DIRE_NAME = 1
1429: 8460+7	067C' 0608    	                ld b, FILENAME_SIZE
1430: 8467+7	067E' 1A      	mf_name_loop    ld a, (de)
1431: 8474+7	067F' BE      	                cp (hl)
1432: 8481+7+5	0680' 2019    	                jr nz, mf_no_match
1433: 8488+6	0682' 13      	                inc de
1434: 8494+6	0683' 23      	                inc hl
1435: 8500+8+5	0684' 10F8    	                djnz mf_name_loop
1436:				;
1437:				; Compare type. Ignore read-only and hidden flags.
1438:     -	0001'         	                assert FI_TYP = 9
1439:     -	0001'         	                assert DIRE_TYP = 9
1440: 8508+7	0686' 0603    	                ld b, FILEEXT_SIZE
1441: 8515+7	0688' 1A      	mf_typ_loop     ld a, (de)
1442: 8522+7	0689' E67F    	                and 0x7f
1443: 8529+4	068B' 4F      	                ld c, a
1444: 8533+7	068C' 7E      	                ld a, (hl)
1445: 8540+7	068D' E67F    	                and 0x7f
1446: 8547+4	068F' B9      	                cp c
1447: 8551+7+5	0690' 2009    	                jr nz, mf_no_match
1448: 8558+6	0692' 13      	                inc de
1449: 8564+6	0693' 23      	                inc hl
1450: 8570+8+5	0694' 10F2    	                djnz mf_typ_loop
1451:				;
1452:				; Files match!
1453: 8578+4	0696' A7      	                and a
1454:				;
1455: 8582+10	0697' E1      	mf_exit         pop hl
1456: 8592+10	0698' D1      	                pop de
1457: 8602+10	0699' C1      	                pop bc
1458: 8612+10	069A' C9      	                ret
1459:				;
1460:				; Mismatch.
1461: 8622+4	069B' 37      	mf_no_match     scf
1462: 8626+12	069C' 18F9    	                jr mf_exit
1463:				;
1464:				;
1465:				; Read a directory entry from the disk and return a pointer to it.
1466:				; Call with:
1467:				; HL - required directory entry number
1468:				; IX - pointer to Disk Parameter Block (DPB)
1469:				; Returns with:
1470:				; HL - points to start of entry
1471: 8638+11	069E' C5      	get_entry       push bc
1472: 8649+11	069F' D5      	                push de
1473: 8660+11	06A0' E5      	                push hl                 ; Save entry number
1474:				; Divide by four to find the sector number.
1475: 8671+4	06A1' A7      	                and a
1476: 8675+8	06A2' CB1C    	                rr h
1477: 8683+8	06A4' CB1D    	                rr l
1478: 8691+4	06A6' A7      	                and a
1479: 8695+8	06A7' CB1C    	                rr h
1480: 8703+8	06A9' CB1D    	                rr l
1481:				; HL - CP/M (128-byte) sector number (offset into data area)
1482:				; Is this already in the buffer?
1483: 8711+20	06AB' ED5B0C00	                ld de, (loaded_sector)
1484: 8731+4	06AF' 7C      	                ld a, h
1485: 8735+4	06B0' BA      	                cp d
1486: 8739+7+5	06B1' 2004    	                jr nz, ge_load_reqd
1487: 8746+4	06B3' 7D      	                ld a, l
1488: 8750+4	06B4' BB      	                cp e
1489: 8754+7+5	06B5' 2816    	                jr z, ge_have_sec
1490:				;
1491:				; We need to load the sector containing the required entry.
1492: 8761+16	06B7' 220C00  	ge_load_reqd    ld (loaded_sector), hl  ; Save sector number
1493: 8777+7	06BA' 0E00    	                ld c, 0
1494: 8784+4	06BC' EB      	                ex de, hl
1495:				; CDE - CP/M (128-byte) sector number (offset into data area)
1496: 8788+17	06BD' CDE006  	                call set_sector
1497:				; Read the sector.
1498: 8805+10	06C0' 212400  	                ld hl, BIOS_READ        ; Read a sector
1499: 8815+17	06C3' CD0000  	                call cbios              ; Call BIOS with some registers saved
1500: 8832+4	06C6' A7      	                and a
1501: 8836+10	06C7' 21D607  	                ld hl, disk_err_msg     ; "Disk I/O error."
1502: 8846+10	06CA' C2E204  	                jp nz, msg_exit
1503:				;
1504:				; The required sector is loaded. Find the start address of the directory entry.
1505: 8856+10	06CD' E1      	ge_have_sec     pop hl                  ; Restore directory entry number
1506: 8866+4	06CE' 7D      	                ld a, l
1507: 8870+7	06CF' E603    	                and 0x03
1508: 8877+4	06D1' 6F      	                ld l, a
1509: 8881+7	06D2' 2600    	                ld h, 0
1510:				; HL - number of entry within sector.
1511: 8888+11	06D4' 29      	                add hl, hl              ; Multiply by 32 to find offset
1512: 8899+11	06D5' 29      	                add hl, hl
1513: 8910+11	06D6' 29      	                add hl, hl
1514: 8921+11	06D7' 29      	                add hl, hl
1515: 8932+11	06D8' 29      	                add hl, hl
1516: 8943+10	06D9' 118000  	                ld de, DEF_BUFFER
1517: 8953+11	06DC' 19      	                add hl, de              ; Add buffer start address
1518:				;
1519: 8964+10	06DD' D1      	                pop de
1520: 8974+10	06DE' C1      	                pop bc
1521: 8984+10	06DF' C9      	                ret                     ; Return with address in HL
1522:				;
1523:				;
1524:				; Set track and sector numbers for subsequent read and / or write operations.
1525:				; DMA address is set to the default area (0x80). The variables track and sector
1526:				; are set appropriately.
1527:				; Call with:
1528:				; CDE - CP/M (128-byte) sector number (offset into data area)
1529:				; IX - pointer to Disk Parameter Block (DPB)
1530: 8994+11	06E0' C5      	set_sector      push bc
1531: 9005+11	06E1' E5      	                push hl
1532:				; Find track number. For this application, the track number is likely to be small
1533:				; (normally zero). Hence this crude algorithm is sufficient.
1534: 9016+19	06E2' DD6E0D  	                ld l, (ix + DPB_OFF)    ; Start after reserved tracks
1535: 9035+19	06E5' DD660E  	                ld h, (ix + DPB_OFF + 1)
1536: 9054+11	06E8' D5      	ss_track_loop   push de                 ; Save LS 16 bits of sector number
1537:				; Perform a trial subtraction to see if we have a complete track worth of sectors.
1538: 9065+4	06E9' 7B      	                ld a, e
1539: 9069+19	06EA' DD9600  	                sub (ix + DPB_SPT)
1540: 9088+4	06ED' 5F      	                ld e, a
1541: 9092+4	06EE' 7A      	                ld a, d
1542: 9096+19	06EF' DD9E01  	                sbc (ix + DPB_SPT + 1)
1543: 9115+4	06F2' 57      	                ld d, a
1544: 9119+4	06F3' 79      	                ld a, c
1545: 9123+7	06F4' DE00    	                sbc 0
1546: 9130+4	06F6' 4F      	                ld c, a
1547: 9134+7+5	06F7' 3805    	                jr c, ss_track_done
1548:				; No carry, so we can advance to the next track.
1549: 9141+6	06F9' 23      	                inc hl
1550: 9147+6	06FA' 33      	                inc sp                  ; Discard saved sector number
1551: 9153+6	06FB' 33      	                inc sp
1552: 9159+12	06FC' 18EA    	                jr ss_track_loop
1553:				;
1554:				; There was a carry in the last subtract, so this is the track we want.
1555:				; HL - track number
1556:				; (stacked) - sector number
1557:				; Set track.
1558: 9171+4	06FE' 44      	ss_track_done   ld b, h                 ; Move track number to BC
1559: 9175+4	06FF' 4D      	                ld c, l
1560: 9179+20	0700' ED432600	                ld (track), bc          ; Save track for status reporting
1561: 9199+10	0704' 211B00  	                ld hl, BIOS_SETTRK      ; Set track number
1562: 9209+17	0707' CD0000  	                call cbios              ; Call BIOS with some registers saved
1563:				;
1564:				; Set sector.
1565: 9226+10	070A' C1      	                pop bc                  ; Fetch sector
1566: 9236+20	070B' ED432A00	                ld (sector), bc         ; Save sector for status reporting
1567: 9256+10	070F' 211E00  	                ld hl, BIOS_SETSEC      ; Set sector number
1568: 9266+17	0712' CD0000  	                call cbios              ; Call BIOS with some registers saved
1569:				;
1570:				; Set DMA address.
1571: 9283+10	0715' 018000  	                ld bc, DEF_BUFFER
1572: 9293+10	0718' 212100  	                ld hl, BIOS_SETDMA      ; Set DMA address
1573: 9303+17	071B' CD0000  	                call cbios              ; Call BIOS with some registers saved
1574:				;
1575: 9320+10	071E' E1      	                pop hl
1576: 9330+10	071F' C1      	                pop bc
1577: 9340+10	0720' C9      	                ret
1578:				;
1579:				;
1580:				;
1581:				; *************
1582:				; * Constants *
1583:				; *************
1584:				;
1585:				;
1586:     -	0721' 2A2A2A20	signon_msg      byte "*** CP/M File System Checker V1.1 ***", 0x0d, 0x0a, 0x0d, 0x0a, "$"
	              43502F4D
	              2046696C
	              65205379
	              7374656D
	              20436865
	              636B6572
	              2056312E
	              31202A2A
	              2A0D0A0D
	              0A24
1587:     -	074B' 5A383020	no_z80_msg      byte "Z80 CPU required", 0x0d, 0x0a, "$"
	              43505520
	              72657175
	              69726564
	              0D0A24
1588:     -	075E' 4F706572	op_err_msg      byte "Operand error. Expected format: fsck <drive>[:] [/s]", 0x0d, 0x0a, "$"
	              616E6420
	              6572726F
	              722E2045
	              78706563
	              74656420
	              666F726D
	              61743A20
	              6673636B
	              203C6472
	              6976653E
	              5B3A5D20
	              5B2F735D
	              0D0A24
1589:     -	0795' 52657475	exit_msg        byte "Returning to CP/M.", 0x0d, 0x0a, "$"
	              726E696E
	              6720746F
	              2043502F
	              4D2E0D0A
	              24
1590:     -	07AA' 496E7375	memory_msg      byte "Insufficient memory", 0x0d, 0x0a, "$"
	              66666963
	              69656E74
	              206D656D
	              6F72790D
	              0A24
1591:     -	07C0' 43616E27	sel_err_msg     byte "Can't select drive.", 0x0d, 0x0a, "$"
	              74207365
	              6C656374
	              20647269
	              76652E0D
	              0A24
1592:     -	07D6' 4469736B	disk_err_msg    byte "Disk I/O error.", 0x0d, 0x0a, "$"
	              20492F4F
	              20657272
	              6F722E0D
	              0A24
1593:     -	07E8' 44697265	dir_done_msg    byte "Directory checks complete", 0x0d, 0x0a, "$"
	              63746F72
	              79206368
	              65636B73
	              20636F6D
	              706C6574
	              650D0A24
1594:     -	0804' 46696C65	files_msg       byte "Files found: $"
	              7320666F
	              756E643A
	              2024
1595:     -	0812' 556E7573	unused_msg      byte "Unused directory entries: $"
	              65642064
	              69726563
	              746F7279
	              20656E74
	              72696573
	              3A2024
1596:     -	082D' 426C6F63	blocks_used_msg byte "Blocks used: $"
	              6B732075
	              7365643A
	              2024
1597:     -	083B' 0D0A426C	block_map_msg   byte 0x0d, 0x0a, "Block map ('D': directory, 'F': file and '-': unused).", 0x0d, 0x0a, "$"
	              6F636B20
	              6D617020
	              28274427
	              3A206469
	              72656374
	              6F72792C
	              20274627
	              3A206669
	              6C652061
	              6E642027
	              2D273A20
	              756E7573
	              6564292E
	              0D0A24
1598:     -	0876' 4572726F	errors_msg      byte "Errors and warnings: $"
	              72732061
	              6E642077
	              61726E69
	              6E67733A
	              2024
1599:     -	088C' 53757266	no_ss_msg       byte "Surface scan skipped", 0x0d, 0x0a, "$"
	              61636520
	              7363616E
	              20736B69
	              70706564
	              0D0A24
1600:     -	08A3' 0D0A4368	surf_scan_msg   byte 0x0d, 0x0a, "Checking all blocks are readable (surface scan)", 0x0d, 0x0a, "$"
	              65636B69
	              6E672061
	              6C6C2062
	              6C6F636B
	              73206172
	              65207265
	              61646162
	              6C652028
	              73757266
	              61636520
	              7363616E
	              290D0A24
1601:     -	08D7' 0D547261	track_msg       byte 0x0d, "Track: $"
	              636B3A20
	              24
1602:     -	08E0' 2C207365	sector_msg      byte ", sector: $"
	              63746F72
	              3A2024
1603:     -	08EB' 0D0A5363	scan_done_msg   byte 0x0d, 0x0a, "Scan complete", 0x0d, 0x0a, "$"
	              616E2063
	              6F6D706C
	              6574650D
	              0A24
1604:				; Directory entry error messages
1605:     -	08FD' 202D2062	bad_user_msg    byte " - bad user number$"
	              61642075
	              73657220
	              6E756D62
	              657224
1606:     -	0910' 202D2062	bad_name_msg    byte " - bad file name$"
	              61642066
	              696C6520
	              6E616D65
	              24
1607:     -	0921' 202D2062	bad_ex_cnt_msg  byte " - bad extent count$"
	              61642065
	              7874656E
	              7420636F
	              756E7424
1608:     -	0935' 202D2062	bad_s1_msg      byte " - bad S1$"
	              61642053
	              3124
1609:     -	093F' 202D2064	ext_dup_msg     byte " - duplicated physical extent$"
	              75706C69
	              63617465
	              64207068
	              79736963
	              616C2065
	              7874656E
	              7424
1610:     -	095D' 202D2062	dble_blk_msg    byte " - block not unique$"
	              6C6F636B
	              206E6F74
	              20756E69
	              71756524
1611:     -	0971' 202D2069	sparse_msg      byte " - is sparse (holed) [warning]$"
	              73207370
	              61727365
	              2028686F
	              6C656429
	              205B7761
	              726E696E
	              675D24
1612:     -	0990' 202D2062	blk_too_big_msg byte " - block number out of range$"
	              6C6F636B
	              206E756D
	              62657220
	              6F757420
	              6F662072
	              616E6765
	              24
1613:     -	09AD' 202D206E	no_alloc_msg    byte " - no allocations in physical extent [warning]$"
	              6F20616C
	              6C6F6361
	              74696F6E
	              7320696E
	              20706879
	              73696361
	              6C206578
	              74656E74
	              205B7761
	              726E696E
	              675D24
1614:     -	09DC' 202D2052	bad_rc_msg      byte " - RC not 0x80 in intermediate extent$"
	              43206E6F
	              74203078
	              38302069
	              6E20696E
	              7465726D
	              65646961
	              74652065
	              7874656E
	              7424
1615:     -	0A02' 202D2068	empty_msg       byte " - has no data [warning]$"
	              6173206E
	              6F206461
	              7461205B
	              7761726E
	              696E675D
	              24
1616:				;
1617:				;
1618:				; *************
1619:				; * Variables *
1620:				; *************
1621:				;
1622:				;
1623:				; Note: linker "-c" option is used, so no data is initialised here.
1624:				                dseg                ; Data segment
1625:				;
1626:     -	0000"         	bdos_sp         defs 2              ; BDOS's stack pointer
1627:     -	0002"         	drive           defs 1              ; Drive number (0 to 15)
1628:     -	0003"         	scan_enable     defs 1              ; Surface scan enable flag
1629:     -	0004"         	blk_flags       defs 2              ; Pointer to start of blocks used flags
1630:     -	0006"         	blk_flags_size  defs 2              ; Size of block flags buffer
1631:     -	0008"         	files_info      defs 2              ; Start address of FI structures
1632:     -	000A"         	free_start      defs 2              ; First free location
1633:     -	000C"         	loaded_sector   defs 2              ; Currently loaded sector
1634:     -	000E"         	dir_blocks      defs 1              ; Number of blocks used by the directory
1635:     -	000F"         	error_count     defs 2              ; Error count
1636:     -	0011"         	file_count      defs 2              ; Files count
1637:     -	0013"         	unused_count    defs 2              ; Unused entry count
1638:     -	0015"         	blocks_used     defs 2              ; Number of blocks used
1639:     -	0017"         	phys_extent     defs 2              ; Calculated physical extent
1640:     -	0019"         	dpb             defs 2              ; Pointer to Disk Parameter Block (DPB_xxx)
1641:     -	001B"         	dire            defs 2              ; Pointer to directory entry structure (DIRE_xxx)
1642:     -	001D"         	fie             defs 2              ; Pointer to file information structure (FI_xxx)
1643:     -	001F"         	dir_entry_num   defs 2              ; Directory entry number being processed
1644:     -	0021"         	bdis_shift      defs 1              ; Block display shift (scaling)
1645:     -	0022"         	bdis_scale      defs 1              ; Scale (n:1)
1646:     -	0023"         	bdis_s_count    defs 1              ; Scale (block) counter
1647:     -	0024"         	bdis_col        defs 2              ; Display column
1648:     -	0026"         	track           defs 2              ; Current track
1649:     -	0028"         	disp_track      defs 2              ; Displayed track
1650:     -	002A"         	sector          defs 2              ; Current sector
1651:     -	002C"         	total_sectors   defs 3              ; Number of sectors in file system
1652:     -	002F"         	                defs STACK_SIZE     ; Stack space
1653:     -	006F"         	app_stack_top
1654:				;
1655:     -	006F"         	                end



Statistics:

     4	passes
     0	jr promotions
   430	symbols
  2587	bytes

   108	macro calls
  1546	macro bytes
     0	invented symbols



Symbol Table:

ALLCF_COUNT    =0F        15
ALLCF_SPARSE_BIT=06        6
ALLCF_SPARSE_MASK=40        64
ALLCF_UNUSED_BIT=07        7
ALLCF_UNUSED_MASK=80        128
ANSI_SGR_BLINK_OFF=19        25
ANSI_SGR_BOLD  =01        1
ANSI_SGR_DULINE=15        21
ANSI_SGR_FAINT =02        2
ANSI_SGR_FONT_1=0B        11
ANSI_SGR_FONT_2=0C        12
ANSI_SGR_FONT_3=0D        13
ANSI_SGR_FONT_4=0E        14
ANSI_SGR_FONT_5=0F        15
ANSI_SGR_FONT_6=10        16
ANSI_SGR_FONT_7=11        17
ANSI_SGR_FONT_8=12        18
ANSI_SGR_FONT_9=13        19
ANSI_SGR_GOTHIC=14        20
ANSI_SGR_HIDE_OFF=1C        28
ANSI_SGR_ITAL_OFF=17        23
ANSI_SGR_NORMAL=00        0
ANSI_SGR_NORM_INTEN=16        22
ANSI_SGR_PRI_FONT=0A        10
ANSI_SGR_RBLINK=06        6
ANSI_SGR_REV   =07        7
ANSI_SGR_REV_OFF=1B        27
ANSI_SGR_SBLINK=05        5
ANSI_SGR_STRIKE=09        9
ANSI_SGR_STRIKE_OFF=1D        29
ANSI_SGR_ULINE =04        4
ANSI_SGR_ULINE_OFF=18        24
ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
BDIS_CHARS_MAX = 3C0      960
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAX_SIZE  =1000      4096
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
BREAK_CHAR     =03        3
BitAddrMask      526'     1318
CCP_START      =D600      54784
CDISK          =04        4
CONCAP_ANSI_BIT=01        1
CONCAP_ANSI_MASK=02        2
CONCAP_UNICODE_BIT=02        2
CONCAP_UNICODE_MASK=04        4
CONCAP_ZARC_BIT=00        0
CONCAP_ZARC_MASK=01        1
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
FI_EX_FLAGS    =10        16
FI_EX_FL_LEN   =0F        15
FI_LAST_PEXT   =0C        12
FI_LAST_RC     =0E        14
FI_NAME        =01        1
FI_SIZE        =10        16
FI_TYP         =09        9
FI_USER        =00        0
INT_VEC_TABLE  =FFE0      65504
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
MAX_USER       =0F        15
MMAP_CPM_PAGES =04        4
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
STACK_SIZE     =40        64
TPA_START      = 100      256
VT100_COLS     =50        80
VT100_ROWS     =18        24
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
app_stack_top   6F"       111
bad_ex_cnt_msg   921'     2337
bad_name_msg     910'     2320
bad_rc_msg       9DC'     2524
bad_s1_msg       935'     2357
bad_user_msg     8FD'     2301
bam_div_loop     534'     1332
bam_mask_loop    52E'     1326
bdis_blk_done    401'     1025
bdis_col        24"       36
bdis_col_done    41E'     1054
bdis_entry_done  423'     1059
bdis_loop        3E0'     992
bdis_not_dir     3F1'     1009
bdis_s_count    23"       35
bdis_scale      22"       34
bdis_scale_done  3CC'     972
bdis_scale_loop  3AF'     943
bdis_shift      21"       33
bdos_sp         00"       0
bfc_done        DF'       223
bfc_loop        CF'       207
blk_flags       04"       4
blk_flags_size  06"       6
blk_too_big_msg  990'     2448
block_map_msg    83B'     2107
blocks_used     15"       21
blocks_used_msg  82D'     2093
cbdos           00        0 (extern)
cbios           00        0 (extern)
ccinit          00        0 (extern)
ccls            00        0 (extern)
chk_mem_lim      5CC'     1484
cldcur          00        0 (extern)
concap          00        0 (extern)
conrch          00        0 (extern)
conrev          00        0 (extern)
const           00        0 (extern)
conuln          00        0 (extern)
conwch          00        0 (extern)
conwmn          00        0 (extern)
conwms          00        0 (extern)
cscrup          00        0 (extern)
csrvis          00        0 (extern)
cwnwln          00        0 (extern)
cwpdby          00        0 (extern)
cwpdlo          00        0 (extern)
cwpdwd          00        0 (extern)
cwphby          00        0 (extern)
cwphnb          00        0 (extern)
cwphwd          00        0 (extern)
cwpspc          00        0 (extern)
cwvich          00        0 (extern)
dble_blk_msg     95D'     2397
df_name_loop     652'     1618
df_type_loop     669'     1641
dir_blocks      0E"       14
dir_done_msg     7E8'     2024
dir_entry_num   1F"       31
dire            1B"       27
disk_err_msg     7D6'     2006
disp_file        637'     1591
disp_track      28"       40
dpb             19"       25
drive           02"       2
drive_sel_ok    95'       149
empty_msg        A02'     2562
error_count     0F"       15
errors_msg       876'     2166
exit             4E5'     1253
exit_msg         795'     1941
ext_dup_msg      93F'     2367
fb_error         57B'     1403
fe_dup_err       5C8'     1480
fe_exit          5C9'     1481
fe_have_space    5B6'     1462
fi_make_room     5D9'     1497
fie             1D"       29
file_count      11"       17
files_info      08"       8
files_msg        804'     2052
fimr_clr_done    62C'     1580
fimr_clr_loop    622'     1570
fimr_exit        61E'     1566
fimr_no_copy     630'     1584
flag_block       54B'     1355
flag_extent      580'     1408
free_start      0A"       10
fstfre          00        0 (extern)
ge_have_sec      6CD'     1741
ge_load_reqd     6B7'     1719
get_entry        69E'     1694
id_al_done      FD'       253
id_al_loop      F5'       245
id_mark_used_lp  109'     265
init_blk_div    C0'       192
jptbl_addr     =7E        126
loaded_sector   0C"       12
match_files      673'     1651
memory_msg       7AA'     1962
mf_exit          697'     1687
mf_name_loop     67E'     1662
mf_no_match      69B'     1691
mf_typ_loop      688'     1672
msg_exit         4E2'     1250
mtwdli          00        0 (extern)
no_alloc_msg     9AD'     2477
no_ss_msg        88C'     2188
no_z80_msg       74B'     1867
on_z80          18'       24
op_check_term   69'       105
op_err_msg       75E'     1886
op_error        70'       112
op_found        50'       80
op_options      37'       55
operands_ok     76'       118
out_of_memory    4DF'     1247
panic           00        0 (extern)
phys_extent     17"       23
rddulo          00        0 (extern)
rdduwd          00        0 (extern)
rdhxwd          00        0 (extern)
rshift_word      53E'     1342
rshw_loop        53F'     1343
scan_done        301'     769
scan_done_msg    8EB'     2283
scan_enable     03"       3
scan_loop        11D'     285
sector          2A"       42
sector_msg       8E0'     2272
sel_err_msg      7C0'     1984
set_c_reg        548'     1352
set_sector       6E0'     1760
signon_msg       721'     1825
skpspc          00        0 (extern)
sl_calc_ext_dn   15A'     346
sl_calc_ext_lp   14E'     334
sl_do_next       2F8'     760
sl_entry_done    2E5'     741
sl_err_cont      4F2'     1266
sl_err_stop      2FC'     764
sl_find_loop     1CD'     461
sl_name_chk      173'     371
sl_not_unused    13B'     315
sl_user_ok       168'     360
slf_alu_dn       28F'     655
slf_by_alu_dn    28B'     651
slf_by_alu_lp    271'     625
slf_by_alu_used  27B'     635
slf_bytes        26F'     623
slf_ext_done     23E'     574
slf_found_fi     22E'     558
slf_name_loop    20B'     523
slf_no_match     1F3'     499
slf_typ_loop     213'     531
slf_wd_alu_dn    267'     615
slf_wd_alu_lp    24C'     588
slf_wd_alu_used  25A'     602
slfrc_done       2E5'     741
slfrc_not_last   2C3'     707
slfrc_update     2D6'     726
sparse_msg       971'     2417
spck_bit_loop    341'     833
spck_byte_loop   32B'     811
spck_byte_ok     337'     823
spck_done        35F'     863
spck_error       510'     1296
spck_file_done   351'     849
spck_last_byte   33B'     827
spck_last_ok     349'     841
spck_loop        305'     773
spck_not_empty   328'     808
spck_sp_err      335'     821
ss_disp_track    489'     1161
ss_find_sec_lp   457'     1111
ss_loop          475'     1141
ss_nodisp        497'     1175
ss_sec_done      4B5'     1205
ss_track_done    6FE'     1790
ss_track_loop    6E8'     1768
str_offset     =10        16
surf_scan_msg    8A3'     2211
surface_scan     445'     1093
toloca          00        0 (extern)
total_sectors   2C"       44
toupca          00        0 (extern)
track           26"       38
track_msg        8D7'     2263
unused_count    13"       19
unused_msg       812'     2066
z80det          00        0 (extern)
zrcdet          00        0 (extern)
