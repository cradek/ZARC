   1:				; *******************************************************
   2:				; * CP/M BIOS for ZARC Z80 Computer                     *
   3:				; * Version: V1.4                                       *
   4:				; * Merlin Skinner, 16/11/2020                          *
   5:				; *******************************************************
   6:				;
   7:				; Based on details in Digital Research CP/M Operating System Manual, especially
   8:				; appendix A, "The MDS Basic I/O System (BIOS)" and
   9:				; appendix B, "A Skeletal CBIOS", both at
  10:				; http://www.gaby.de/cpm/manuals/archive/cpm22htm/
  11:				;
  12:				; V1.0 - initial version.
  13:				; V1.1 - added ZARC specific functions and allocated pages.
  14:				; V1.2 - added ADM-3A / VT-100 console translation for console.
  15:				; V1.3, 29/7/2022 - switched console translation to terminal codes based on 
  16:				;   VT-52 for wider support.
  17:				; V1.4, 15/9/2022 - implemented CONOST, AUXIST and AUXOST functions. Added BIOS
  18:				;   version number readable by applications.
  19:				; V1.5, 30/9/2022 - added terminal reset sequence on cold and warm boot.
  20:				;
  21:				;
  22:				; Memory Map (CP/M Mode)
  23:				; 
  24:				; 0 (0000 - 3FFF): [CPM0]   writeable
  25:				; 1 (4000 - 7FFF): [CPM1]   writeable
  26:				; 2 (8000 - BFFF): [CPM2]   writeable
  27:				; 3 (C000 - FFFF): [CPM3]   writeable, supervisor
  28:				;
  29:				; When running CP/M, memory is mapped as shown above. Note that bank 3 is the
  30:				; only one with I/O (supervisor) access. This one bank is maintained when calls
  31:				; are made to the monitor. For this reason, interrupt code is maintained in
  32:				; this bank. Page numbers for CP/M may vary, and are allocated using the
  33:				; monitor's mpall function.
  34:				;
  35:				; Memory Map (Monitor Mode)
  36:				; 
  37:				; 0 (0000 - 3FFF): 3f [MONP]   read only, supervisor - monitor program
  38:				; 1 (4000 - 7FFF): 3e [MOND]   writeable - monitor variables, buffers etc.
  39:				; 2 (8000 - BFFF): (not used)
  40:				; 3 (C000 - FFFF): [CPM3]   writeable - interrupts, stack common with CP/M.
  41:				;
  42:				; This is the default map used by the monitor, and is selected when the monitor
  43:				; is active either for user commands or when its support routines are called.
  44:				; Pages are mapped into bank 2 (8000 - BFFF) as required to support this. Page
  45:				; 0x3f is selected in hardware when memory mapping is not active, so on reset
  46:				; the monitor (page 0x3f at address 0) is entered.
  47:				;
  48:				;
  49:				                title ZARC CP/M BIOS
  50:				;
  51:				;
  52:				;
  53:				; ************
  54:				; * Includes *
  55:				; ************
  56:				;
  57:				                include "macros.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//macros.i ****
   1:				; ***********************************
   2:				; * ZARC Macro Definitions          *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				;
   8:				;
   9:				; **********
  10:				; * Macros *
  11:				; **********
  12:				;
  13:				;
  14:				; Initialise enumeration.
  15:				; The absolute segment is used so the offsets are not marked as relocatable. This
  16:				; avoids "Not relocatable" errors.
  17:				ENUM_START      macro
  18:				                .aseg
  19:				enum_counter    set 0
  20:				                endm
  21:				;
  22:				; Invoke for each item.
  23:				ENUM            macro x
  24:				x               equ enum_counter
  25:				enum_counter    set enum_counter + 1
  26:				                endm
  27:				;
  28:				ENUM_END        macro x
  29:				x               set enum_counter    ; Set label to count of items
  30:				                .cseg
  31:				                endm
  32:				;
  33:				;
  34:				; Initialise a structure. This is used to generate offsets for data structures.
  35:				; The absolute segment is used so the offsets are not marked as relocatable. This
  36:				; avoids "Not relocatable" errors.
  37:				STRUCT          macro
  38:				                .aseg
  39:				str_offset      set 0
  40:				                endm
  41:				;
  42:				; Add a byte entry.
  43:				STR_BYTE        macro x
  44:				x               equ str_offset
  45:				str_offset      set str_offset + 1
  46:				                endm
  47:				;
  48:				; Add a word (16-bit) entry.
  49:				STR_WORD        macro x
  50:				x               equ str_offset
  51:				str_offset      set str_offset + 2
  52:				                endm
  53:				;
  54:				; Add a 3 byte (24-bit) entry.
  55:				STR_24BIT       macro x
  56:				x               equ str_offset
  57:				str_offset      set str_offset + 3
  58:				                endm
  59:				;
  60:				; Add a long (32-bit) entry.
  61:				STR_LONG        macro x
  62:				x               equ str_offset
  63:				str_offset      set str_offset + 4
  64:				                endm
  65:				;
  66:				; Add an arbitrary length entry.
  67:				STR_BLOCK       macro x, size   ; <name>, <size>
  68:				x               equ str_offset
  69:				str_offset      set str_offset + size
  70:				                endm
  71:				;
  72:				; End of structure (used to set size)
  73:				STR_END         macro x
  74:				x               equ str_offset
  75:				                .cseg
  76:				                endm
  77:				;
  78:				;
  79:				; Calculate offsets into jump tables.
  80:				; The absolute segment is used so the offsets are not marked as relocatable. This
  81:				; avoids "Not relocatable" errors.
  82:				JPTBL_START     macro x
  83:				                .aseg
  84:				jptbl_addr      set x               ; Set start address
  85:				                endm
  86:				;
  87:				; Invoke for each item.
  88:				JPTBL_ENTRY     macro x
  89:				x               equ jptbl_addr
  90:				jptbl_addr      set jptbl_addr + 3
  91:				                endm
  92:				;
  93:				; Invoke for a data block in the jump table
  94:				JPTBL_BLOCK     macro x, size   ; <name>, <size>
  95:				x               equ jptbl_addr
  96:				jptbl_addr      set jptbl_addr + size
  97:				                endm
  98:				;
  99:				JPTBL_END       macro x
 100:				x               set jptbl_addr      ; Set label to next address
 101:				                .cseg
 102:				                endm
 103:				;
 104:				;
 105:				; Define bits and masks. This is inspired by the Commodore Amiga BITDEF mechanism.
 106:				; Given:
 107:				; BITDEF I2C_CSR_STOP, 2
 108:				; Yields:
 109:				; I2C_CSR_STOP_BIT  EQU 2       ; Bit number
 110:				; I2C_CSR_STOP_MASK EQU 1<<2    ; Bit mask
 111:				BITDEF          macro n, b      ; <Name>, <bit>
 112:				n`_BIT          equ b
 113:				n`_MASK         equ 1 << b
 114:				                endm
 115:				;
 116:				;
 117:				; Force alignment. This asserts an appropriate number of zero bytes to achieve
 118:				; the required alignment. Note that these macros cannot work for relocatable
 119:				; files.
 120:				; 16-bit
 121:				ALIGN_WORD      macro
 122:				                if $ and 1
 123:				                    byte 0
 124:				                endif
 125:				                endm
 126:				;
 127:				; 32-bit
 128:				ALIGN_LONG      macro
 129:				                ALIGN_WORD
 130:				                if $ and 2
 131:				                    byte 0, 0
 132:				                endif
 133:				                endm
 134:				
**** bios.z80 ****
  58:				                include "z80.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//z80.i ****
   1:				; ***********************************
   2:				; * ZARC Z80 Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 28/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the Z80 itself.
   8:				;
   9:				; Z80 Vectors
  10:     -	0000          	Z80_RST00_VEC   equ 0x0000      ; RST instruction vectors
  11:     -	0008          	Z80_RST08_VEC   equ 0x0008
  12:     -	0010          	Z80_RST10_VEC   equ 0x0010
  13:     -	0018          	Z80_RST18_VEC   equ 0x0018
  14:     -	0020          	Z80_RST20_VEC   equ 0x0020
  15:     -	0028          	Z80_RST28_VEC   equ 0x0028
  16:     -	0030          	Z80_RST30_VEC   equ 0x0030
  17:     -	0038          	Z80_RST38_VEC   equ 0x0038
  18:     -	0066          	Z80_NMI_VEC     equ 0x0066      ; NMI vectors
  19:				
**** bios.z80 ****
  59:				                include "zarc.i"        ; Hardware definitions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//zarc.i ****
   1:				; ***********************************
   2:				; * ZARC Definitions                *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 26/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions related to the ZARC system.
   8:				;
   9:				;
  10:				; ************
  11:				; * Hardware *
  12:				; ************
  13:				;
  14:				; Interrupt vector numbers in INT_VEC_TABLE.
  15:				; Address is INT_VEC_TABLE + 2 * vector number).
  16:     -	0000          	INT_SER1_TX_VEC     equ INT_SER1_TX_BIT ; Serial port 1 transmitter buffer is half full or less
  17:     -	0001          	INT_SER1_RX_VEC     equ INT_SER1_RX_BIT ; Serial port 1 receiver has data
  18:     -	0002          	INT_SER2_TX_VEC     equ INT_SER2_TX_BIT ; Serial port 2 transmitter buffer is half full or less
  19:     -	0003          	INT_SER2_RX_VEC     equ INT_SER2_RX_BIT ; Serial port 2 receiver has data
  20:     -	0004          	INT_TICK_VEC        equ INT_TICK_BIT    ; Regular timekeeping
  21:				;
  22:     -	0064          	MS_PER_TICK         equ 100             ; ms per tick
  23:     -	000A          	TICK_FREQ           equ 10              ; Tick rate in Hz
  24:				;
  25:				
**** bios.z80 ****
  60:				                include "monitor.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//monitor.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor Definitions                            *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related to the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				;
  12:				; The following conditionals are intended to allow the same include file to be
  13:				; used in the defining module and elsewhere as required. Some includes are used
  14:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  15:				; the extern and public statements are not desirable.
  16:				;
  17:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  32:				            endif
  33:				;
  34:				;
  35:				;
  36:				; *****************
  37:				; * Monitor Calls *
  38:				; *****************
  39:				;
  40:				;
  41:				; Calculate offsets into jump tables. Entries here must match the jump table in
  42:				; monitor.z80.
  43:     -	        	    JPTBL_START %(Z80_NMI_VEC + 3)   ; Start after NMI vector
  44:				;
  45:				; From monitor.z80
  46:     -	        	    JPTBL_ENTRY MCALL_MON_ENTRY     ; Normal monitor entry
  47:     -	        	    JPTBL_ENTRY MCALL_PANIC         ; System error monitor entry
  48:				; From io.z80
  49:     -	        	    JPTBL_ENTRY MCALL_CONWCH        ; Write character to the console port
  50:     -	        	    JPTBL_ENTRY MCALL_CONRCH        ; Read character from the console port
  51:     -	        	    JPTBL_ENTRY MCALL_CONSTA        ; Fetch console port status
  52:     -	        	    JPTBL_ENTRY MCALL_S1WCH         ; Write character to serial port 1
  53:     -	        	    JPTBL_ENTRY MCALL_S1RCH         ; Read character from serial port 1
  54:     -	        	    JPTBL_ENTRY MCALL_S1STA         ; Fetch serial port 1 status
  55:     -	        	    JPTBL_ENTRY MCALL_S2WCH         ; Write character to serial port 2
  56:     -	        	    JPTBL_ENTRY MCALL_S2RCH         ; Read character from serial port 2
  57:     -	        	    JPTBL_ENTRY MCALL_S2STA         ; Fetch serial port 2 status
  58:				; From utility.z80
  59:     -	        	    JPTBL_ENTRY MCALL_CWNWLN        ; Write new line characters to console
  60:     -	        	    JPTBL_ENTRY MCALL_CONWMS        ; Print null-terminated string to the console
  61:     -	        	    JPTBL_ENTRY MCALL_CONWMN        ; Print message <n> in a list
  62:     -	        	    JPTBL_ENTRY MCALL_SKPSPC        ; Step hl past spaces
  63:     -	        	    JPTBL_ENTRY MCALL_TOUPCA        ; Convert character in A to upper case
  64:     -	        	    JPTBL_ENTRY MCALL_TOLOCA        ; Convert character in A to lower case
  65:     -	        	    JPTBL_ENTRY MCALL_CWVICH        ; Print only visible 7-bit characters
  66:     -	        	    JPTBL_ENTRY MCALL_CWPSPC        ; Print a space
  67:     -	        	    JPTBL_ENTRY MCALL_MTWDLI        ; Match word in a string against list of options
  68:     -	        	    JPTBL_ENTRY MCALL_CWPHNB        ; Print least-significant nibble in A in hexadecimal
  69:     -	        	    JPTBL_ENTRY MCALL_CWPHBY        ; Print A in hexadecimal
  70:     -	        	    JPTBL_ENTRY MCALL_CWPHWD        ; Print HL in hexadecimal
  71:     -	        	    JPTBL_ENTRY MCALL_CWPDBY        ; Print A in decimal. Leading zeros are suppressed.
  72:     -	        	    JPTBL_ENTRY MCALL_CWPDWD        ; Print HL in decimal. Leading zeros are suppressed.
  73:     -	        	    JPTBL_ENTRY MCALL_CWPDLO        ; Print DEHL in decimal. Leading zeros are suppressed
  74:     -	        	    JPTBL_ENTRY MCALL_RDHXWD        ; Read a 16-bit hexadecimal number from a string
  75:     -	        	    JPTBL_ENTRY MCALL_RDDUWD        ; Read a 16-bit unsigned decimal number from a string
  76:     -	        	    JPTBL_ENTRY MCALL_RDDULO        ; Read a 32-bit unsigned decimal number from a string
  77:				; From maths.z80
  78:     -	        	    JPTBL_ENTRY MCALL_MADLBU        ; 32-bit / 8-bit unsigned divide
  79:     -	        	    JPTBL_ENTRY MCALL_MADWBU        ; 16-bit / 8-bit unsigned divide
  80:     -	        	    JPTBL_ENTRY MCALL_MADBBU        ; 8-bit / 8-bit unsigned divide
  81:     -	        	    JPTBL_ENTRY MCALL_MAMWWU        ; 16-bit * 16-bit unsigned multiply
  82:     -	        	    JPTBL_ENTRY MCALL_MAMLBU        ; 32-bit * 8-bit unsigned multiply
  83:     -	        	    JPTBL_ENTRY MCALL_CRC16X        ; CRC-16 (XMODEM)
  84:				; From time.z80
  85:     -	        	    JPTBL_ENTRY MCALL_TIRD          ; Read current time and date
  86:     -	        	    JPTBL_ENTRY MCALL_TIWR          ; Set time and date
  87:     -	        	    JPTBL_ENTRY MCALL_TIITOS        ; Convert integer time to structure
  88:     -	        	    JPTBL_ENTRY MCALL_TISTOI        ; Convert structure time to integer
  89:     -	        	    JPTBL_ENTRY MCALL_CWPTM         ; Print time structure to console
  90:				; From mmc.z80
  91:     -	        	    JPTBL_ENTRY MCALL_MCPRER        ; Print memory card error text
  92:				; From cache.z80
  93:     -	        	    JPTBL_ENTRY MCALL_CACRS         ; CP/M read sector
  94:     -	        	    JPTBL_ENTRY MCALL_CACWS         ; CP/M write sector
  95:     -	        	    JPTBL_ENTRY MCALL_CAFLUS        ; Flush cache (write dirty buffers)
  96:				; From memory.z80
  97:     -	        	    JPTBL_ENTRY MCALL_MPALL         ; Allocate new page
  98:     -	        	    JPTBL_ENTRY MCALL_MPFREE        ; Free allocated page
  99:     -	        	    JPTBL_ENTRY MCALL_MPSTAT        ; Allocation status
 100:				;
 101:     -	        	    JPTBL_END MCALL_JPTBL_NEXT
 102:				;
 103:				;
 104:				;
 105:				; **************
 106:				; * Structures *
 107:				; **************
 108:				;
 109:				;
 110:				; Machine state structure.
 111:     -	        	                STRUCT
 112:     -	        	                STR_BYTE MST_IEN        ; Non-zero if interrupts enabled
 113:     -	        	                STR_BYTE MST_MMAP_EN    ; Non-zero if memory mapping enabled
 114:     -	        	                STR_BYTE MST_MMAP0      ; Memory mapping registers
 115:     -	        	                STR_BYTE MST_MMAP1
 116:     -	        	                STR_BYTE MST_MMAP2
 117:     -	        	                STR_BYTE MST_MMAP3
 118:     -	        	                STR_WORD MST_SP
 119:     -	        	                STR_WORD MST_PC
 120:				; The sequence of the following entries must match those in the state save and
 121:				; load routines.
 122:     -	        	                STR_WORD MST_IY
 123:     -	        	                STR_WORD MST_IX
 124:     -	        	                STR_WORD MST_HL_P
 125:     -	        	                STR_WORD MST_DE_P
 126:     -	        	                STR_WORD MST_BC_P
 127:     -	        	                STR_WORD MST_AF_P       ; Alternate ("prime") registers
 128:     -	        	                STR_WORD MST_HL
 129:     -	        	                STR_WORD MST_DE
 130:     -	        	                STR_WORD MST_BC
 131:     -	        	                STR_WORD MST_AF
 132:				; End of sequence critical entries.
 133:     -	        	                STR_BYTE MST_I
 134:     -	        	                STR_BYTE MST_R
 135:     -	        	                STR_END MST_SIZE
 136:				;
 137:				;
 138:				;
 139:				; *************
 140:				; * Constants *
 141:				; *************
 142:				;
 143:				;
 144:				; Trace mode states for trace_mode.
 145:     -	        	                ENUM_START
 146:     -	        	                ENUM TRM_NONE
 147:     -	        	                ENUM TRM_SINGLE
 148:     -	        	                ENUM TRM_TO_ADDR        ; Trace to address
 149:     -	        	                ENUM TRM_XPT            ; Exception - start running normally
 150:     -	        	                ENUM_END TRM_STATES     ; Number of states
 151:				
**** bios.z80 ****
  61:				                include "io_map.i"      ; I/O addresses mapping
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io_map.i ****
   1:				; ***********************************
   2:				; * ZARC I/O Definitions            *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 3/9/2019          *
   5:				; ***********************************
   6:				
   7:				; *** I/O register address mapping ***
   8:				
   9:				; This should be kept in sync with the Definitions.vhd package file.
  10:     -	0000          	IOA_FPGA_MAJREV equ 0x00        ; FPGA major revision
  11:     -	0001          	IOA_FPGA_MINREV equ 0x01        ; FPGA minor revision
  12:     -	0002          	IOA_CONTROL     equ 0x02        ; System control register
  13:     -	0003          	IOA_FP_SW       equ 0x03        ; Front panel data switches
  14:				
  15:				; Paging
  16:     -	0004          	IOA_MMAP_0      equ 0x04        ; Page, supervisor and protection for bank 0 (0x0000 to 0x3fff)
  17:     -	0005          	IOA_MMAP_1      equ 0x05        ; Page, supervisor and protection for bank 1 (0x4000 to 0x7fff)
  18:     -	0006          	IOA_MMAP_2      equ 0x06        ; Page, supervisor and protection for bank 2 (0x8000 to 0xbfff)
  19:     -	0007          	IOA_MMAP_3      equ 0x07        ; Page, supervisor and protection for bank 3 (0xc000 to 0xffff)
  20:				
  21:				; Interrupts
  22:				; Note: Up to eight interrupts are supported. IM 2 is anticipated, and the
  23:				; fixed vector associated with each interrupt is supplied when the interrupt
  24:				; is serviced. Routine address is “I*256+databus”. Vector supplied is
  25:				; 0xe0 + 2 * interrupt number (0 to 7).
  26:				; Note: addresses 0x09 and 0x0b reserved for use if more than eight interrupt
  27:				; sources are required.
  28:     -	0008          	IOA_INT_EN      equ 0x08        ; Enables
  29:     -	000A          	IOA_INT_PEND    equ 0x0a        ; Pending interrupts
  30:				;
  31:				;NMI
  32:     -	000C          	IOA_NMI_REASONS equ 0x0c        ; NMI reasons flags
  33:				;
  34:				; Serial.
  35:     -	0010          	IOA_SER1_CSR    equ 0x10        ; Port 1 control / status
  36:     -	0011          	IOA_SER1_DATA   equ 0x11        ; Port 1 data
  37:     -	0012          	IOA_SER2_CSR    equ 0x12        ; Port 2 serial control / status
  38:     -	0013          	IOA_SER2_DATA   equ 0x13        ; Port 2 serial data
  39:				
  40:				; RTC (DS1672)
  41:				; I2C, implemented using a byte interface to the CPU. Writing to the data port
  42:				; shifts out a byte. Input puts are shifted into the “other end” of the same
  43:				; register.
  44:     -	0018          	IOA_I2C_CSR     equ 0x18        ; Control
  45:     -	0019          	IOA_I2C_DATA    equ 0x19        ; Data
  46:				;
  47:				; SD Card
  48:				; Uses SPI mode, with a generally similar interface to that of the I2C.
  49:     -	0020          	IOA_SPI_CSR     equ 0x20        ; Control
  50:     -	0021          	IOA_SPI_DATA    equ 0x21        ; Data
  51:				
  52:				; CRC16 / XMODEM and MultiMediaCard CRC16
  53:				; Write to the CRC register to set the initial value. Writing to the input
  54:				; data register updates the CRC.
  55:     -	0024          	IOA_CRC_0       equ 0x24        ; CRC register (low)
  56:     -	0025          	IOA_CRC_1       equ 0x25        ; CRC register (high)
  57:     -	0026          	IOA_CRC_DATA    equ 0x26        ; Input data
  58:				
  59:				; *** Proposed features ***
  60:				; Video
  61:				;IOA_VID_CTRL    equ 0x30;       ; Control (cursor on/off ...)
  62:				;IOA_VID_DATA    equ 0x31;       ; Data
  63:				;IOA_VID_CUR_X   equ 0x32;       ; Cursor X (0 to 127)
  64:				;IOA_VID_CUR_Y   equ 0x33;       ; Cursor Y (0 to 63)
  65:				;IOA_VID_START_L equ 0x34        ; Display start address (low byte)
  66:				;IOA_VID_START_H equ 0x35        ; Display start address (high byte)
  67:				
  68:				; Video palette
  69:				; Each entry consists of 6 bits of colour data. Foreground and background
  70:				; colour pairs are selected from the above palette using eight of the 22
  71:				; control codes in the display character set. This leaves codes for
  72:				; double-height, double-width etc.
  73:				;IOA_VID_PALBG0  equ 0x40        ; Background colour 0
  74:				;IOA_VID_PALFG0  equ 0x41        ; Foreground colour 0
  75:				;IOA_VID_PALBG1  equ 0x42        ; Background colour 1
  76:				;IOA_VID_PALFG1  equ 0x43        ; Foreground colour 1
  77:				;IOA_VID_PALBG2  equ 0x44        ; Background colour 2
  78:				;IOA_VID_PALFG2  equ 0x45        ; Foreground colour 2
  79:				;IOA_VID_PALBG3  equ 0x46        ; Background colour 3
  80:				;IOA_VID_PALFG3  equ 0x47        ; Foreground colour 3
  81:				;IOA_VID_PALBG4  equ 0x48        ; Background colour 4
  82:				;IOA_VID_PALFG4  equ 0x49        ; Foreground colour 4
  83:				;IOA_VID_PALBG5  equ 0x4a        ; Background colour 5
  84:				;IOA_VID_PALFG5  equ 0x4b        ; Foreground colour 5
  85:				;IOA_VID_PALBG6  equ 0x4c        ; Background colour 6
  86:				;IOA_VID_PALFG6  equ 0x4d        ; Foreground colour 6
  87:				;IOA_VID_PALBG7  equ 0x4e        ; Background colour 7
  88:				;IOA_VID_PALFG7  equ 0x4f        ; Foreground colour 7
  89:				
  90:				; Arithmetic
  91:				; Multiply, divide … based on 68000 DIV, DIVU, MUL, MULU.
  92:				; Multiply does A[16] * B[16] => C[32].
  93:				; Divide does A[32] / B[16] => C[32] (16-bit remainder [high bits] and
  94:				; 16-bit quotient [low bits]).
  95:				; Status bits include “complete” and “overflow”.
  96:				;IOA_ARITH_A_L   equ 0x50        ; A register (low)
  97:				;IOA_ARITH_A_H   equ 0x51        ; A register (high)
  98:				;IOA_ARITH_B_L   equ 0x54        ; B register (low)
  99:				;IOA_ARITH_B_H   equ 0x57        ; B register (high)
 100:				;IOA_ARITH_C_0   equ 0x58        ; C register (low)
 101:				;IOA_ARITH_C_1   equ 0x59 
 102:				;IOA_ARITH_C_2   equ 0x5a
 103:				;IOA_ARITH_C_3   equ 0x5b        ; C register (high)
 104:				;IOA_ARITH_CSR   equ 0x5c        ; Command / status
 105:				
 106:				
 107:				; *** Register bits allocation ***
 108:				
 109:				; IOA_CONTROL register
 110:     -	        	BITDEF SYSCTRL_TRARM, 0         ; 1 arms the trace interrupt
 111:     -	        	BITDEF SYSCTRL_MMAP, 1          ; 1 enables memory mapping
 112:     -	        	BITDEF SYSCTRL_NMCLR, 2         ; NMI mapping clear
 113:     -	        	BITDEF SYSCTRL_MAPARM, 3        ; NMI out arm
 114:     -	        	BITDEF SYSCTRL_MMAPN, 4         ; State of MMAP when an NMI occurred
 115:     -	        	BITDEF SYSCTRL_TRPRE0, 5        ; Number of prefixes for trace
 116:     -	        	BITDEF SYSCTRL_TRPRE1, 6
 117:     -	        	BITDEF SYSCTRL_RESERVED, 7      ; Unused bit
 118:				;
 119:				; MMAP page registers
 120:     -	        	BITDEF MMAP_PROT, 7             ; Write protection
 121:     -	        	BITDEF MMAP_SUPER, 6            ; I/O enable
 122:     -	003F          	MMAP_PAGE_MASK  equ 0x3f        ; RAM page number bits
 123:				;
 124:				; IOA_INT_EN and IOA_INT_PEND registers.
 125:     -	0008          	INTS_NUM        equ 8           ; Number of possible interrupt sources
 126:     -	        	BITDEF INT_SER1_TX, 0           ; Serial port 1 transmitter buffer is half full or less
 127:     -	        	BITDEF INT_SER1_RX, 1           ; Serial port 1 receiver has data
 128:     -	        	BITDEF INT_SER2_TX, 2           ; Serial port 2 transmitter buffer is half full or less
 129:     -	        	BITDEF INT_SER2_RX, 3           ; Serial port 2 receiver has data
 130:     -	        	BITDEF INT_TICK, 4              ; Regular timekeeping
 131:				;
 132:				; IOA_NMI_REASONS register.
 133:     -	0004          	NMI_REASONS_NUM equ 4           ; Number of reasons for an NMI
 134:     -	        	BITDEF NMI_SWITCH, 0;           ; Front panel switch
 135:     -	        	BITDEF NMI_PROT_VIOL, 1;        ; Write protection violation
 136:     -	        	BITDEF NMI_SUPER_VIOL, 2;       ; Supervisor violation
 137:     -	        	BITDEF NMI_TRACE, 3;            ; Debugger trace (single step)
 138:     -	000F          	NMI_REASONS_ALL equ NMI_SWITCH_MASK + NMI_PROT_VIOL_MASK + NMI_SUPER_VIOL_MASK + NMI_TRACE_MASK
 139:				;
 140:				; Serial CSRs (IOA_SER1_CSR and IOA_SER2_CSR).
 141:     -	        	BITDEF SER_CSR_RX_EMPTY, 0      ; Receiver buffer is empty
 142:     -	        	BITDEF SER_CSR_RX_ALHALF, 1     ; Receiver buffer is at least half full
 143:     -	        	BITDEF SER_CSR_RX_FULL, 2       ; Receiver buffer is full
 144:     -	        	BITDEF SER_CSR_FRAME_ERR, 3     ; Framing error in last character
 145:     -	        	BITDEF SER_CSR_TX_EMPTY, 4      ; Transmitter buffer is empty
 146:     -	        	BITDEF SER_CSR_TX_ALHALF, 5     ; Transmitter buffer is at least half full
 147:     -	        	BITDEF SER_CSR_TX_FULL, 6       ; Transmitter buffer is full
 148:				; Bit 7 is not used.
 149:				;
 150:				; I2C (Inter-Integrated Circuit) master interface. Used for RTC (DS1672).
 151:				; Bits in IOA_I2C_CSR
 152:     -	        	BITDEF I2C_CSR_ACKN, 0          ; (Read / write) acknowledge from receiving device
 153:     -	        	BITDEF I2C_CSR_START, 1         ; (Write only) trigger start sequence
 154:     -	        	BITDEF I2C_CSR_STOP, 2          ; (Write only) trigger stop sequence
 155:     -	        	BITDEF I2C_CSR_BUSY, 7          ; (Read only) transceiver busy
 156:				;
 157:				; SPI (Serial Peripheral Interface) master interface. Used for memory card.
 158:				; Bits in IOA_SPI_CSR
 159:     -	        	BITDEF SPI_CSR_FAST, 0          ; (Read / write) SPI speed select
 160:     -	        	BITDEF SPI_CSR_MC_SS, 1         ; (Read / write) memory card slave select
 161:     -	        	BITDEF SPI_CSR_BUSY, 7          ; (Read only) transceiver busy
 162:				
**** bios.z80 ****
  62:				                include "terminal.i"    ; Terminal constants
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//terminal.i ****
   1:				; ***********************************
   2:				; * ZARC Terminal Definitions       *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Definitions associated with terminals connected to an RS-232 port.
   8:				;
   9:     -	0005          	ASCII_ENQ           equ 0x05        ; Enquiry
  10:     -	0008          	ASCII_BS            equ 0x08        ; Backspace
  11:     -	0009          	ASCII_HT            equ 0x09
  12:     -	000A          	ASCII_LF            equ 0x0a        ; Line feed
  13:     -	000B          	ASCII_VT            equ 0x0b        ; Upline (ADM-3A)
  14:     -	000C          	ASCII_FF            equ 0x0c        ; Forward space (ADM-3A)
  15:     -	000D          	ASCII_CR            equ 0x0d        ; Carriage return
  16:     -	0016          	ASCII_SYN           equ 0x16        ; Synchronous idle
  17:     -	001A          	ASCII_SUB           equ 0x1a        ; Clear screen (ADM-3A)
  18:     -	001B          	ASCII_ESC           equ 0x1b        ; Escape
  19:     -	001E          	ASCII_RS            equ 0x1e        ; Home cursor (ADM-3A)
  20:     -	007F          	ASCII_DEL           equ 0x7f        ; Delete
  21:				;
  22:				; ZARC CP/M terminal input key codes. Some are copied from Amstrad PCW and
  23:				; Spectrum +3, others are unique to ZARC. Delete seems very common.
  24:     -	001F          	ZKEY_CSR_UP         equ 0x1f        ; Cursor up
  25:     -	001E          	ZKEY_CSR_DOWN       equ 0x1e        ; Cursor down
  26:     -	0006          	ZKEY_CSR_RIGHT      equ 0x06        ; Cursor right
  27:     -	0001          	ZKEY_CSR_LEFT       equ 0x01        ; Cursor left
  28:     -	0002          	ZKEY_HOME           equ 0x02
  29:     -	0016          	ZKEY_INSERT         equ 0x16
  30:     -	007F          	ZKEY_DELETE         equ 0x7f
  31:     -	0004          	ZKEY_END            equ 0x04
  32:     -	001D          	ZKEY_PAGE_UP        equ 0x1d
  33:     -	001C          	ZKEY_PAGE_DOWN      equ 0x1c
  34:				
**** bios.z80 ****
  63:				                include "io.i"          ; I/O routines
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//io.i ****
   1:				; ***********************************
   2:				; * ZARC Basic I/O Extern Symbols   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and extern statements are not desirable.
  13:				;
  14:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  40:				            endif
  41:				;
  42:				;
  43:				; Port enumeration. Used for console and transfer port selection. Definitions must
  44:				; match names in prt_name_list (monitor.z80).
  45:     -	        	                ENUM_START
  46:     -	        	                ENUM PORT_SER1          ; Serial port 1
  47:     -	        	                ENUM PORT_SER2          ; Serial port 2
  48:     -	        	                ENUM_END PORT_STATES    ; Number of states
  49:				;
  50:				
**** bios.z80 ****
  64:				                include "utility.i"     ; Utility functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//utility.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Utility Routines   *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 16/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  37:				            endif
  38:				;
  39:				;
  40:				; mtwdli (match word in a string against list of options) option bits. Each bit
  41:				; has the described effect if set.
  42:     -	        	BITDEF MTWDLI_ABBREV, 0                 ; Enable "." abbreviation
  43:     -	        	BITDEF MTWDLI_ICASE, 1                  ; Ignore case when matching
  44:     -	        	BITDEF MTWDLI_TERM, 7                   ; Terminator found (internal use only)
  45:				
**** bios.z80 ****
  65:				                include "maths.i"       ; Mathematical functions
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//maths.i ****
   1:				; *******************************************************
   2:				; * Mathematical Routines for ZARC Z80 Computer         *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 29/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  25:				            endif
  26:				
**** bios.z80 ****
  66:				                include "interrupts.i"  ; Interrupts
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//interrupts.i ****
   1:				; ***********************************
   2:				; * ZARC Interrupts Routines        *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/5/2020         *
   5:				; ***********************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant.
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  27:				            endif
  28:				
**** bios.z80 ****
  67:				                include "time.i"        ; Routines associated with time
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//time.i ****
   1:				; ***********************************
   2:				; * ZARC Monitor Time Routines      *
   3:				; * Written by: Merlin Skinner      *
   4:				; * Date Started: 30/7/2020         *
   5:				; ***********************************
   6:				;
   7:				; The system keeps track of time as a Unix-style 32-bit number. Unlike Unix, this
   8:				; is treated as an unsigned integer and so will not suffer from the Year 2038 problem
   9:				; as it doubles the allowable postive time. It does, however, mean that it is not
  10:				; possible to represent dates before 1970.
  11:				
  12:				; Note that ld80 only considers the first six characters of labels significant.
  13:				;
  14:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  24:				            endif
  25:				;
  26:				;
  27:     -	0046          	TIM_EPOCH_YEAR  equ 70              ; Epoch year byte
  28:				;
  29:				; The following structure is used to store dates and times in human units. It is based
  30:				; on the Unix time.h tm structure.
  31:     -	        	                STRUCT
  32:     -	        	                STR_BYTE TM_SECS    ; Seconds [0,59]
  33:     -	        	                STR_BYTE TM_MINS    ; Minutes [0,59]
  34:     -	        	                STR_BYTE TM_HOURS   ; Hours [0,23]
  35:     -	        	                STR_BYTE TM_MDAY    ; Day of month [1,31]
  36:     -	        	                STR_BYTE TM_MON     ; Month of year [1,12]
  37:     -	        	                STR_BYTE TM_YEAR    ; Years since 1900 [70,255]
  38:     -	        	                STR_BYTE TM_WDAY    ; Day of week [0,6] (Sunday = 0)
  39:     -	        	                STR_WORD TM_YDAY    ; Day of year [0,365]
  40:     -	        	                STR_BYTE TM_DST     ; Daylight savings status
  41:     -	        	                STR_END TM_SIZE
  42:				
  43:				; TM_DST can have any of the following values:
  44:     -	        	                ENUM_START
  45:     -	        	                ENUM TMDST_UNKNOWN
  46:     -	        	                ENUM TMDST_GMT      ; The time is GMT
  47:     -	        	                ENUM TMDST_DST      ; The time has DST applied (is one hour advanced)
  48:     -	        	                ENUM_END TMDST_NUM  ; Number of possible values
  49:				
**** bios.z80 ****
  68:				                include "diags.i"       ; Diagnostics
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//diags.i ****
   1:				; ***************************************
   2:				; * ZARC Monitor Diagostics Routines    *
   3:				; * Written by: Merlin Skinner          *
   4:				; * Date Started: 3/8/2020              *
   5:				; ***************************************
   6:				;
   7:				; Note that ld80 only considers the first six characters of labels significant
   8:				;
   9:				; The following conditionals are intended to allow the same include file to be
  10:				; used in the defining module and elsewhere as required. Some includes are used
  11:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  12:				; the extern and public statements are not desirable.
  13:				;
  14:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  22:				            endif
  23:				
**** bios.z80 ****
  69:				                include "heap.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//heap.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Heap Incude File           *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 7/8/2020                  *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  22:				            endif
  23:				
**** bios.z80 ****
  70:				                include "cpm.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//cpm.i ****
   1:				; *******************************************************
   2:				; * ZARC Monitor CP/M Definitions                       *
   3:				; * Written by: Merlin Skinner                          *
   4:				; * Date Started: 26/5/2020                             *
   5:				; *******************************************************
   6:				;
   7:				; Definitions related CP/M running under the monitor programme.
   8:				;
   9:				; Note that ld80 only considers the first six characters of labels significant.
  10:				;
  11:				; The following conditionals are intended to allow the same include file to be
  12:				; used in the defining module and elsewhere as required. Some includes are used
  13:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  14:				; the extern and public statements are not desirable.
  15:				;
  16:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  28:				            endif
  29:				;
  30:				;
  31:				;
  32:				; ****************
  33:				; * Memory Usage *
  34:				; ****************
  35:				;
  36:				;
  37:				; Note: memory banks are allocated by the monitor's initialisation code.
  38:     -	0004          	MMAP_CPM_PAGES      equ 4               ; Number of 16 kB pages
  39:				;
  40:				; The MS byte of INT_VEC_TABLE comes from the Z80 I register, and the LS byte
  41:				; from the FPGA. The 0xe0 offset is chosen to allow the table to reside at the
  42:				; top of memory (0xffe0 to 0xffff).
  43:     -	FFE0          	INT_VEC_TABLE   equ 0xffe0              ; Interrupt mode 2 vector table
  44:				;
  45:				; Copied from CP/M manual appendix A.
  46:				; MSIZE             equ 64              ; CP/M version memory size in kilobytes
  47:				;
  48:				; "BIAS" is the address offset from 0x3400 for memory systems other than 16 K.
  49:				;BIAS               equ (MSIZE-20) * 1024
  50:     -	A200          	CPM_BIAS            equ 0xa200          ; For CompuPro64K_CPM
  51:     -	D600          	CCP_START           equ 0x3400 + CPM_BIAS   ; Base of CCP
  52:     -	DE06          	BDOS_START          equ CCP_START + 0x0806  ; Base of BDOS
  53:     -	EC00          	BIOS_START          equ CCP_START + 0x1600  ; Base of BIOS
  54:     -	002C          	BIOS_CPM_START_SEC  equ 44              ; First CP/M sector of BIOS
  55:     -	1000          	BIOS_MAX_SIZE       equ 4096            ; 2 KB allocation for BIOS stored on MMC (ZARC)
  56:     -	0100          	TPA_START           equ 0x0100          ; Transient Programme Area
  57:				;
  58:				; Page zero.
  59:     -	0003          	IOBYTE              equ 0x0003          ; Intel I/O byte
  60:     -	0004          	CDISK               equ 0x0004          ; Current disk (0="A") & user no. (in high nibble)
  61:     -	005C          	FCB1                equ 0x005c          ; Default FCB 1
  62:     -	006C          	FCB2                equ 0x006c          ; Default FCB 2 (overwritten if FCB 1 is opened)
  63:				; Default 128-byte disk buffer, also filled with the command line when a transient
  64:				; is loaded under the CCP.
  65:     -	0080          	DEF_BUFFER          equ 0x80
  66:     -	0080          	DEF_BUFFER_SIZE     equ 0x80
  67:				;
  68:				; IOBYTE bit definitions.
  69:     -	0003          	IOB_CON_MASK        equ 0x03
  70:     -	000C          	IOB_RDR_MASK        equ 0x0c
  71:     -	0030          	IOB_PUN_MASK        equ 0x30
  72:     -	00C0          	IOB_LST_MASK        equ 0xc0
  73:				;
  74:				; BIOS option bits.
  75:     -	        	BITDEF BIOS_OPT_DEBUG, 0                ; Enable BIOS debugging messages
  76:     -	        	BITDEF BIOS_OPT_NOINTS, 1               ; Disables interrupts (use basic I/O mode)
  77:     -	        	BITDEF BIOS_OPT_RAWCON, 2               ; Disables ADM-3A to VT-100 translation
  78:				;
  79:				;
  80:				;
  81:				; ***************
  82:				; * Disk System *
  83:				; ***************
  84:				;
  85:				;
  86:     -	0080          	CPM_SECTOR_SIZE     equ 128             ; CP/M disk sector size
  87:     -	0010          	NUM_DISKS           equ 16              ; Number of disk drives
  88:     -	0010          	NUM_DISKS_MAX       equ 16              ; Maximum number of disk drives
  89:     -	0000          	CPM_SYS_SIZE        equ 1024 * 1024     ; System area size (bytes)
  90:     -	0000          	CPM_DISK_SIZE       equ 1024 * 1024     ; Disk size (bytes)
  91:     -	0008          	FILENAME_SIZE       equ 8               ; Filename size
  92:     -	0003          	FILEEXT_SIZE        equ 3               ; File extension size
  93:     -	001A          	FILE_EOF            equ 0x1a            ; End of file (^Z)
  94:     -	000F          	MAX_USER            equ 15              ; Maximum user number
  95:				;
  96:     -	0001          	BDOS_READ_SEQ_EOF   equ 1               ; Sequential read EOF error code
  97:				;
  98:				; Disk Parameter Header (DPH) structure.
  99:     -	        	                STRUCT
 100:     -	        	                STR_WORD DPH_XLT        ; Address of sector translation table
 101:     -	        	                STR_WORD DPH_SCRATCH0   ; BDOS scratch area
 102:     -	        	                STR_WORD DPH_SCRATCH1
 103:     -	        	                STR_WORD DPH_SCRATCH2
 104:     -	        	                STR_WORD DPH_DIRBF      ; BDOS directory scratch area
 105:     -	        	                STR_WORD DPH_DPB        ; Pointer to DPB
 106:     -	        	                STR_WORD DPH_CSV        ; Pointer to the directory checksum vector
 107:     -	        	                STR_WORD DPH_ALV        ; Pointer to the allocation vector
 108:     -	        	                STR_END DPH_SIZE
 109:				;
 110:				;
 111:				; Disk Parameter Block (DPB) structure.
 112:     -	        	                STRUCT
 113:     -	        	                STR_WORD DPB_SPT        ; Number of 128-byte records per track
 114:     -	        	                STR_BYTE DPB_BSH        ; Block shift. 3 => 1k, 4 => 2k, 5 => 4k....
 115:     -	        	                STR_BYTE DPB_BLM        ; Block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
 116:     -	        	                STR_BYTE DPB_EXM        ; Extent mask
 117:     -	        	                STR_WORD DPB_DSM        ; Maximum block number
 118:     -	        	                STR_WORD DPB_DRM        ; Maximum directory entry number
 119:     -	        	                STR_BYTE DPB_AL0        ; Directory allocation bitmap
 120:     -	        	                STR_BYTE DPB_AL1
 121:     -	        	                STR_WORD DPB_CKS        ; Checksum vector size, 0 for a fixed disc
 122:     -	        	                STR_WORD DPB_OFF        ; Offset, number of reserved tracks
 123:     -	        	                STR_END DPB_SIZE
 124:				;
 125:				;
 126:				; Directory entry structure.
 127:     -	        	                STRUCT
 128:     -	        	                STR_BYTE DIRE_USER      ; User number. 0xe5 if entry unused
 129:     -	        	                STR_BLOCK DIRE_NAME, FILENAME_SIZE  ; Filename
 130:     -	        	                STR_BLOCK DIRE_TYP, FILEEXT_SIZE    ; File type
 131:     -	        	                STR_BYTE DIRE_EX        ; Extent counter, low byte (0-31)
 132:     -	        	                STR_BYTE DIRE_S1        ; Reserved, set to 0
 133:     -	        	                STR_BYTE DIRE_S2        ; Extent counter, high byte
 134:     -	        	                STR_BYTE DIRE_RC        ; Record count (low byte)
 135:     -	        	                STR_BLOCK DIRE_ALLOC, 16 ; Associated block numbers
 136:     -	        	                STR_END DIRE_SIZE
 137:				;
 138:				;
 139:				; File Control Block (FCB) structure.
 140:     -	        	                STRUCT
 141:     -	        	                STR_BYTE FCB_DRIVE      ; Drive. 0 for default, 1-16 for A-P
 142:     -	        	                STR_BLOCK FCB_NAME, FILENAME_SIZE   ; Filename in ASCII upper-case
 143:     -	        	                STR_BLOCK FCB_TYP, FILEEXT_SIZE     ; File type
 144:     -	        	                STR_BYTE FCB_EX         ; Current extent (*)
 145:     -	        	                STR_BYTE FCB_S1         ; Reserved (*)
 146:     -	        	                STR_BYTE FCB_S2         ; Reserved (*)
 147:     -	        	                STR_BYTE FCB_RC         ; Reserved (*)
 148:     -	        	                STR_BLOCK FCB_ALLOC, 16 ; Associated block numbers
 149:     -	        	                STR_BYTE FCB_CR         ; Current record within extent
 150:     -	        	                STR_BLOCK FCB_RECORD, 3 ; Record number (low byte first)
 151:     -	        	                STR_END FCB_SIZE
 152:				;
 153:				; * - Set this to 0 when opening a file and then leave it to CP/M. You can rewind
 154:				; a file by setting EX, RC, S2 and CR to 0.
 155:				;
 156:				;
 157:				;
 158:				; **************
 159:				; * BIOS Calls *
 160:				; **************
 161:				;
 162:				;
 163:				; Calculate offsets into jump tables. Entries here must match the jump table in
 164:				; the BIOS. The base address of the BIOS must be added to these addresses. A call
 165:				; routine might look like:
 166:				;
 167:				; Call BIOS, allowing for its unknown base address.
 168:				; Call with:
 169:				; BC - operand (depends on BIOS function called)
 170:				; DE - operand (depends on BIOS function called)
 171:				; HL - offset for the routine (e.g. BIOS_CONIN)
 172:				; call_bios       push de
 173:				;                 ex de, hl
 174:				;                 ld hl, (1)              ; Find WBOOT (warm boot) address
 175:				;                 add hl, de              ; Add offset
 176:				;                 pop de
 177:				;                 jp (hl)                 ; Jump to BIOS then return to caller
 178:				;
 179:				; The above method is a bit clumsy, but then application code shouldn't normally
 180:				; call the BIOS directly.
 181:				;
 182:     -	        	    JPTBL_START 0                   ; Generate offsets as BIOS_START isn't always known
 183:				;
 184:				; From monitor.z80
 185:				; Note - cold start routine omitted to align with use of address at (1) to find BIOS.
 186:     -	        	    JPTBL_ENTRY BIOS_WBOOT          ; Warm boot - reload command processor
 187:     -	        	    JPTBL_ENTRY BIOS_CONST          ; Console status
 188:     -	        	    JPTBL_ENTRY BIOS_CONIN          ; Console input
 189:     -	        	    JPTBL_ENTRY BIOS_CONOUT         ; Console output
 190:     -	        	    JPTBL_ENTRY BIOS_PLIST          ; Printer output
 191:     -	        	    JPTBL_ENTRY BIOS_PUNCH          ; Paper tape punch output
 192:     -	        	    JPTBL_ENTRY BIOS_READER         ; Paper tape reader input
 193:     -	        	    JPTBL_ENTRY BIOS_HOME           ; Move disc head to track 0
 194:     -	        	    JPTBL_ENTRY BIOS_SELDSK         ; Select disc drive
 195:     -	        	    JPTBL_ENTRY BIOS_SETTRK         ; Set track number
 196:     -	        	    JPTBL_ENTRY BIOS_SETSEC         ; Set sector number
 197:     -	        	    JPTBL_ENTRY BIOS_SETDMA         ; Set DMA address
 198:     -	        	    JPTBL_ENTRY BIOS_READ           ; Read a sector
 199:     -	        	    JPTBL_ENTRY BIOS_WRITE          ; Write a sector
 200:				; CP/M 2 functions.
 201:     -	        	    JPTBL_ENTRY BIOS_LISTST         ; Status of list device
 202:     -	        	    JPTBL_ENTRY BIOS_SECTRAN        ; Sector translation for skewing
 203:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 204:     -	        	    JPTBL_ENTRY BIOS_CONOST         ; Status of console output
 205:     -	        	    JPTBL_ENTRY BIOS_AUXIST         ; Status of auxiliary input
 206:     -	        	    JPTBL_ENTRY BIOS_AUXOST         ; Status of auxiliary output
 207:     -	        	    JPTBL_ENTRY BIOS_DEVTBL         ; Address of devices table
 208:     -	        	    JPTBL_ENTRY BIOS_DEVINI         ; Initialise a device
 209:     -	        	    JPTBL_ENTRY BIOS_DRVTBL         ; Address of discs table
 210:     -	        	    JPTBL_ENTRY BIOS_MULTIO         ; Read/write multiple sectors
 211:     -	        	    JPTBL_ENTRY BIOS_FLUSH          ; Flush host buffers
 212:     -	        	    JPTBL_ENTRY BIOS_MOVE           ; Move a block of memory
 213:     -	        	    JPTBL_ENTRY BIOS_TIME           ; Real time clock
 214:     -	        	    JPTBL_ENTRY BIOS_SELMEM         ; Select memory bank
 215:     -	        	    JPTBL_ENTRY BIOS_SETBNK         ; Select bank for DMA operation
 216:     -	        	    JPTBL_ENTRY BIOS_XMOVE          ; Preload banks for MOVE
 217:     -	        	    JPTBL_ENTRY BIOS_USERF          ; System-depedent functions
 218:     -	        	    JPTBL_ENTRY BIOS_RESERV1        ; Reserved
 219:     -	        	    JPTBL_ENTRY BIOS_RESERV2        ; Reserved
 220:				; ZARC-specific items.
 221:     -	        	    JPTBL_BLOCK BIOS_ID, 3          ; BIOS ID ("ZRC")
 222:     -	        	    JPTBL_BLOCK BIOS_VER, 3         ; Version (see below)
 223:     -	        	    JPTBL_ENTRY BIOS_STARTUP        ; CP/M startup entry point
 224:     -	        	    JPTBL_ENTRY BIOS_MON_CALL       ; Call monitor function
 225:     -	        	    JPTBL_ENTRY BIOS_SUPER          ; Set supervisor state
 226:     -	        	    JPTBL_ENTRY BIOS_INT_DISABLE    ; Disable interrupts and keep count
 227:     -	        	    JPTBL_ENTRY BIOS_INT_ENABLE     ; Enable interrupts if safe
 228:     -	        	    JPTBL_ENTRY BIOS_TIRD           ; Read time and date
 229:     -	        	    JPTBL_ENTRY BIOS_SET_TIMER      ; Set timer
 230:     -	        	    JPTBL_ENTRY BIOS_GET_TIMER      ; Get timer
 231:				;
 232:     -	        	    JPTBL_END BIOS_JPTBL_NEXT
 233:				;
 234:				; BIOS_VER is <reserved (zero)>, <major version>, <minor version>. The reserved
 235:				; byte may flag capabilities at some point.
 236:				;
 237:				;
 238:				;
 239:				; **************
 240:				; * BDOS Calls *
 241:				; **************
 242:				;
 243:				;
 244:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Section_5.2
 245:				; In general, the function number is passed in register C with the information
 246:				; address in the double byte pair DE. Single byte values are returned in register
 247:				; A, with double byte values returned in HL. A zero value is returned when the
 248:				; function number is out of range. For reasons of compatibility, register A = L
 249:				; and register B = H upon return in all cases. Example call:
 250:				;   ld c, BDOS_CONIN    ; Read next character
 251:				;   call BDOS           ; Return character in A
 252:				;
 253:     -	0005          	BDOS        equ 5               ; BDOS entry point
 254:				;
 255:     -	0000          	BDOS_SYS_RST        equ 0       ; System Reset
 256:     -	0001          	BDOS_CON_IN         equ 1       ; Console Input
 257:     -	0002          	BDOS_CON_OUT        equ 2       ; Console Output
 258:     -	0003          	BDOS_RDR_IN         equ 3       ; Reader Input
 259:     -	0004          	BDOS_PUN_OUT        equ 4       ; Punch Output
 260:     -	0005          	BDOS_LST_OUT        equ 5       ; List Output
 261:     -	0006          	BDOS_DIRECT_CON_IO  equ 6       ; Direct Console I/O
 262:     -	0007          	BDOS_GET_IO_BYTE    equ 7       ; Get I/O Byte
 263:     -	0008          	BDOS_SET_IO_BYTE    equ 8       ; Set I/O Byte
 264:     -	0009          	BDOS_PRINT_STRING   equ 9       ; Print String
 265:     -	000A          	BDOS_READ_CON_BUFF  equ 10      ; Read Console Buffer
 266:     -	000B          	BDOS_GET_CON_STAT   equ 11      ; Get Console Status
 267:     -	000C          	BDOS_VERSION        equ 12      ; Return Version Number
 268:     -	000D          	BDOS_RESET_DISK_SYS equ 13      ; Reset Disk System
 269:     -	000E          	BDOS_SEL_DISK       equ 14      ; Select Disk
 270:     -	000F          	BDOS_OPEN_FILE      equ 15      ; Open File
 271:     -	0010          	BDOS_CLOSE_FILE     equ 16      ; Close File
 272:     -	0011          	BDOS_SEARCH_FIRST   equ 17      ; Search for First
 273:     -	0012          	BDOS_SEARCH_NEXT    equ 18      ; Search for Next
 274:     -	0013          	BDOS_DELETE_FILE    equ 19      ; Delete File
 275:     -	0014          	BDOS_READ_SEQ       equ 20      ; Read Sequential
 276:     -	0015          	BDOS_WRITE_SEQ      equ 21      ; Write Sequential
 277:     -	0016          	BDOS_MAKE_FILE      equ 22      ; Make File
 278:     -	0017          	BDOS_RENAME_FILE    equ 23      ; Rename File
 279:     -	0018          	BDOS_GET_LOGIN_VEC  equ 24      ; Return Login Vector
 280:     -	0019          	BDOS_GET_CURR_DISK  equ 25      ; Return Current Disk
 281:     -	001A          	BDOS_SET_DMA_ADDR   equ 26      ; Set DMA Address
 282:     -	001B          	BDOS_GET_ALLOC_ADDR equ 27      ; Get Addr (Alloc)
 283:     -	001C          	BDOS_WRITE_PROT     equ 28      ; Write Protect Disk
 284:     -	001D          	BDOS_GET_RO_VEC     equ 29      ; Get R/O Vector
 285:     -	001E          	BDOS_SET_FILE_ATTR  equ 30      ; Set File Attributes
 286:     -	001F          	BDOS_GET_DPB        equ 31      ; Get Addr (Disk Parms)
 287:     -	0020          	BDOS_GET_SET_USER   equ 32      ; Set/Get User Code
 288:     -	0021          	BDOS_READ_RANDOM    equ 33      ; Read Random
 289:     -	0022          	BDOS_WRITE_RANDOM   equ 34      ; Write Random
 290:     -	0023          	BDOS_GET_FILE_SIZE  equ 35      ; Compute File Size
 291:     -	0024          	BDOS_SET_RANDOM_REC equ 36      ; Set Random Record
 292:     -	0025          	BDOS_RESET_DRIVES   equ 37      ; Selectively reset disc drives
 293:     -	0028          	BDOS_WRITE_RAN_ZFILL equ 40     ; Write Random with Zero Fill
 294:				
 295:				; Functions 28 and 32 should be avoided in application programs to maintain upward
 296:				; compatibility with CP/M.
 297:				;
 298:				
**** bios.z80 ****
  71:				                include "disks.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//disks.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Disk Format Include File   *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 13/11/2020                *
   5:				; *******************************************
   6:				;
   7:				; Constants and structures for use when handling disks (memory cards) in the
   8:				; monitor.
   9:				;
  10:				; Master Boot Record (MBR) parameters. This follows the format of the "Structure
  11:				; of a classical generic MBR" at https://en.wikipedia.org/wiki/Master_boot_record#PTE
  12:				; This is consistent what what I found on one of the MMC cards I examined.
  13:     -	AA55          	DSK_BOOT_SIGN               equ 0xaa55
  14:     -	01FE          	DSK_BOOT_SIGN_OFFSET        equ 0x01fe
  15:     -	0004          	DSK_MAX_PARTS               equ 4       ; Maximum allowed in a "classical" MBR
  16:     -	01BE          	DSK_PART1_OFFSET            equ 0x01be
  17:     -	007F          	DSK_PART_TYP_EXPER          equ 0x7f    ; Experimental (no CP/M 2.2 type coded)
  18:				;
  19:				;
  20:				; Partition table entry structure.
  21:				; Derived from https://en.wikipedia.org/wiki/Master_boot_record#PTE
  22:     -	        	                STRUCT
  23:     -	        	                STR_BYTE DPART_STATUS
  24:				; CHS of first sector.
  25:     -	        	                STR_BYTE DPART_START_HD     ; Head
  26:     -	        	                STR_BYTE DPART_START_SEC    ; Cylinder MS bits and sector
  27:     -	        	                STR_BYTE DPART_START_CYL    ; Cylinder
  28:     -	        	                STR_BYTE DPART_TYPE
  29:				; CHS of last sector.
  30:     -	        	                STR_BYTE DPART_END_HD
  31:     -	        	                STR_BYTE DPART_END_SEC
  32:     -	        	                STR_BYTE DPART_END_CYL
  33:				; Logical Block Address (LBA) parameters.
  34:     -	        	                STR_LONG DPART_START_LBA    ; Start sector
  35:     -	        	                STR_LONG DPART_SIZE_SECS    ; Size in sectors
  36:     -	        	                STR_END DPART_SIZE
  37:				
**** bios.z80 ****
  72:				                include "mmc.i"
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//mmc.i ****
   1:				; *******************************************
   2:				; * ZARC Monitor Memory Card Include File   *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 7/8/2020                  *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  26:				            endif
  27:				;
  28:				;
  29:     -	0200          	MMC_SECTOR_SIZE             equ 512     ; Sector size
  30:     -	0009          	MMC_LOG2_SEC_SIZE           equ 9       ; Save number of shifts for above
  31:     -	0040          	MMC_CMD_START               equ 0x40    ; Command start bits (01b) shifted for
  32:				                                        ; command byte
  33:     -	0001          	MMC_CMD_STOP                equ 0x01    ; Stop bit (in CRC byte)
  34:				;
  35:				;
  36:				; Card state (mcstat) states.
  37:     -	        	                ENUM_START
  38:     -	        	                ENUM MMC_STAT_IDLE      ; Not initialised
  39:     -	        	                ENUM MMC_STAT_INIT      ; Initialised (can do raw read / writes)
  40:				
  41:     -	        	                ENUM_END MC_STATES  ; Number of states
  42:				;
  43:				;
  44:				; Memory card command structure
  45:     -	        	                STRUCT
  46:     -	        	                STR_BYTE MMC_CMD    ; Command including start bits
  47:     -	        	                STR_BYTE MMC_ARG1   ; Arguments
  48:     -	        	                STR_BYTE MMC_ARG2   ; Arguments
  49:     -	        	                STR_BYTE MMC_ARG3   ; Arguments
  50:     -	        	                STR_BYTE MMC_ARG4   ; Arguments
  51:     -	        	                STR_BYTE MMC_CRC    ; CRC and stop bit
  52:     -	        	                STR_END MMC_SIZE
  53:				;
  54:				;
  55:				; SPI mode commands (CMDn from MMC-System-Spec-v3.31.pdf chapter 4.9).
  56:     -	0000          	MMC_CMD_GO_IDLE_STATE       equ 0   ; Resets the memory card
  57:     -	0001          	MMC_CMD_SEND_OP_COND        equ 1   ; Sends host capacity support information and init.
  58:     -	0009          	MMC_CMD_SEND_CSD            equ 9   ; Read card specific data
  59:     -	000A          	MMC_CMD_SEND_CID            equ 10  ; Read card identification
  60:     -	000D          	MMC_CMD_SEND_STATUS         equ 13  ; Read card status register
  61:     -	0010          	MMC_CMD_SET_BLOCKLEN        equ 16  ; Set block length (in bytes)
  62:     -	0011          	MMC_CMD_READ_SINGLE_BLOCK   equ 17  ; Reads a block
  63:     -	0018          	MMC_CMD_WRITE_BLOCK         equ 24  ; Writes a block
  64:     -	0037          	MMC_CMD_APP_CMD             equ 55  ; Next command is an application specific command
  65:     -	003B          	MMC_CMD_CRC_ON_OFF          equ 59  ; Turns the CRC option on or off
  66:				;
  67:				; The list describes all the application specific commands supported/reserved by the 
  68:				; memory card. All the following commands shall be preceded with APP_CMD (CMD55).
  69:     -	0029          	MMC_ACMD_MC_SEND_OP_COND    equ 41  ; Sends host capacity support information and init
  70:				;
  71:				; R1 response bits
  72:     -	        	BITDEF MMC_R1_IDLE, 0           ; In idle state
  73:     -	        	BITDEF MMC_R1_ERA_RST, 1        ; Erase reset
  74:     -	        	BITDEF MMC_R1_ILL_CMD, 2        ; Illegal command
  75:     -	        	BITDEF MMC_R1_CMD_CRC_ERR, 3    ; Command CRC error
  76:     -	        	BITDEF MMC_R1_ERA_SEQ_ERR, 4    ; Erase sequence error
  77:     -	        	BITDEF MMC_R1_ADDR_ERR, 5       ; Address error
  78:     -	        	BITDEF MMC_R1_PAR_ERR, 6        ; Parameter error
  79:     -	        	BITDEF MMC_R1_START, 7          ; Zero identifies an R1 response
  80:				;
  81:				;
  82:     -	0006          	MMC_CID_PNM_SIZE      equ 6   ; Product name length (bytes)
  83:				;
  84:				; Card IDentification (CID) register (128 bits)
  85:     -	        	                STRUCT
  86:     -	        	                STR_BYTE MMC_CID_MID    ; Manufacturer ID
  87:     -	        	                STR_WORD MMC_CID_OID    ; OEM/Application ID
  88:     -	        	                STR_BLOCK MMC_CID_PNM, MMC_CID_PNM_SIZE ; Product name
  89:     -	        	                STR_BYTE MMC_CID_PRV    ; Product revision
  90:     -	        	                STR_LONG MMC_CID_PSN    ; Product serial number
  91:     -	        	                STR_BYTE MMC_CID_MDT    ; Manufacturing date
  92:     -	        	                STR_BYTE MMC_CID_CRC    ; CRC7 checksum and "1"
  93:     -	        	                STR_END MMC_CID_SIZE
  94:				;
  95:				;
  96:				; Card-Specific Data (CSD) register (128 bits). It contains a number of bit fields
  97:				; that aren't necessarily byte aligned. In these cases, the entries simply identify
  98:				; the bit numbers contained.
  99:     -	        	                STRUCT
 100:     -	        	                STR_BYTE MMC_CSD_VERSION    ; (127-120) CSD version, spec version
 101:     -	        	                STR_BYTE MMC_CSD_TAAC       ; (119-112) data read access-time-1
 102:     -	        	                STR_BYTE MMC_CSD_NSAC       ; (111-104) data read access-time-2
 103:     -	        	                STR_BYTE MMC_CSD_TR_SPD     ; (103-96) max. data transfer rate
 104:     -	        	                STR_BYTE MMC_CSD_95_88      ; Card command classes (MS 8 bits)
 105:     -	        	                STR_BYTE MMC_CSD_87_80      ; CCC (LS bits) and max. read data length
 106:     -	        	                STR_BYTE MMC_CSD_79_72      ; Flags and C_SIZE bits 10 and 11
 107:     -	        	                STR_BYTE MMC_CSD_71_64      ; C_SIZE bits 2 to 9
 108:     -	        	                STR_BYTE MMC_CSD_63_56      ; C_SIZE bits 1 to 0 and some currents
 109:     -	        	                STR_BYTE MMC_CSD_55_48      ; Currents & C_SIZE_MULT (MS 2 bits)
 110:     -	        	                STR_BYTE MMC_CSD_47_40      ; C_SIZE_MULT (LS bit) and erase size (part)
 111:     -	        	                STR_BYTE MMC_CSD_39_32      ; Erase size (part) and WP group size
 112:     -	        	                STR_BYTE MMC_CSD_31_24      ; WP group enable, ECC and write parameters (part)
 113:     -	        	                STR_BYTE MMC_CSD_23_16      ; Write block lenth (part) and reserved
 114:     -	        	                STR_BYTE MMC_CSD_15_8       ; Flags
 115:     -	        	                STR_BYTE MMC_CSD_CRC        ; CRC7 checksum and "1"
 116:     -	        	                STR_END MMC_CSD_SIZE
 117:				
**** bios.z80 ****
  73:				                include "memory.i"      ; Memory page allocation
**** /home/merlin/Dropbox/ZARC_Z80_Box/github_sw/includes//memory.i ****
   1:				; *******************************************
   2:				; * ZARC Memory Include File                *
   3:				; * Written by: Merlin Skinner              *
   4:				; * Date Started: 24/11/2021                *
   5:				; *******************************************
   6:				;
   7:				;
   8:				; Note that ld80 only considers the first six characters of labels significant.
   9:				;
  10:				; The following conditionals are intended to allow the same include file to be
  11:				; used in the defining module and elsewhere as required. Some includes are used
  12:				; for other applications than the monitor, such as the CP/M BIOS. In these cases,
  13:				; the extern and public statements are not desirable.
  14:				;
  15:     -	0000          	            ifdef monitor           ; Meaningful for monitor build only
  26:				            endif
  27:				;
  28:				; Physical memory constants are found in zarc.i
  29:				;
  30:     -	0004          	MPA_NAME_LEN        equ 4               ; Page owner name length (bytes)
  31:				;
  32:				; Memory map
  33:     -	4000          	MMAP_PAGE_SIZE      equ 0x4000          ; Memory mapping bank / page size
  34:     -	0004          	MMAP_BANKS          equ 4               ; Number of 16 kB banks
  35:     -	0040          	MMAP_PAGES          equ 0x40            ; Number of 16 kB RAM pages
  36:     -	0000          	MMAP_BANK0_START    equ 0x0000
  37:     -	3FFF          	MMAP_BANK0_END      equ 0x3fff
  38:     -	4000          	MMAP_BANK1_START    equ 0x4000
  39:     -	7FFF          	MMAP_BANK1_END      equ 0x7fff
  40:     -	8000          	MMAP_BANK2_START    equ 0x8000
  41:     -	BFFF          	MMAP_BANK2_END      equ 0xbfff
  42:     -	C000          	MMAP_BANK3_START    equ 0xc000
  43:     -	FFFF          	MMAP_BANK3_END      equ 0xffff
  44:				;
  45:				;
  46:				;
  47:				; ****************
  48:				; * Memory Usage *
  49:				; ****************
  50:				;
  51:				;
  52:				; Memory banks setup.
  53:				; 0 (0000 - 3FFF): 3f read only, supervisor - monitor program
  54:				; 1 (4000 - 7FFF): 3e writeable - monitor variables, stacks, buffers etc.
  55:				; 2 (8000 - BFFF): (not used)
  56:				; 3 (C000 - FFFF): (mapped as required)
  57:				;
  58:     -	003F          	MMAP_MON_B0_PAGE    equ 0x3f        ; Page for bank 0
  59:     -	003E          	MMAP_MON_B1_PAGE    equ 0x3e        ; Page for bank 1
  60:				;
  61:     -	0040          	STACKS_SIZE     equ 64              ; Space allocated to normal stacks
  62:				;
  63:     -	7FFF          	HEAP_TOP        equ MMAP_BANK1_END  ; Top (end) of heap space.
  64:				
**** bios.z80 ****
  74:				;
  75:				;
  76:				;
  77:				; *************
  78:				; * Externals *
  79:				; *************
  80:				;
  81:				;
  82:				; None
  83:				;
  84:				;
  85:				;
  86:				; *************
  87:				; * Constants *
  88:				; *************
  89:				;
  90:				;
  91:				; Version
  92:     -	0001          	BIOS_MAJ_VER        equ 1
  93:     -	0005          	BIOS_MIN_VER        equ 5
  94:				;
  95:				; The interrupt stack need only be deep enough to meet the requirements of the
  96:				; interrupt service routines plus a NMI. As the monitor switches to its own
  97:				; stack for NMIs, this is a light requirement.
  98:     -	0010          	INT_STACK_SIZE      equ 16              ; Interrupt service routine stack size
  99:				;
 100:     -	0100          	DISK_SPT            equ 256             ; Sectors per track
 101:     -	01FF          	DISK_DSM            equ 511             ; Maximum block number
 102:     -	0000          	CPM_MIN_PRT_SIZE    equ CPM_SYS_SIZE + (NUM_DISKS * CPM_DISK_SIZE)
 103:     -	8800          	CPM_MIN_PRT_SIZE_MS equ CPM_MIN_PRT_SIZE / MMC_SECTOR_SIZE  ; Minimum partition size in MMC sectors
 104:     -	8000          	CPM_TRACK_SIZE      equ DISK_SPT * CPM_SECTOR_SIZE   ; "Track" size in bytes
 105:     -	0020          	CPM_SYS_TRACKS      equ CPM_SYS_SIZE / CPM_TRACK_SIZE   ; System area size in tracks
 106:     -	0020          	CPM_DRIVE_TRACKS    equ CPM_DISK_SIZE / CPM_TRACK_SIZE  ; Drive size in tracks
 107:				;
 108:				; Console input translation.
 109:     -	0004          	CIT_BUF_MAX_LEN     equ 4               ; Maximum sequence length
 110:     -	0004          	COT_BUF_MAX_LEN     equ 4               ; Maximum sequence length
 111:				;
 112:				;
 113:				; Console output translation state machine states (cot_state).
 114:     -	        	                ENUM_START
 115:     -	        	                ENUM COTST_NORM         ; Normal state
 116:     -	        	                ENUM COTST_ESC          ; Escape received
 117:     -	        	                ENUM COTST_LOAD         ; Cursor load sequence
 118:     -	        	                ENUM COTST_Y            ; Cursor load Y received
 119:     -	        	                ENUM_END COTST_STATES   ; Number of states
 120:				;
 121:     -	0001          	                assert COTST_NORM = 0   ; Code assumes this
 122:				;
 123:				;
 124:				; Console input translation state machine states (cit_state).
 125:     -	        	                ENUM_START
 126:     -	        	                ENUM CITST_NORM         ; Normal state
 127:     -	        	                ENUM CITST_REPLAY       ; Replay unrecognised sequence
 128:     -	        	                ENUM_END CITST_STATES   ; Number of states
 129:				;
 130:     -	0001          	                assert CITST_NORM = 0   ; Code assumes this
 131:				;
 132:				;
 133:				;
 134:				; *************
 135:				; * Main Code *
 136:				; *************
 137:				;
 138:				                aseg
 139:				;
 140:     -	EC00          	                org BIOS_START
 141:				;
 142:     -	002C          	CCP_BDOS_SECTS  equ ($-CCP_START) / CPM_SECTOR_SIZE   ; Number of sectors in CCP and BDOS
 143:     -	0010          	CCP_SECTS       equ (BDOS_START-CCP_START-6) / CPM_SECTOR_SIZE  ; Number of sectors in CCP
 144:				;
 145:				; Jump table.
 146:				; Information from http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.htm
 147:				; Entries here must match the jump table in cpm.i.
 148:    0+10	EC00  C356ED  	                jp BOOT                 ; Cold start routine
 149:   10+10	EC03  C3CAED  	wboot_entry     jp WBOOT                ; Warm boot
 150:   20+10	EC06  C3D5ED  	                jp CONST                ; Console status
 151:   30+10	EC09  C30FEE  	                jp CONIN                ; Console input
 152:   40+10	EC0C  C306EF  	                jp CONOUT               ; Console output
 153:   50+10	EC0F  C33EF0  	                jp PLIST                ; Printer output
 154:   60+10	EC12  C358F0  	                jp PUNCH                ; Paper tape punch output
 155:   70+10	EC15  C372F0  	                jp READER               ; Paper tape reader input
 156:   80+10	EC18  C36CF1  	                jp HOME                 ; Move disc head to track 0
 157:   90+10	EC1B  C38FF1  	                jp SELDSK               ; Select disc drive
 158:  100+10	EC1E  C302F2  	                jp SETTRK               ; Set track number
 159:  110+10	EC21  C330F2  	                jp SETSEC               ; Set sector number
 160:  120+10	EC24  C35EF2  	                jp SETDMA               ; Set DMA address
 161:  130+10	EC27  C38CF2  	                jp READ                 ; Read a sector
 162:  140+10	EC2A  C305F3  	                jp WRITE                ; Write a sector
 163:				; CP/M 2 functions.
 164:  150+10	EC2D  C36BF3  	                jp LISTST               ; Status of list device
 165:  160+10	EC30  C36DF3  	                jp SECTRAN              ; Sector translation for skewing
 166:				; CP/M 3 functions (not supported yet). From https://www.seasip.info/Cpm/bios.html
 167:  170+10	EC33  C371F3  	                jp CONOST               ; Status of console output
 168:  180+10	EC36  C3A2F3  	                jp AUXIST               ; Status of auxiliary input
 169:  190+10	EC39  C3BCF3  	                jp AUXOST               ; Status of auxiliary output
 170:  200+10	EC3C  C3D6F3  	                jp DEVTBL               ; Address of devices table
 171:  210+10	EC3F  C3D9F3  	                jp DEVINI               ; Initialise a device
 172:  220+10	EC42  C3DCF3  	                jp DRVTBL               ; Address of discs table
 173:  230+10	EC45  C3DFF3  	                jp MULTIO               ; Read/write multiple sectors
 174:  240+10	EC48  C3E2F3  	                jp FLUSH                ; Flush host buffers
 175:  250+10	EC4B  C3E5F3  	                jp MOVE                 ; Move a block of memory
 176:  260+10	EC4E  C3E8F3  	                jp TIME                 ; Real time clock
 177:  270+10	EC51  C3EBF3  	                jp SELMEM               ; Select memory bank
 178:  280+10	EC54  C3EEF3  	                jp SETBNK               ; Select bank for DMA operation
 179:  290+10	EC57  C3F1F3  	                jp XMOVE                ; Preload banks for MOVE
 180:  300+10	EC5A  C3F4F3  	                jp USERF                ; System-depedent functions
 181:  310+10	EC5D  C3F7F3  	                jp RESERV1              ; Reserved
 182:  320+10	EC60  C3FAF3  	                jp RESERV2              ; Reserved
 183:				; ZARC-specific items follow.
 184:     -	EC63  5A5243  	                byte "ZRC"              ; ZARC BIOS ID *1
 185:     -	EC66  000105  	                byte 0, BIOS_MAJ_VER, BIOS_MIN_VER  ; BIOS_VER (version)
 186:  330+10	EC69  C381EC  	                jp startup              ; ZARC CP/M startup entry point
 187:  340+10	EC6C  C396F4  	                jp mon_call             ; Call monitor function
 188:  350+10	EC6F  C359F4  	                jp set_super            ; Set supervisor state
 189:  360+10	EC72  C376F5  	                jp int_disable          ; Disable interrupt and keep count
 190:  370+10	EC75  C363F5  	                jp int_enable           ; Enable interrupts if safe.
 191:  380+10	EC78  C382F5  	                jp tird                 ; Read time and date
 192:  390+10	EC7B  C3A2F5  	                jp set_timer            ; Set elapsed time
 193:  400+10	EC7E  C3BDF5  	                jp get_timer            ; Get elapsed timer
 194:				;
 195:     -	0001          	                assert $ = BIOS_JPTBL_NEXT + BIOS_START + 3 ; Verify end
 196:				; *1 - this is "ZARC" truncated to three bytes to maintain alignment with other
 197:				; jumps. This may be useful if the BIOS is ever called from C.
 198:				;
 199:				;
 200:				;
 201:				; ***********
 202:				; * Booting *
 203:				; ***********
 204:				;
 205:				;
 206:				; Entry point from monitor's CPM command. This entry point is ZARC-only, and its
 207:				; primary purpose is to provide a method for passing parameters to the CP/M
 208:				; environment.
 209:				; A - options. See BIOS_OPT_xxx definitions.
 210:				; HL - pointer to memory page numbers (one for each bank)
 211:				; IX - pointer to partition table entry
 212:  410+10	EC81  318CFC  	startup         ld sp, mc_stk_top_p1    ; Use monitor call stack space
 213:  420+13	EC84  3285F7  	                ld (bios_options), a    ; See BIOS_OPT_xxx definitions.
 214:				; Copy page numbers to the BIOS variables area.
 215:  433+10	EC87  1186F7  	                ld de, mem_pages        ; Destination
 216:  443+10	EC8A  010400  	                ld bc, MMAP_CPM_PAGES
 217:  453+16+5	EC8D  EDB0    	                ldir
 218:  469+20	EC8F  DD228CF7	                ld (cpm_part_entry), ix ; Save pointer to partition table entry
 219:				; Reset terminal. Use of the monitor's console I/O routines is safe at
 220:				; this point as interrupts are not yet enabled.
 221:  489+10	EC93  21F3F5  	                ld hl, term_rst_msg
 222:  499+17	EC96  CD8D00  	                call MCALL_CONWMS       ; Print message
 223:				; Display banner message.
 224:  516+10	EC99  21D8F5  	                ld hl, signon_msg
 225:  526+17	EC9C  CD8D00  	                call MCALL_CONWMS       ; Print message
 226:				;
 227:				; Setup assuming no interrupts.
 228:  543+4	EC9F  AF      	                xor a
 229:  547+13	ECA0  328AF7  	                ld (itenfl), a          ; Set int. enable (I/O mode)
 230:  560+13	ECA3  328BF7  	                ld (itdsct), a          ; Reset DI nest count
 231:				;
 232:				; Setup console translation.
 233:  573+13	ECA6  322DF8  	                ld (cot_state), a       ; Console output translation state
 234:  586+13	ECA9  3233F8  	                ld (cit_state), a       ; Console input translation state
 235:  599+13	ECAC  3238F8  	                ld (cit_count), a       ; Number of characters in buffer
 236:  612+13	ECAF  3232F8  	                ld (cot_count), a       ; Number of characters in buffer
 237:				;
 238:				; Set dummy time for use if interrupts are disabled.
 239:  625+10	ECB2  2196F7  	                ld hl, tinow            ; BIOS current time and date
 240:  635+4	ECB5  AF      	                xor a
 241:  639+7	ECB6  0604    	                ld b, 4
 242:  646+7	ECB8  77      	strt_clr_tim_lp ld (hl), a
 243:  653+6	ECB9  23      	                inc hl
 244:  659+8+5	ECBA  10FC    	                djnz strt_clr_tim_lp
 245:				;
 246:				; Enable interrupts unless the "noints" option was specified. This has the
 247:				; following effects:
 248:				; 1) Changes the way console I/O works, ensuring interrupts can run while waiting
 249:				;    for I/O.
 250:				; 2) Allows the tick interrupt to maintain the current time, which speeds up
 251:				;    reading the time enormously.
 252:				; Skip interrupt setup if interrupts are disabled.
 253:  667+13	ECBC  3A85F7  	                ld a, (bios_options)    ; See BIOS_OPT_xxx definitions.
 254:  680+7	ECBF  E602    	                and BIOS_OPT_NOINTS_MASK
 255:  687+7+5	ECC1  280F    	                jr z, strt_ints         ; Jump if interrupts desired
 256:				;
 257:				; "noints" specified. Make sure the FPGA won't generate an INT as we can't stop
 258:				; CP/M programs enabling interrupts (e.g. ZEXALL / ZEXDOC).
 259:  694+4	ECC3  AF      	                xor a
 260:  698+11	ECC4  D308    	                out (IOA_INT_EN), a     ; Disable all interrupts in FPGA
 261:  709+11	ECC6  D30A    	                out (IOA_INT_PEND), a   ; Clear any pending interrupts
 262:				;
 263:				; Ensure than console translation is turned off as this depends
 264:				; on interrupts for timing.
 265:  720+13	ECC8  3A85F7  	                ld a, (bios_options)    ; See BIOS_OPT_xxx definitions.
 266:  733+7	ECCB  F604    	                or BIOS_OPT_RAWCON_MASK
 267:  740+13	ECCD  3285F7  	                ld (bios_options), a
 268:  753+12	ECD0  1869    	                jr strt_ints_done
 269:				;
 270:				; Setup interrupt vectors to point to BIOS service routines.
 271:  765+7	ECD2  3E04    	strt_ints       ld a, INT_TICK_VEC      ; Vector number
 272:  772+10	ECD4  11B7F4  	                ld de, tick_serv        ; Address of service routine
 273:  782+17	ECD7  CD57F5  	                call int_set_vec        ; Set interrupt vector
 274:				;
 275:  799+7	ECDA  3E00    	                ld a, INT_SER1_TX_VEC   ; Vector number
 276:  806+10	ECDC  11FFF4  	                ld de, ser1w_serv       ; Address of service routine
 277:  816+17	ECDF  CD57F5  	                call int_set_vec        ; Set interrupt vector
 278:				;
 279:  833+7	ECE2  3E01    	                ld a, INT_SER1_RX_VEC   ; Vector number
 280:  840+10	ECE4  1115F5  	                ld de, ser1r_serv       ; Address of service routine
 281:  850+17	ECE7  CD57F5  	                call int_set_vec        ; Set interrupt vector
 282:				;
 283:  867+7	ECEA  3E02    	                ld a, INT_SER2_TX_VEC   ; Vector number
 284:  874+10	ECEC  112BF5  	                ld de, ser2w_serv       ; Address of service routine
 285:  884+17	ECEF  CD57F5  	                call int_set_vec        ; Set interrupt vector
 286:				;
 287:  901+7	ECF2  3E03    	                ld a, INT_SER2_RX_VEC   ; Vector number
 288:  908+10	ECF4  1141F5  	                ld de, ser2r_serv       ; Address of service routine
 289:  918+17	ECF7  CD57F5  	                call int_set_vec        ; Set interrupt vector
 290:				;
 291:				; Set Z80 interrupt registers appropriately for the mode we want to use.
 292:  935+8	ECFA  ED5E    	                im 2
 293:  943+7	ECFC  3EFF    	                ld a, high (INT_VEC_TABLE)
 294:  950+9	ECFE  ED47    	                ld i, a
 295:				;
 296:				; Read the hardware RTC and set the tick interrupt maintained copy to the
 297:				; current time. Note that reading the hardware RTC takes a significant amount
 298:				; of time.
 299:  959+17	ED00  CDD200  	                call MCALL_TIRD         ; Read current time and date
 300:				; A - zero (OK) or I2C error code (I2C_ERR_xxx)
 301:				; DEHL - 32-bit time (if no error).
 302:  976+4	ED03  A7      	                and a
 303:  980+7+5	ED04  2810    	                jr z, strt_rtc_ok
 304:				; RTC read error
 305:  987+4	ED06  4F      	                ld c, a
 306:  991+10	ED07  216BF6  	                ld hl, rtc_err_msg      ; "RTC error "
 307: 1001+17	ED0A  CD8D00  	                call MCALL_CONWMS       ; Print "RTC error " message
 308: 1018+4	ED0D  79      	                ld a, c
 309: 1022+17	ED0E  CDA800  	                call MCALL_CWPHBY       ; Print error code in hex
 310: 1039+17	ED11  CD8A00  	                call MCALL_CWNWLN       ; New line
 311: 1056+12	ED14  1815    	                jr strt_rtc_done        ; Continue with default (zero) time
 312:				;
 313: 1068+14	ED16  FD2196F7	strt_rtc_ok     ld iy, tinow
 314: 1082+19	ED1A  FD7500  	                ld (iy + 0), l          ; LS byte
 315: 1101+19	ED1D  FD7401  	                ld (iy + 1), h
 316: 1120+19	ED20  FD7302  	                ld (iy + 2), e
 317: 1139+19	ED23  FD7203  	                ld (iy + 3), d          ; MS byte
 318:				; Set tick counter.
 319: 1158+10	ED26  2195F7  	                ld hl, tikdiv
 320: 1168+10	ED29  3609    	                ld (hl), TICK_FREQ - 1  ; Tick rate in Hz
 321:				;
 322:				; FPGA interrupt controller initialisation.
 323: 1178+7	ED2B  3E10    	strt_rtc_done   ld a, INT_TICK_MASK
 324: 1185+11	ED2D  D30A    	                out (IOA_INT_PEND), a   ; Clear any pending tick interrupt.
 325: 1196+11	ED2F  D308    	                out (IOA_INT_EN), a     ; Enable interrupt
 326:				;
 327: 1207+7	ED31  3E01    	                ld a, 1
 328: 1214+13	ED33  328AF7  	                ld (itenfl), a          ; Flag interrupts enabled
 329: 1227+4	ED36  AF      	                xor a
 330: 1231+13	ED37  328BF7  	                ld (itdsct), a          ; Reset DI nest count
 331: 1244+4	ED3A  FB      	                ei                      ; Global enable
 332:				; Interrupts are now running.
 333:				;
 334:				; Since partitions are only (easily) aligned to 1 MB boundaries, we simply (but
 335:				; somewhat wastefully) reserve another 1 MB for the system files. One could view
 336:				; it as 17 x 1 MB sub-partitions, one for the system and the remainder for CP/M
 337:				; drives. This means the partition size should be 17 MB, but larger is
 338:				; allowable. Subtracting the minimum required size from the actual partition
 339:				; size should not cause a carry.
 340: 1248+19	ED3B  DD5E0C  	strt_ints_done  ld e, (ix + DPART_SIZE_SECS)
 341: 1267+19	ED3E  DD560D  	                ld d, (ix + DPART_SIZE_SECS + 1)
 342: 1286+19	ED41  DD4E0E  	                ld c, (ix + DPART_SIZE_SECS + 2)
 343: 1305+19	ED44  DD460F  	                ld b, (ix + DPART_SIZE_SECS + 3)
 344:				; BCDE - partition size in MMC sectors
 345: 1324+4	ED47  7B      	                ld a, e
 346: 1328+7	ED48  D600    	                sub low CPM_MIN_PRT_SIZE_MS
 347: 1335+4	ED4A  7A      	                ld a, d
 348: 1339+7	ED4B  DE88    	                sbc high CPM_MIN_PRT_SIZE_MS
 349: 1346+4	ED4D  79      	                ld a, c
 350: 1350+7	ED4E  DE00    	                sbc 0
 351: 1357+4	ED50  78      	                ld a, b
 352: 1361+7	ED51  DE00    	                sbc 0
 353: 1368+10+7	ED53  DC4AF4  	                call c, bios_panic
 354:				; The partition is large enough.
 355:				;
 356:				; Drop into cold boot.
 357:				;
 358:				;
 359:				; On entry, these functions swap to the BIOS stack. This allows use of bank
 360:				; switching without concerns about switching the bank containing the stack. This
 361:				; would be especially hazardous as interrupts are normally enabled.
 362:				;
 363:				; -3: Cold start.
 364:				; From https://www.seasip.info/Cpm/bios.html - "This function is completely
 365:				; implementation-dependent and should never be called from user code."
 366:				; Booting is always from drive A, the first in the CP/M partition.
 367:				; Set CP/M context
 368: 1378+10	ED56  318CFC  	BOOT            ld sp, mc_stk_top_p1    ; Use monitor call stack space
 369: 1388+17	ED59  CD85F4  	                call mmap_cpm           ; Ensure CP/M memory map is selected
 370:				; Initialise some zero page locations.
 371: 1405+4	ED5C  AF      	                xor a                   ; Use console for all character I/O
 372: 1409+13	ED5D  320300  	                ld (IOBYTE), a          ; Set I/O byte
 373: 1422+13	ED60  320400  	                ld (CDISK), a           ; Select drive A and user 0
 374:				;
 375:				; Go here to load the CCP and (optionally) the BDOS before jumping to CP/M.
 376:				; As the CCP and BDOS are located in bank 3 (0xc000 to 0xffff), we can use the
 377:				; monitor's memory map and load directly to the required locations.
 378:				; a - number of sectors to load
 379: 1435+7	ED63  3E2C    	boot_load       ld a, CCP_BDOS_SECTS    ; Sector count
 380:				;
 381: 1442+13	ED65  32ACF7  	                ld (load_secs), a       ; Save number of sectors
 382: 1455+4	ED68  47      	                ld b, a
 383: 1459+17	ED69  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
 384: 1476+20	ED6C  DD2A8CF7	                ld ix, (cpm_part_entry) ; Point to partition table entry
 385: 1496+7	ED70  0E00    	                ld c, 0                 ; Starting sector
 386: 1503+10	ED72  110000  	                ld de, 0
 387: 1513+10	ED75  2100D6  	                ld hl, CCP_START        ; Destination address
 388: 1523+11	ED78  C5      	boot_load_loop  push bc
 389: 1534+11	ED79  D5      	                push de
 390:				; CDE - CP/M (128-byte) sector number (offset into partition)
 391:				; HL - destination address
 392:				; IX - pointer to partition table entry structure
 393: 1545+17	ED7A  CDE400  	                call MCALL_CACRS        ; Read CP/M sector
 394:				; A - zero (OK) or error code (SPI_ERR_xxx)
 395:				; HL - updated pointer to buffer (points to location after last written)
 396: 1562+10	ED7D  D1      	                pop de
 397: 1572+10	ED7E  C1      	                pop bc
 398: 1582+4	ED7F  A7      	                and a
 399: 1586+10	ED80  C23EF4  	                jp nz, mmc_error        ; Halt system on error
 400:				; Increment sector.
 401: 1596+6	ED83  13      	                inc de
 402: 1602+4	ED84  7A      	                ld a, d
 403: 1606+4	ED85  B3      	                or e
 404: 1610+7+5	ED86  2001    	                jr nz, boot_ldlp_nc
 405: 1617+4	ED88  0C      	                inc c                   ; Increment if carry occurred
 406: 1621+8+5	ED89  10ED    	boot_ldlp_nc    djnz boot_load_loop
 407:				;
 408:				; Calculate and display CRC if debugging is enabled. The monitor memory map
 409:				; remains throughout.
 410: 1629+13	ED8B  3A85F7  	                ld a, (bios_options)    ; See BIOS_OPT_xxx definitions.
 411: 1642+7	ED8E  E601    	                and BIOS_OPT_DEBUG_MASK
 412: 1649+7+5	ED90  282C    	                jr z, bol_no_debug
 413:				;
 414:				; Debugging messages.
 415:				; Load parameters for cold start (BDOS & CCP) initially.
 416: 1656+10	ED92  2138F6  	                ld hl, cold_crc_msg     ; "BDOS & CCP CRC "
 417: 1666+10	ED95  1100D6  	                ld de, CCP_START
 418: 1676+10	ED98  010016  	                ld bc, BIOS_START - CCP_START   ; Length
 419: 1686+13	ED9B  3AACF7  	                ld a, (load_secs)       ; Fetch number of sectors
 420: 1699+7	ED9E  FE2C    	                cp CCP_BDOS_SECTS
 421: 1706+7+5	EDA0  2806    	                jr z, bol_do_crc        ; Jump on cold start
 422:				; This is a warm start, so modify the parameters appropriately.
 423: 1713+10	EDA2  2155F6  	                ld hl, warm_crc_msg     ; "CCP CRC "
 424: 1723+10	EDA5  010008  	                ld bc, BDOS_START - CCP_START -6    ; Length
 425:				;
 426:				; BC - length
 427:				; DE - start
 428:				; HL - pointer to message
 429: 1733+17	EDA8  CD8D00  	bol_do_crc      call MCALL_CONWMS       ; Print message
 430:				; Generate CRC.
 431: 1750+10	EDAB  210000  	                ld hl, 0                ; Initial CRC
 432: 1760+7	EDAE  1A      	bol_crc_loop    ld a, (de)
 433: 1767+17	EDAF  CDCF00  	                call MCALL_CRC16X       ; CRC-16 (XMODEM)
 434: 1784+6	EDB2  13      	                inc de
 435: 1790+6	EDB3  0B      	                dec bc
 436: 1796+4	EDB4  78      	                ld a, b
 437: 1800+4	EDB5  B1      	                or c
 438: 1804+7+5	EDB6  20F6    	                jr nz, bol_crc_loop
 439:				; HL - required CRC.
 440: 1811+17	EDB8  CDAB00  	                call MCALL_CWPHWD       ; Print HL in hexadecimal
 441: 1828+17	EDBB  CD8A00  	                call MCALL_CWNWLN       ; Write new line characters to console
 442:				;
 443:				; Reset elapsed time.
 444: 1845+10	EDBE  010000  	bol_no_debug    ld bc, 0
 445: 1855+10	EDC1  110000  	                ld de, 0
 446:				; BCDE - 32-bit time in ms (0 to approximately 49.7 days).
 447: 1865+17	EDC4  CDA2F5  	                call set_timer
 448:				; Jump to CP/M.
 449: 1882+10	EDC7  C31AF4  	                jp go_cpm
 450:				;
 451:				;
 452:				; 0: Warm boot - reload command processor (CCP). Modified on 6/7/2021 to load
 453:				; the BDOS as well. Some programmes such as ADV and ZEXDOC rely on this as they
 454:				; overwrite the serial number at the start of the BDOS.
 455: 1892+10	EDCA  318CFC  	WBOOT           ld sp, mc_stk_top_p1    ; Use monitor call stack space
 456:				; Reset the terminal.
 457: 1902+10	EDCD  21F3F5  	                ld hl, term_rst_msg
 458: 1912+17	EDD0  CDFDF3  	                call con_out_msg        ; Print message using CONOUT
 459:				;
 460: 1929+12	EDD3  188E    	                jr boot_load            ; Continue as for cold boot
 461:				;
 462:				;
 463:				;
 464:				; *****************
 465:				; * Character I/O *
 466:				; *****************
 467:				;
 468:				;
 469:				; Using IOBYTE mapping described at https://www.seasip.info/Cpm/iobyte.html
 470:				;
 471:				; Console escape codes are are translated so as to provide the appearance of a
 472:				; simple terminal to applications. Translation is useful because few terminal
 473:				; emulators support ADM-3A, and some CP/M programs cannot support VT-100
 474:				; sequences. Codes based on the VT-52 were chosen for output as it offers
 475:				; relatively simple control codes and is the basis for a variety of later CP/M
 476:				; machines such as the Amstrad PCW range and Spectrum +3. An external VT-100 /
 477:				; ANSI terminal or terminal emulator can then be used with a wide range of CP/M
 478:				; software.
 479:				;
 480:				; Input escape codes are translated to single characters where appropriate. This
 481:				; is the approach taken by later CP/M machines such as the Amstrad PCW range and
 482:				; Spectrum +3.
 483:				;
 484:				; Translation may be disabled by starting CP/M from the monitor with the
 485:				; "rawcon" option. Translation of console input depends on interrupts, so will
 486:				; not function if CP/M is started with the "noints" option.
 487:				;
 488:				; 3: Console status, return 0xff if character ready, 00h if not
 489: 1941+13	EDD5  3A33F8  	CONST           ld a, (cit_state)       ; Console input translation state
 490: 1954+4	EDD8  A7      	                and a
 491: 1958+7+5	EDD9  2803    	                jr z, const_raw         ; CITST_NORM (normal state)
 492:				; Console translation is enabled and we have received an escape sequence that
 493:				; we didn't recognise. There are characters to return, so we need to reflect
 494:				; this in the return code.
 495: 1965+7	EDDB  3EFF    	                ld a, 0xff
 496: 1972+10	EDDD  C9      	                ret
 497:				
 498: 1982+13	EDDE  3A0300  	const_raw       ld a, (IOBYTE)          ; Fetch mapping
 499: 1995+7	EDE1  E603    	                and IOB_CON_MASK
 500:				; A indicates the relevant device.
 501: 2002+10	EDE3  CA8CF0  	                jp z, tty_in_st         ; 0: console printer device (TTY:)
 502: 2012+4	EDE6  3D      	                dec a
 503: 2016+10	EDE7  CAE9F0  	                jp z, crt_in_st         ; 1: console (keyboard and terminal screen).
 504: 2026+4	EDEA  3D      	                dec a
 505: 2030+10	EDEB  CAF5ED  	                jp z, rdr_st            ; 2: batch mode, use current reader dev.
 506: 2040+4	EDEE  3D      	                dec a
 507: 2044+10	EDEF  CAF1F0  	                jp z, uc1_in_st         ; 3: user-defined console device
 508: 2054+17	EDF2  CD4AF4  	                call bios_panic         ; System error monitor entry
 509:				;
 510:				;
 511:				; Get status from current reader device.
 512: 2071+13	EDF5  3A0300  	rdr_st          ld a, (IOBYTE)          ; Fetch mapping
 513: 2084+7	EDF8  E60C    	                and IOB_RDR_MASK
 514:				; A indicates the relevant device.
 515: 2091+10	EDFA  CA8CF0  	                jp z, tty_in_st         ; 0: teletype device (TTY:)
 516: 2101+7	EDFD  D604    	                sub 0x04
 517: 2108+10	EDFF  CAF9F0  	                jp z, ptr_in_st         ; 1: high speed reader device (PTR:)
 518: 2118+7	EE02  D604    	                sub 0x04
 519: 2125+10	EE04  CA27F1  	                jp z, ur1_in_st         ; 2: user-defined reader #1 (UR1:)
 520: 2135+7	EE07  D604    	                sub 0x04
 521: 2142+10	EE09  CA2CF1  	                jp z, ur2_in_st         ; 3: user-defined reader #2 (UR2:)
 522: 2152+17	EE0C  CD4AF4  	                call bios_panic         ; System error monitor entry
 523:				;
 524:				;
 525:				; 6: Console input. Read console character into register A.
 526: 2169+13	EE0F  3A85F7  	CONIN           ld a, (bios_options)
 527: 2182+7	EE12  E604    	                and BIOS_OPT_RAWCON_MASK
 528: 2189+10	EE14  C2EFEE  	                jp nz, raw_conin        ; Skip translation if disabled
 529:				;
 530:				; Console translation is enabled. Unrecognised sequences are
 531:				; transmitted without modification, so applications can still receive VT-100 /
 532:				; ANSI sequences if desired. Translations are:
 533:				; <Esc>[A to 0x1f (^_) - Cursor up
 534:				; <Esc>[B to 0x1e (^^) - Cursor down
 535:				; <Esc>[C to 0x06 (^F) - Cursor right
 536:				; <Esc>[D to 0x01 (^A) - Cursor left
 537:				; <Esc>[1~ to 0x02 (^B) - Home (useful for BBC Basic) *
 538:				; <Esc>[2~ to 0x16 (^V) - Ins (useful for BBC Basic) *
 539:				; <Esc>[3~ to 0x7f - Del (added to ease use with terminal emulators) *
 540:				; <Esc>[4~ to 0x04 (^D) - End (useful for BBC Basic) *
 541:				; <Esc>[5~ to 0x1d (^]) - Page up *
 542:				; <Esc>[6~ to 0x1c (^\) - Page down *
 543:				; * There are no VT-100 keys for these functions.
 544: 2199+13	EE17  3A33F8  	                ld a, (cit_state)
 545: 2212+4	EE1A  A7      	                and a
 546: 2216+7+5	EE1B  2808    	                jr z, cit_norm          ; Jump if COTST_NORM
 547: 2223+7	EE1D  FE01    	                cp CITST_REPLAY         ; Replay unrecognised sequence
 548: 2230+10	EE1F  CAA4EE  	                jp z, cit_replay
 549:				;
 550:				; Panic if state is unknown.
 551: 2240+17	EE22  CD4AF4  	                call bios_panic         ; System error monitor entry
 552:				;
 553:				; Normal state (CITST_NORM).
 554: 2257+17	EE25  CDEFEE  	cit_norm        call raw_conin          ; Fetch next character
 555: 2274+7	EE28  FE1B    	                cp ASCII_ESC
 556: 2281+5+6	EE2A  C0      	                ret nz                  ; Return unless <Esc>
 557:				; The <Esc> may be the beginning of a VT-100 / ANSI CSI, or a single character.
 558:				; We will allow at least one tick before assuming this is an isolated character.
 559:				; At this point, we can't return as we have to return a character, but may or
 560:				; may not want to translate depending on what follows. We will wait for at
 561:				; least one tick to see what follows. Initialise variables.
 562: 2286+11	EE2B  F5      	                push af
 563: 2297+4	EE2C  AF      	                xor a
 564: 2301+13	EE2D  3238F8  	                ld (cit_count), a       ; Number of characters in buffer
 565: 2314+10	EE30  F1      	                pop af                  ; Restore <Esc>
 566: 2324+17	EE31  CDD3EE  	                call cit_store          ; Store character
 567: 2341+7	EE34  3E02    	                ld a, 2
 568: 2348+13	EE36  3239F8  	                ld (cit_timer), a     ; Set timer (1 to 2 ticks)
 569: 2361+17	EE39  CDBCEE  	                call cit_getch          ; Read character or time out
 570: 2378+7+5	EE3C  3859    	                jr c, cit_do_replay     ; Replay sequence on timeout
 571:				; Second character received.
 572: 2385+7	EE3E  FE5B    	                cp "["
 573: 2392+7+5	EE40  2055    	                jr nz, cit_do_replay
 574:				; CSI received. Read the next character.
 575: 2399+17	EE42  CDBCEE  	cit_csi         call cit_getch          ; Read character or time out
 576: 2416+7+5	EE45  3850    	                jr c, cit_do_replay     ; Replay sequence on timeout
 577: 2423+7	EE47  0E1F    	                ld c, ZKEY_CSR_UP
 578: 2430+7	EE49  FE41    	                cp "A"                  ; Cursor up
 579: 2437+7+5	EE4B  286D    	                jr z, cit_ret_char
 580: 2444+7	EE4D  0E1E    	                ld c, ZKEY_CSR_DOWN
 581: 2451+7	EE4F  FE42    	                cp "B"                  ; Cursor down
 582: 2458+7+5	EE51  2867    	                jr z, cit_ret_char
 583: 2465+7	EE53  0E06    	                ld c, ZKEY_CSR_RIGHT
 584: 2472+7	EE55  FE43    	                cp "C"                  ; Cursor right
 585: 2479+7+5	EE57  2861    	                jr z, cit_ret_char
 586: 2486+7	EE59  0E01    	                ld c, ZKEY_CSR_LEFT
 587: 2493+7	EE5B  FE44    	                cp "D"                  ; Cursor left
 588: 2500+7+5	EE5D  285B    	                jr z, cit_ret_char
 589:				; Not a cursor key, but it may be a numeric digit followed by "~".
 590: 2507+7	EE5F  FE30    	                cp "0"
 591: 2514+7+5	EE61  3834    	                jr c, cit_do_replay
 592: 2521+7	EE63  FE3A    	                cp "9" + 1
 593: 2528+7+5	EE65  3030    	                jr nc, cit_do_replay
 594:				; Numeric argument found. Fetch another character.
 595: 2535+17	EE67  CDBCEE  	                call cit_getch          ; Read character or time out
 596: 2552+7+5	EE6A  382B    	                jr c, cit_do_replay     ; Replay sequence on timeout
 597: 2559+7	EE6C  FE7E    	                cp "~"                  ; RUB
 598: 2566+7+5	EE6E  2027    	                jr nz, cit_do_replay
 599:				; We have a sequence of the form <Esc>[<digit>~
 600: 2573+13	EE70  3A36F8  	                ld a, (cit_buffer + 2)  ; Fetch argument
 601: 2586+7	EE73  0E02    	                ld c, ZKEY_HOME
 602: 2593+7	EE75  FE31    	                cp "1"                  ; Home
 603: 2600+7+5	EE77  2841    	                jr z, cit_ret_char
 604: 2607+7	EE79  0E16    	                ld c, ZKEY_INSERT
 605: 2614+7	EE7B  FE32    	                cp "2"                  ; Ins
 606: 2621+7+5	EE7D  283B    	                jr z, cit_ret_char
 607: 2628+7	EE7F  0E7F    	                ld c, ZKEY_DELETE
 608: 2635+7	EE81  FE33    	                cp "3"                  ; Del
 609: 2642+7+5	EE83  2835    	                jr z, cit_ret_char
 610: 2649+7	EE85  0E04    	                ld c, ZKEY_END
 611: 2656+7	EE87  FE34    	                cp "4"                  ; End
 612: 2663+7+5	EE89  282F    	                jr z, cit_ret_char
 613: 2670+7	EE8B  0E1D    	                ld c, ZKEY_PAGE_UP
 614: 2677+7	EE8D  FE35    	                cp "5"                  ; Page up
 615: 2684+7+5	EE8F  2829    	                jr z, cit_ret_char
 616: 2691+7	EE91  0E1C    	                ld c, ZKEY_PAGE_DOWN
 617: 2698+7	EE93  FE36    	                cp "6"                  ; Page down
 618: 2705+7+5	EE95  2823    	                jr z, cit_ret_char
 619:				; Sequence not recognised.
 620:				;
 621:				; <Esc><something> received, where <something> is not recognised. We will
 622:				; supply the received sequence for possible handling by the application.
 623: 2712+7	EE97  3E01    	cit_do_replay   ld a, CITST_REPLAY      ; Replay unrecognised sequence
 624: 2719+13	EE99  3233F8  	                ld (cit_state), a
 625: 2732+11	EE9C  E5      	                push hl
 626: 2743+10	EE9D  2134F8  	                ld hl, cit_buffer       ; Set pointer to first character
 627: 2753+16	EEA0  223AF8  	                ld (cit_buff_ptr), hl
 628: 2769+10	EEA3  E1      	                pop hl
 629:				; Fall into following code to return with the first character from the buffer.
 630:				;
 631:				; We are replaying an unrecognised sequence.
 632:				; Find address in sequence buffer.
 633: 2779+11	EEA4  E5      	cit_replay      push hl
 634: 2790+16	EEA5  2A3AF8  	                ld hl, (cit_buff_ptr)
 635: 2806+7	EEA8  7E      	                ld a, (hl)              ; Fetch character
 636:				; Update pointer.
 637: 2813+6	EEA9  23      	                inc hl
 638: 2819+16	EEAA  223AF8  	                ld (cit_buff_ptr), hl
 639:				; Update counter.
 640: 2835+10	EEAD  2138F8  	                ld hl, cit_count        ; Number of characters in buffer
 641: 2845+11	EEB0  35      	                dec (hl)
 642: 2856+10	EEB1  E1      	                pop hl
 643: 2866+5+6	EEB2  C0      	                ret nz
 644:				; We are about to return the last character. We can stop replaying now.
 645: 2871+11	EEB3  F5      	                push af
 646: 2882+4	EEB4  AF      	                xor a
 647: 2886+13	EEB5  3233F8  	                ld (cit_state), a       ; Set COTST_NORM state
 648: 2899+10	EEB8  F1      	                pop af
 649: 2909+10	EEB9  C9      	                ret
 650:				;
 651:				; Return with character in C.
 652: 2919+4	EEBA  79      	cit_ret_char    ld a, c
 653: 2923+10	EEBB  C9      	                ret
 654:				;
 655:				; Read character or time out (cit_timer reaches zero). If a character is
 656:				; received, it is stored in cit_buffer and returned. Returns with:
 657:				; A - character received if no timeout.
 658:				; Carry flag - set on timeout
 659: 2933+13	EEBC  3A39F8  	cit_getch       ld a, (cit_timer)       ; Fetch timer
 660: 2946+7	EEBF  C6FF    	                add 0xff
 661:				; Carry will be set if timer > 0 (not timed out).
 662: 2953+4	EEC1  3F      	                ccf
 663: 2957+5+6	EEC2  D8      	                ret c
 664: 2962+17	EEC3  CDD5ED  	                call CONST              ; Console status
 665:				; A - 0xff if character ready, 00h if not.
 666: 2979+4	EEC6  A7      	                and a
 667: 2983+7+5	EEC7  28F3    	                jr z, cit_getch
 668:				; A character has been received.
 669: 2990+17	EEC9  CDEFEE  	                call raw_conin          ; Fetch it
 670:				; A - character received
 671: 3007+11	EECC  F5      	                push af
 672: 3018+17	EECD  CDD3EE  	                call cit_store          ; Store character
 673: 3035+10	EED0  F1      	                pop af
 674: 3045+4	EED1  A7      	                and a                   ; Reset carry
 675: 3049+10	EED2  C9      	                ret                     ; Return (no timeout)
 676:				;
 677:				; Store character in console input buffer.
 678:				; A - character to store.
 679: 3059+11	EED3  C5      	cit_store       push bc
 680: 3070+11	EED4  E5      	                push hl
 681: 3081+4	EED5  4F      	                ld c, a
 682: 3085+13	EED6  3A38F8  	                ld a, (cit_count)       ; Number of characters in buffer
 683: 3098+7	EED9  FE04    	                cp CIT_BUF_MAX_LEN
 684: 3105+10+7	EEDB  D44AF4  	                call nc, bios_panic     ; System error monitor entry
 685:				; Find address in sequence buffer.
 686: 3115+10	EEDE  2134F8  	                ld hl, cit_buffer
 687: 3125+4	EEE1  85      	                add l
 688: 3129+4	EEE2  6F      	                ld l, a
 689: 3133+4	EEE3  7C      	                ld a, h
 690: 3137+7	EEE4  CE00    	                adc 0                   ; Propagate carry
 691: 3144+4	EEE6  67      	                ld h, a
 692:				; HL - address in buffer
 693: 3148+7	EEE7  71      	                ld (hl), c              ; Store character
 694:				; Update counter
 695: 3155+10	EEE8  2138F8  	                ld hl, cit_count
 696: 3165+11	EEEB  34      	                inc (hl)
 697: 3176+10	EEEC  E1      	                pop hl
 698: 3186+10	EEED  C1      	                pop bc
 699: 3196+10	EEEE  C9      	                ret
 700:				;
 701:				; Console input with no terminal translation.
 702: 3206+13	EEEF  3A0300  	raw_conin       ld a, (IOBYTE)          ; Fetch mapping
 703: 3219+7	EEF2  E603    	                and IOB_CON_MASK
 704:				; A indicates the relevant device.
 705: 3226+10	EEF4  CA97F0  	                jp z, tty_in            ; 0: console printer device (TTY:)
 706: 3236+4	EEF7  3D      	                dec a
 707: 3240+10	EEF8  CAEBF0  	                jp z, crt_in            ; 1: console (keyboard and terminal screen).
 708: 3250+4	EEFB  3D      	                dec a
 709: 3254+10	EEFC  CA72F0  	                jp z, READER            ; 2: batch mode, use current reader dev.
 710: 3264+4	EEFF  3D      	                dec a
 711: 3268+10	EF00  CAF3F0  	                jp z, uc1_in            ; 3: user-defined console device
 712: 3278+17	EF03  CD4AF4  	                call bios_panic         ; System error monitor entry
 713:				;
 714:				;
 715:				; 9: Console output. Console character output from register C.
 716: 3295+13	EF06  3A85F7  	CONOUT          ld a, (bios_options)
 717: 3308+7	EF09  E604    	                and BIOS_OPT_RAWCON_MASK
 718: 3315+10	EF0B  C227F0  	                jp nz, raw_conout       ; Skip translation if disabled
 719:				;
 720:				; Console translation is enabled. Unrecognised sequences are
 721:				; transmitted without modification, so applications can still send VT-100 /
 722:				; ANSI sequences if desired. Translations are:
 723:				; Esc A to Esc [ A - Cursor up
 724:				; Esc B to Esc [ B - Cursor down
 725:				; Esc C to Esc [ C - Cursor right
 726:				; Esc D to Esc [ D - Cursor left
 727:				; Esc H to Esc [ H - Cursor home
 728:				; Esc J to Esc [ J - Clear to end of display
 729:				; Esc K to Esc [ K - Clear to end of line
 730:				; Esc Y <y> <x> to Esc [ <y> ; <x> H - Set cursor position
 731:				; Esc p to Esc [ 7 m - Reverse video on
 732:				; Esc q to Esc [ 27 m - Normal (positive) video
 733:				; Esc r to Esc [ 4 m - Underline on
 734:				; Esc u to Esc [ 24 m - Underline off
 735: 3325+13	EF0E  3A2DF8  	                ld a, (cot_state)
 736: 3338+4	EF11  A7      	                and a
 737: 3342+7+5	EF12  2811    	                jr z, cot_norm        ; Jump if COTST_NORM
 738: 3349+7	EF14  FE01    	                cp COTST_ESC
 739: 3356+7+5	EF16  2821    	                jr z, cot_esc
 740: 3363+7	EF18  FE02    	                cp COTST_LOAD
 741: 3370+10	EF1A  CAB0EF  	                jp z, cot_load
 742: 3380+7	EF1D  FE03    	                cp COTST_Y
 743: 3387+10	EF1F  CABFEF  	                jp z, cot_y
 744:				; Panic if state is unknown.
 745: 3397+17	EF22  CD4AF4  	                call bios_panic         ; System error monitor entry
 746:				;
 747:				; Normal state (COTST_NORM).
 748: 3414+4	EF25  79      	cot_norm        ld a, c
 749: 3418+7	EF26  FE1B    	                cp ASCII_ESC
 750: 3425+10	EF28  C227F0  	                jp nz, raw_conout       ; Don't tranlate if not Esc
 751:				; Escape found.
 752: 3435+4	EF2B  AF      	                xor a
 753: 3439+13	EF2C  3232F8  	                ld (cot_count), a       ; Flush buffer
 754: 3452+4	EF2F  79      	                ld a, c
 755: 3456+17	EF30  CD0BF0  	                call cot_store          ; Store it
 756: 3473+7	EF33  3E01    	                ld a, COTST_ESC         ; Set state for next character
 757: 3480+13	EF35  322DF8  	                ld (cot_state), a
 758: 3493+10	EF38  C9      	                ret
 759:				;
 760:				; Previous character was an escape.
 761: 3503+4	EF39  79      	cot_esc         ld a, c
 762: 3507+17	EF3A  CD0BF0  	                call cot_store         ; Store it
 763: 3524+4	EF3D  79      	                ld a, c
 764: 3528+7	EF3E  FE41    	                cp "A"
 765: 3535+7+5	EF40  3804    	                jr c, cot_not_arw
 766: 3542+7	EF42  FE45    	                cp "D" + 1
 767: 3549+7+5	EF44  383D    	                jr c, cot_cmd         ; Jump if cursor arrow
 768:				; Not a cursor arrow (up, down, left or right)
 769: 3556+7	EF46  FE48    	cot_not_arw     cp "H"
 770: 3563+7+5	EF48  2839    	                jr z, cot_cmd         ; Cursor home
 771: 3570+7	EF4A  FE4A    	                cp "J"
 772: 3577+7+5	EF4C  2835    	                jr z, cot_cmd         ; Clear to end of display
 773: 3584+7	EF4E  FE4B    	                cp "K"
 774: 3591+7+5	EF50  2831    	                jr z, cot_cmd         ; Clear to end of line
 775: 3598+7	EF52  FE59    	                cp "Y"
 776: 3605+10	EF54  CAAAEF  	                jp z, cot_set_csr     ; Set cursor position
 777: 3615+7	EF57  0E07    	                ld c, 7                 ; VT-100 / ANSI SGR code
 778: 3622+7	EF59  FE70    	                cp "p"
 779: 3629+7+5	EF5B  2833    	                jr z, cot_sgr
 780: 3636+7	EF5D  0E1B    	                ld c, 27                ; VT-100 / ANSI SGR code
 781: 3643+7	EF5F  FE71    	                cp "q"
 782: 3650+7+5	EF61  282D    	                jr z, cot_sgr
 783: 3657+7	EF63  0E04    	                ld c, 4                 ; VT-100 / ANSI SGR code
 784: 3664+7	EF65  FE72    	                cp "r"
 785: 3671+7+5	EF67  2827    	                jr z, cot_sgr
 786: 3678+7	EF69  0E18    	                ld c, 24                ; VT-100 / ANSI SGR code
 787: 3685+7	EF6B  FE75    	                cp "u"
 788: 3692+7+5	EF6D  2821    	                jr z, cot_sgr
 789:				;
 790:				; Unrecognised sequence. Send whatever we received. This code assumes that
 791:				; there is at least one character in cot_buffer.
 792: 3699+13	EF6F  3A32F8  	cot_pass        ld a, (cot_count)       ; Number of characters in buffer
 793: 3712+4	EF72  47      	                ld b, a
 794: 3716+10	EF73  212EF8  	                ld hl, cot_buffer       ; Point to buffer
 795: 3726+7	EF76  4E      	cot_pass_lp     ld c, (hl)
 796: 3733+11	EF77  C5      	                push bc
 797: 3744+11	EF78  E5      	                push hl
 798: 3755+17	EF79  CD27F0  	                call raw_conout
 799: 3772+10	EF7C  E1      	                pop hl
 800: 3782+10	EF7D  C1      	                pop bc
 801: 3792+6	EF7E  23      	                inc hl
 802: 3798+8+5	EF7F  10F5    	                djnz cot_pass_lp
 803: 3806+12	EF81  1808    	                jr cot_to_norm          ; Set normal state and exit
 804:				;
 805:				; Send CSI followed by command.
 806:				; C - command character
 807: 3818+11	EF83  C5      	cot_cmd         push bc
 808: 3829+17	EF84  CDA1EF  	                call cot_csi            ; Send <Esc>[
 809: 3846+10	EF87  C1      	                pop bc
 810: 3856+17	EF88  CD27F0  	                call raw_conout         ; Send cursor move command
 811:				; Set state to normal for the next character.
 812: 3873+4	EF8B  AF      	cot_to_norm     xor a
 813: 3877+13	EF8C  322DF8  	                ld (cot_state), a       ; Set state to COTST_NORM
 814: 3890+10	EF8F  C9      	                ret
 815:				;
 816:				; Select graphics rendition.
 817:				; C - required ANSI / VT-100 SGR code in decimal
 818: 3900+11	EF90  C5      	cot_sgr         push bc
 819: 3911+17	EF91  CDA1EF  	                call cot_csi
 820: 3928+10	EF94  C1      	                pop bc
 821: 3938+4	EF95  79      	                ld a, c
 822: 3942+17	EF96  CDE8EF  	                call cot_dec            ; Send decimal parameter
 823: 3959+7	EF99  0E6D    	                ld c, "m"
 824: 3966+17	EF9B  CD27F0  	                call raw_conout
 825: 3983+10	EF9E  C38BEF  	                jp cot_to_norm          ; Set normal state and exit
 826:				;
 827:				; Send VT-100 CSI sequence ("<Esc>[") to console.
 828: 3993+7	EFA1  0E1B    	cot_csi         ld c, ASCII_ESC
 829: 4000+17	EFA3  CD27F0  	                call raw_conout
 830: 4017+7	EFA6  0E5B    	                ld c, "["
 831: 4024+12	EFA8  187D    	                jr raw_conout
 832:				;
 833:				; Set cursor position sequence (Esc Y). The next characters are <y> and <x>.
 834: 4036+7	EFAA  3E02    	cot_set_csr     ld a, COTST_LOAD
 835: 4043+13	EFAC  322DF8  	                ld (cot_state), a
 836: 4056+10	EFAF  C9      	                ret
 837:				;
 838:				; Cursor load state (COTST_LOAD).
 839: 4066+4	EFB0  79      	cot_load        ld a, c
 840: 4070+17	EFB1  CD0BF0  	                call cot_store          ; Store it
 841: 4087+4	EFB4  79      	                ld a, c                 ; Y coordinate
 842: 4091+7	EFB5  FE20    	                cp 0x20
 843: 4098+7+5	EFB7  38B6    	                jr c, cot_pass          ; Discard if Y is negative
 844: 4105+7	EFB9  3E03    	                ld a, COTST_Y
 845: 4112+13	EFBB  322DF8  	                ld (cot_state), a
 846: 4125+10	EFBE  C9      	                ret
 847:				;
 848:				; Cursor load Y state (COTST_Y).
 849: 4135+4	EFBF  79      	cot_y           ld a, c
 850: 4139+17	EFC0  CD0BF0  	                call cot_store          ; Store it
 851: 4156+4	EFC3  79      	                ld a, c                 ; X coordinate
 852: 4160+7	EFC4  FE20    	                cp 0x20
 853: 4167+7+5	EFC6  38A7    	                jr c, cot_pass          ; Discard if X is negative
 854:				; Send VT-100 console load sequence: <ESC> [ pl ; pc H
 855: 4174+17	EFC8  CDA1EF  	                call cot_csi
 856: 4191+13	EFCB  3A30F8  	                ld a, (cot_buffer + 2)  ; y
 857: 4204+7	EFCE  D61F    	                sub 0x1f                ; Make origin 0x01
 858: 4211+17	EFD0  CDE8EF  	                call cot_dec
 859: 4228+7	EFD3  0E3B    	                ld c, ";"
 860: 4235+17	EFD5  CD27F0  	                call raw_conout
 861: 4252+13	EFD8  3A31F8  	                ld a, (cot_buffer + 3)  ; x
 862: 4265+7	EFDB  D61F    	                sub 0x1f                ; Make origin 0x01
 863: 4272+17	EFDD  CDE8EF  	                call cot_dec
 864: 4289+7	EFE0  0E48    	                ld c, "H"
 865: 4296+17	EFE2  CD27F0  	                call raw_conout
 866: 4313+10	EFE5  C38BEF  	                jp cot_to_norm          ; Set normal state and exit
 867:				;
 868:				; Send decimal number in A to console.
 869: 4323+11	EFE8  C5      	cot_dec         push bc
 870: 4334+7	EFE9  0664    	                ld b, 100
 871: 4341+17	EFEB  CDF9EF  	                call cot_dec_div
 872: 4358+7	EFEE  060A    	                ld b, 10
 873: 4365+17	EFF0  CDF9EF  	                call cot_dec_div
 874: 4382+10	EFF3  C1      	                pop bc
 875:				; Output digit (0 to 9) in A.
 876: 4392+7	EFF4  C630    	cot_dec_digit   add "0"                 ; Convert to ASCII
 877: 4399+4	EFF6  4F      	                ld c, a
 878: 4403+12	EFF7  182E    	                jr raw_conout           ; Send it and return
 879:				; Divide by A by B using repeated subtraction.
 880: 4415+7	EFF9  0E30    	cot_dec_div     ld c, "0"
 881: 4422+4	EFFB  90      	cot_dec_loop    sub b
 882: 4426+7+5	EFFC  3803    	                jr c, cot_dec_carry
 883: 4433+4	EFFE  0C      	                inc c
 884: 4437+12	EFFF  18FA    	                jr cot_dec_loop
 885: 4449+4	F001  80      	cot_dec_carry   add b                   ; Reverse subtract that carried
 886:				; Now A is the remainder and C is the digit.
 887: 4453+11	F002  F5      	                push af
 888: 4464+4	F003  79      	                ld a, c
 889: 4468+7	F004  FE30    	                cp "0"
 890: 4475+10+7	F006  C427F0  	                call nz, raw_conout     ; Output if not zero
 891: 4485+10	F009  F1      	                pop af
 892: 4495+10	F00A  C9      	                ret
 893:				;
 894:				; Store character in console output buffer.
 895:				; A - character to store.
 896: 4505+11	F00B  C5      	cot_store       push bc
 897: 4516+11	F00C  E5      	                push hl
 898: 4527+4	F00D  4F      	                ld c, a
 899: 4531+13	F00E  3A32F8  	                ld a, (cot_count)       ; Number of characters in buffer
 900: 4544+7	F011  FE04    	                cp COT_BUF_MAX_LEN
 901: 4551+10+7	F013  D44AF4  	                call nc, bios_panic     ; System error monitor entry
 902:				; Find address in sequence buffer.
 903: 4561+10	F016  212EF8  	                ld hl, cot_buffer
 904: 4571+4	F019  85      	                add l
 905: 4575+4	F01A  6F      	                ld l, a
 906: 4579+4	F01B  7C      	                ld a, h
 907: 4583+7	F01C  CE00    	                adc 0                   ; Propagate carry
 908: 4590+4	F01E  67      	                ld h, a
 909:				; HL - address in buffer
 910: 4594+7	F01F  71      	                ld (hl), c              ; Store character
 911:				; Update counter
 912: 4601+10	F020  2132F8  	                ld hl, cot_count
 913: 4611+11	F023  34      	                inc (hl)
 914: 4622+10	F024  E1      	                pop hl
 915: 4632+10	F025  C1      	                pop bc
 916: 4642+10	F026  C9      	                ret
 917:				;
 918:				; Console output with no terminal translation.
 919:				; C - character
 920: 4652+13	F027  3A0300  	raw_conout      ld a, (IOBYTE)          ; Fetch mapping
 921: 4665+7	F02A  E603    	                and IOB_CON_MASK
 922:				; A indicates the relevant device.
 923: 4672+10	F02C  CAC5F0  	                jp z, tty_out           ; 0: console printer device (TTY:)
 924: 4682+4	F02F  3D      	                dec a
 925: 4686+10	F030  CAF0F0  	                jp z, crt_out           ; 1: CRT device (CRT:)
 926: 4696+4	F033  3D      	                dec a
 927: 4700+10	F034  CA3EF0  	                jp z, PLIST             ; 2: batch mode, use current list dev.
 928: 4710+4	F037  3D      	                dec a
 929: 4714+10	F038  CAF8F0  	                jp z, uc1_out           ; 3: user-defined console device
 930: 4724+17	F03B  CD4AF4  	                call bios_panic         ; System error monitor entry
 931:				;
 932:				;
 933:				; 12: Printer output (renamed from LIST due to reserved word usage).
 934:				; List character from register C
 935: 4741+13	F03E  3A0300  	PLIST           ld a, (IOBYTE)          ; Fetch mapping
 936: 4754+7	F041  E6C0    	                and IOB_LST_MASK
 937:				; A indicates the relevant device.
 938: 4761+10	F043  CAC5F0  	                jp z, tty_out           ; 0: teletype device (TTY:)
 939: 4771+7	F046  D640    	                sub 0x40
 940: 4778+10	F048  CAF0F0  	                jp z, crt_out           ; 1: CRT device (CRT:)
 941: 4788+7	F04B  D640    	                sub 0x40
 942: 4795+10	F04D  CA68F1  	                jp z, lpt_out           ; 2: line printer device (LPT:)
 943: 4805+7	F050  D640    	                sub 0x40
 944: 4812+10	F052  CA6BF1  	                jp z, ul1_out           ; 3: user-defined list device (UL1:)
 945: 4822+17	F055  CD4AF4  	                call bios_panic         ; System error monitor entry
 946:				;
 947:				;
 948:				; 15: Paper tape punch output character from register C.
 949: 4839+13	F058  3A0300  	PUNCH           ld a, (IOBYTE)          ; Fetch mapping
 950: 4852+7	F05B  E630    	                and IOB_PUN_MASK
 951:				; A indicates the relevant device.
 952: 4859+10	F05D  CAC5F0  	                jp z, tty_out           ; 0: teletype device (TTY:)
 953: 4869+7	F060  D610    	                sub 0x10
 954: 4876+10	F062  CA3CF1  	                jp z, ptp_out           ; 1: high speed punch device (PTP:)
 955: 4886+7	F065  D610    	                sub 0x10
 956: 4893+10	F067  CA62F1  	                jp z, up1_out           ; 2: user-defined punch #1 (UP1:)
 957: 4903+7	F06A  D610    	                sub 0x10
 958: 4910+10	F06C  CA65F1  	                jp z, up2_out           ; 3: user-defined punch #2 (UP2:)
 959: 4920+17	F06F  CD4AF4  	                call bios_panic         ; System error monitor entry
 960:				;
 961:				;
 962:				; 18: Paper tape reader input. Reader character into register A from reader
 963:				; device.
 964: 4937+13	F072  3A0300  	READER          ld a, (IOBYTE)          ; Fetch mapping
 965: 4950+7	F075  E60C    	                and IOB_RDR_MASK
 966:				; A indicates the relevant device.
 967: 4957+10	F077  CA97F0  	                jp z, tty_in            ; 0: teletype device (TTY:)
 968: 4967+7	F07A  D604    	                sub 0x04
 969: 4974+10	F07C  CA04F1  	                jp z, ptr_in            ; 1: high speed reader device (PTR:)
 970: 4984+7	F07F  D604    	                sub 0x04
 971: 4991+10	F081  CA29F1  	                jp z, ur1_in            ; 2: user-defined reader #1 (UR1:)
 972: 5001+7	F084  D604    	                sub 0x04
 973: 5008+10	F086  CA2EF1  	                jp z, ur2_in            ; 3: user-defined reader #2 (UR2:)
 974: 5018+17	F089  CD4AF4  	                call bios_panic         ; System error monitor entry
 975:				;
 976:				;
 977:				;
 978:				; ***********
 979:				; * Devices *
 980:				; ***********
 981:				;
 982:				;
 983:				; Devices are implemented as shown in:
 984:				; http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch1.htm#Table_1-3
 985:				;
 986:				; *** TTY ***
 987:				; Teletype device (slow speed console). This is serial port 1 for ZARC.
 988:				;
 989:				; Input status (is an input character ready?).
 990: 5035+11	F08C  DB10    	tty_in_st       in a, (IOA_SER1_CSR)    ; Read status
 991: 5046+7	F08E  E601    	                and a, SER_CSR_RX_EMPTY_MASK
 992: 5053+7+5	F090  2802    	                jr z, ttyist_char       ; Jump if the FIFO is not empty
 993: 5060+4	F092  AF      	                xor a
 994: 5064+10	F093  C9      	                ret
 995: 5074+7	F094  3EFF    	ttyist_char     ld a, 0xff              ; Flag character available
 996: 5081+10	F096  C9      	                ret
 997:				;
 998:				;
 999:				; Input character. This will wait if no character is available.
1000: 5091+13	F097  3A8AF7  	tty_in          ld a, (itenfl)          ; Fetch int. enable flag (I/O mode)
1001: 5104+4	F09A  A7      	                and a
1002: 5108+7+5	F09B  281A    	                jr z, s1rch_in
1003:				; In normal mode, we will poll the serial receiver to await a character
1004:				; rather than having the hardware stop the machine. This latter method prevents
1005:				; interrupts from being serviced. Basic mode is useful if there are issues with
1006:				; the interrupt system. If the interrupts are disabled, this clearly cannot work
1007:				; so the system panics.
1008: 5115+13	F09D  3A8BF7  	                ld a, (itdsct)          ; DI nest count
1009: 5128+4	F0A0  A7      	                and a
1010: 5132+10+7	F0A1  C44AF4  	                call nz, bios_panic     ; Panic if count != 0
1011:				;
1012:				; The objective of this code is to have the machine halted until we can complete
1013:				; the operation. A simple wait loop would be simpler, but would give no indication
1014:				; that the machine is stalled.
1015:				; We can enable and disable interrupts directly here because we know the DI nest
1016:				; count is zero.
1017: 5142+4	F0A4  F3      	                di
1018: 5146+11	F0A5  DB10    	s1rch_loop      in a, (IOA_SER1_CSR)     ; Read status
1019: 5157+7	F0A7  E601    	                and a, SER_CSR_RX_EMPTY_MASK
1020: 5164+7+5	F0A9  280B    	                jr z, s1rch_in_ei        ; Jump if the FIFO is not empty
1021:				; There is nothing to read in the FIFO. Enable the receiver interrupt before
1022:				; halting so we exit from the halt state when a character arrives. The interrupt
1023:				; service routine simply disables the interrupt, but will also release us from the
1024:				; halt state.
1025: 5171+11	F0AB  DB08    	                in (IOA_INT_EN)
1026: 5182+7	F0AD  F602    	                or INT_SER1_RX_MASK
1027: 5189+11	F0AF  D308    	                out (IOA_INT_EN)
1028:				; Interrupts are only enabled for the halt, so the rest is atomic.
1029: 5200+4	F0B1  FB      	                ei
1030: 5204+4	F0B2  76      	                halt                    ; Halt until the next interrupt
1031: 5208+4	F0B3  F3      	                di
1032: 5212+12	F0B4  18EF    	                jr s1rch_loop
1033:				;
1034: 5224+4	F0B6  FB      	s1rch_in_ei     ei
1035: 5228+11	F0B7  DB11    	s1rch_in        in (IOA_SER1_DATA)
1036: 5239+10	F0B9  C9      	                ret
1037:				;
1038:				;
1039:				; Output status (can the output accept another character?).
1040: 5249+11	F0BA  DB10    	tty_out_st      in a, (IOA_SER1_CSR)    ; Read status
1041: 5260+7	F0BC  E640    	                and a, SER_CSR_TX_FULL_MASK
1042: 5267+7+5	F0BE  2802    	                jr z, ttyost_char       ; Jump if there is space in the FIFO
1043: 5274+4	F0C0  AF      	                xor a
1044: 5278+10	F0C1  C9      	                ret
1045: 5288+7	F0C2  3EFF    	ttyost_char     ld a, 0xff              ; Flag ready
1046: 5295+10	F0C4  C9      	                ret
1047:				;
1048:				;
1049:				; Output character.
1050: 5305+13	F0C5  3A8AF7  	tty_out         ld a, (itenfl)          ; Fetch int. enable flag (I/O mode)
1051: 5318+4	F0C8  A7      	                and a
1052: 5322+7+5	F0C9  281A    	                jr z, s1wch_out
1053:				; In normal mode, we will poll the serial transmitter to await space in the FIFO
1054:				; rather than having the hardware stop the machine. This latter method prevents
1055:				; interrupts from being serviced. Basic mode is useful if there are issues with
1056:				; the interrupt system. If the interrupts are disabled, this clearly cannot work
1057:				; so the system panics.
1058: 5329+13	F0CB  3A8BF7  	                ld a, (itdsct)          ; DI nest count
1059: 5342+4	F0CE  A7      	                and a
1060: 5346+10+7	F0CF  C44AF4  	                call nz, bios_panic     ; Panic if count != 0
1061:				;
1062:				; The objective of this code is to have the machine halted until we can complete
1063:				; the operation. A simple wait loop would be simpler, but would give no indication
1064:				; that the machine is stalled.
1065:				; We can enable and disable interrupts directly here because we know the DI nest
1066:				; count is zero.
1067: 5356+4	F0D2  F3      	                di
1068: 5360+11	F0D3  DB10    	s1wch_loop      in a, (IOA_SER1_CSR)    ; Read status
1069: 5371+7	F0D5  E640    	                and a, SER_CSR_TX_FULL_MASK
1070: 5378+7+5	F0D7  280B    	                jr z, s1wch_out_ei      ; Jump if there is space in the FIFO
1071:				; There is no space in the FIFO. Enable the transmitter interrupt before halting
1072:				; so we exit from the halt state when the buffer has some space. The interrupt
1073:				; service routine simply disables the interrupt, but will also release us from the
1074:				; halt state.
1075: 5385+11	F0D9  DB08    	                in (IOA_INT_EN)
1076: 5396+7	F0DB  F601    	                or INT_SER1_TX_MASK
1077: 5403+11	F0DD  D308    	                out (IOA_INT_EN)
1078:				; Interrupts are only enabled for the halt, so the rest is atomic.
1079: 5414+4	F0DF  FB      	                ei
1080: 5418+4	F0E0  76      	                halt                    ; Halt until the next interrupt
1081: 5422+4	F0E1  F3      	                di
1082: 5426+12	F0E2  18EF    	                jr s1wch_loop
1083:				;
1084: 5438+4	F0E4  FB      	s1wch_out_ei    ei
1085: 5442+4	F0E5  79      	s1wch_out       ld a, c
1086: 5446+11	F0E6  D311    	                out (IOA_SER1_DATA), a
1087: 5457+10	F0E8  C9      	                ret
1088:				;
1089:				;
1090:				; *** CRT ***
1091:				; Cathode ray tube device (high speed console).
1092:				;
1093: 5467+4	F0E9  AF      	crt_in_st       xor a                   ; Flag no character available
1094: 5471+10	F0EA  C9      	                ret
1095:				;
1096: 5481+7	F0EB  3E1A    	crt_in          ld a, 0x1a              ; End of file
1097: 5488+10	F0ED  C9      	                ret
1098:				;
1099: 5498+4	F0EE  AF      	crt_out_st      xor a                   ; Flag not ready
1100: 5502+10	F0EF  C9      	                ret
1101:				;
1102: 5512+10	F0F0  C9      	crt_out         ret
1103:				;
1104:				;
1105:				; *** UC1 ***
1106:				; User-defined console.
1107:				;
1108: 5522+4	F0F1  AF      	uc1_in_st       xor a                   ; Flag no character available
1109: 5526+10	F0F2  C9      	                ret
1110:				;
1111: 5536+7	F0F3  3E1A    	uc1_in          ld a, 0x1a              ; End of file
1112: 5543+10	F0F5  C9      	                ret
1113:				;
1114: 5553+4	F0F6  AF      	uc1_out_st      xor a                   ; Flag not ready
1115: 5557+10	F0F7  C9      	                ret
1116:				;
1117: 5567+10	F0F8  C9      	uc1_out         ret
1118:				;
1119:				;
1120:				; *** PTR ***
1121:				; Paper tape reader (high speed reader). This is serial port 2 (input) for ZARC.
1122:				;
1123: 5577+11	F0F9  DB12    	ptr_in_st       in a, (IOA_SER2_CSR)    ; Read status
1124: 5588+7	F0FB  E601    	                and a, SER_CSR_RX_EMPTY_MASK
1125: 5595+7+5	F0FD  2802    	                jr z, ptrist_char       ; Jump if the FIFO is not empty
1126: 5602+4	F0FF  AF      	                xor a
1127: 5606+10	F100  C9      	                ret
1128: 5616+7	F101  3EFF    	ptrist_char     ld a, 0xff              ; Flag character available
1129: 5623+10	F103  C9      	                ret
1130:				;
1131:				; This will wait if no character is available.
1132: 5633+13	F104  3A8AF7  	ptr_in          ld a, (itenfl)          ; Fetch int. enable flag (I/O mode)
1133: 5646+4	F107  A7      	                and a
1134: 5650+7+5	F108  281A    	                jr z, s2rch_in
1135:				; In normal mode, we will poll the serial receiver to await a character
1136:				; rather than having the hardware stop the machine. This latter method prevents
1137:				; interrupts from being serviced. Basic mode is useful if there are issues with
1138:				; the interrupt system. If the interrupts are disabled, this clearly cannot work
1139:				; so the system panics.
1140: 5657+13	F10A  3A8BF7  	                ld a, (itdsct)          ; DI nest count
1141: 5670+4	F10D  A7      	                and a
1142: 5674+10+7	F10E  C44AF4  	                call nz, bios_panic     ; Panic if count != 0
1143:				;
1144:				; The objective of this code is to have the machine halted until we can complete
1145:				; the operation. A simple wait loop would be simpler, but would give no indication
1146:				; that the machine is stalled.
1147:				; We can enable and disable interrupts directly here because we know the DI nest
1148:				; count is zero.
1149: 5684+4	F111  F3      	                di
1150: 5688+11	F112  DB12    	s2rch_loop      in a, (IOA_SER2_CSR)     ; Read status
1151: 5699+7	F114  E601    	                and a, SER_CSR_RX_EMPTY_MASK
1152: 5706+7+5	F116  280B    	                jr z, s2rch_in_ei        ; Jump if the FIFO is not empty
1153:				; There is nothing to read in the FIFO. Enable the receiver interrupt before
1154:				; halting so we exit from the halt state when a character arrives. The interrupt
1155:				; service routine simply disables the interrupt, but will also release us from the
1156:				; halt state.
1157: 5713+11	F118  DB08    	                in (IOA_INT_EN)
1158: 5724+7	F11A  F608    	                or INT_SER2_RX_MASK
1159: 5731+11	F11C  D308    	                out (IOA_INT_EN)
1160:				; Interrupts are only enabled for the halt, so the rest is atomic.
1161: 5742+4	F11E  FB      	                ei
1162: 5746+4	F11F  76      	                halt                    ; Halt until the next interrupt
1163: 5750+4	F120  F3      	                di
1164: 5754+12	F121  18EF    	                jr s2rch_loop
1165:				;
1166: 5766+4	F123  FB      	s2rch_in_ei     ei
1167: 5770+11	F124  DB13    	s2rch_in        in (IOA_SER2_DATA)
1168: 5781+10	F126  C9      	                ret
1169:				;
1170:				;
1171:				; *** UR1 ***
1172:				; User-defined reader #1.
1173:				;
1174: 5791+4	F127  AF      	ur1_in_st       xor a                   ; Flag no character available
1175: 5795+10	F128  C9      	                ret
1176:				;
1177: 5805+7	F129  3E1A    	ur1_in          ld a, 0x1a              ; End of file
1178: 5812+10	F12B  C9      	                ret
1179:				;
1180:				;
1181:				; *** UR2 ***
1182:				; User-defined reader #2.
1183:				;
1184: 5822+4	F12C  AF      	ur2_in_st       xor a                   ; Flag no character available
1185: 5826+10	F12D  C9      	                ret
1186:				;
1187: 5836+7	F12E  3E1A    	ur2_in          ld a, 0x1a              ; End of file
1188: 5843+10	F130  C9      	                ret
1189:				;
1190:				;
1191:				; *** PTP ***
1192:				; Paper tape punch (high speed punch). This is serial port 2 (output) for ZARC.
1193:				;
1194:				; Output status (can the output accept another character?).
1195: 5853+11	F131  DB12    	ptp_out_st      in a, (IOA_SER2_CSR)    ; Read status
1196: 5864+7	F133  E640    	                and a, SER_CSR_TX_FULL_MASK
1197: 5871+7+5	F135  2802    	                jr z, ptpost_char       ; Jump if there is space in the FIFO
1198: 5878+4	F137  AF      	                xor a
1199: 5882+10	F138  C9      	                ret
1200: 5892+7	F139  3EFF    	ptpost_char     ld a, 0xff              ; Flag ready
1201: 5899+10	F13B  C9      	                ret
1202:				;
1203:				;
1204:				; Output character.
1205: 5909+13	F13C  3A8AF7  	ptp_out         ld a, (itenfl)          ; Fetch int. enable flag (I/O mode)
1206: 5922+4	F13F  A7      	                and a
1207: 5926+7+5	F140  281A    	                jr z, s2wch_out
1208:				; In normal mode, we will poll the serial transmitter to await space in the FIFO
1209:				; rather than having the hardware stop the machine. This latter method prevents
1210:				; interrupts from being serviced. Basic mode is useful if there are issues with
1211:				; the interrupt system. If the interrupts are disabled, this clearly cannot work
1212:				; so the system panics.
1213: 5933+13	F142  3A8BF7  	                ld a, (itdsct)          ; DI nest count
1214: 5946+4	F145  A7      	                and a
1215: 5950+10+7	F146  C44AF4  	                call nz, bios_panic     ; Panic if count != 0
1216:				;
1217:				; The objective of this code is to have the machine halted until we can complete
1218:				; the operation. A simple wait loop would be simpler, but would give no indication
1219:				; that the machine is stalled.
1220:				; We can enable and disable interrupts directly here because we know the DI nest
1221:				; count is zero.
1222: 5960+4	F149  F3      	                di
1223: 5964+11	F14A  DB12    	s2wch_loop      in a, (IOA_SER2_CSR)    ; Read status
1224: 5975+7	F14C  E640    	                and a, SER_CSR_TX_FULL_MASK
1225: 5982+7+5	F14E  280B    	                jr z, s2wch_out_ei      ; Jump if there is space in the FIFO
1226:				; There is no space in the FIFO. Enable the transmitter interrupt before halting
1227:				; so we exit from the halt state when the buffer has some space. The interrupt
1228:				; service routine simply disables the interrupt, but will also release us from the
1229:				; halt state.
1230: 5989+11	F150  DB08    	                in (IOA_INT_EN)
1231: 6000+7	F152  F604    	                or INT_SER2_TX_MASK
1232: 6007+11	F154  D308    	                out (IOA_INT_EN)
1233:				; Interrupts are only enabled for the halt, so the rest is atomic.
1234: 6018+4	F156  FB      	                ei
1235: 6022+4	F157  76      	                halt                    ; Halt until the next interrupt
1236: 6026+4	F158  F3      	                di
1237: 6030+12	F159  18EF    	                jr s2wch_loop
1238:				;
1239: 6042+4	F15B  FB      	s2wch_out_ei    ei
1240: 6046+4	F15C  79      	s2wch_out       ld a, c
1241: 6050+11	F15D  D313    	                out (IOA_SER2_DATA), a
1242: 6061+10	F15F  C9      	                ret
1243:				;
1244:				;
1245:				; *** UP1 ***
1246:				; User-defined punch #1.
1247:				;
1248:				; Output status (can the output accept another character?).
1249: 6071+4	F160  AF      	up1_out_st      xor a                   ; Not ready
1250: 6075+10	F161  C9      	                ret
1251:				;
1252:				;
1253: 6085+10	F162  C9      	up1_out         ret
1254:				;
1255:				;
1256:				; *** UP2 ***
1257:				; User-defined punch #2.
1258:				;
1259:				; Output status (can the output accept another character?).
1260: 6095+4	F163  AF      	up2_out_st      xor a                   ; Not ready
1261: 6099+10	F164  C9      	                ret
1262:				;
1263:				;
1264: 6109+10	F165  C9      	up2_out         ret
1265:				;
1266:				;
1267:				; *** LPT ***
1268:				; Line printer.
1269:				;
1270:				; Output status (can the output accept another character?).
1271: 6119+4	F166  AF      	lpt_out_st      xor a                   ; Not ready
1272: 6123+10	F167  C9      	                ret
1273:				;
1274:				;
1275: 6133+10	F168  C9      	lpt_out         ret
1276:				;
1277:				;
1278:				; *** UL1 ***
1279:				; User-defined list device #1.
1280:				;
1281:				; Output status (can the output accept another character?).
1282: 6143+4	F169  AF      	ul1_out_st      xor a                   ; Not ready
1283: 6147+10	F16A  C9      	                ret
1284:				;
1285:				;
1286: 6157+10	F16B  C9      	ul1_out         ret
1287:				;
1288:				;
1289:				;
1290:				; ***************
1291:				; * Disk System *
1292:				; ***************
1293:				;
1294:				;
1295:				; 21: Move disc head to track 0
1296: 6167+13	F16C  3A85F7  	HOME            ld a, (bios_options)      ; Debugging messages flag
1297: 6180+7	F16F  E601    	                and BIOS_OPT_DEBUG_MASK
1298: 6187+7+5	F171  2817    	                jr z, hm_no_debug
1299:				;
1300:				; Debugging messages.
1301: 6194+20	F173  ED73A8F7	                ld (cpm_sp), sp
1302: 6214+10	F177  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1303: 6224+17	F17A  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1304:				; Monitor context selected.
1305: 6241+10	F17D  21FEF5  	                ld hl, home_msg         ; "<Home>"
1306: 6251+17	F180  CD8D00  	                call MCALL_CONWMS       ; Print message
1307:				; Switch back to the CP/M context.
1308: 6268+17	F183  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1309: 6285+20	F186  ED7BA8F7	                ld sp, (cpm_sp)
1310:				;
1311: 6305+10	F18A  010000  	hm_no_debug     ld bc, 0
1312: 6315+12	F18D  1873    	                jr SETTRK
1313:				;
1314:				;
1315:				; 24: Select disc drive given by C.
1316:				; A responsibility of the SELDSK subroutine is to return the base address of the
1317:				; DPH for the selected drive. The following sequence of operations returns the
1318:				; table address, with a 0000H returned if the selected drive does not exist.
1319:     -	0001          	                assert NUM_DISKS <= NUM_DISKS_MAX
1320: 6327+13	F18F  3A85F7  	SELDSK          ld a, (bios_options)      ; See BIOS_OPT_xxx definitions.
1321: 6340+7	F192  E601    	                and BIOS_OPT_DEBUG_MASK
1322: 6347+7+5	F194  2820    	                jr z, sel_no_debug
1323:				;
1324:				; Debugging messages.
1325: 6354+20	F196  ED73A8F7	                ld (cpm_sp), sp
1326: 6374+10	F19A  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1327: 6384+17	F19D  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1328:				; Monitor context selected.
1329: 6401+10	F1A0  2105F6  	                ld hl, seldsk_msg       ; "<SelDsk "
1330: 6411+17	F1A3  CD8D00  	                call MCALL_CONWMS       ; Print message
1331: 6428+4	F1A6  79      	                ld a, c
1332: 6432+17	F1A7  CDAE00  	                call MCALL_CWPDBY       ; Print A in decimal
1333: 6449+7	F1AA  3E3A    	                ld a, ":"
1334: 6456+17	F1AC  CD6F00  	                call MCALL_CONWCH       ; Write character to the console
1335:				; Switch back to the CP/M context.
1336: 6473+17	F1AF  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1337: 6490+20	F1B2  ED7BA8F7	                ld sp, (cpm_sp)
1338:				;
1339: 6510+10	F1B6  210000  	sel_no_debug    ld hl, 0                ; Error code
1340: 6520+4	F1B9  79      	                ld a, c
1341: 6524+13	F1BA  328EF7  	                ld (sel_drive), a
1342: 6537+7	F1BD  FE10    	                cp NUM_DISKS
1343: 6544+7+5	F1BF  301E    	                jr nc, sd_exit          ; Return with HL=0 if out of range
1344:				; Calculate disk parameter header (DPH) address.
1345: 6551+4	F1C1  69      	                ld l, c
1346: 6555+7	F1C2  2600    	                ld h, 0
1347:     -	0001          	                assert DPH_SIZE = 16
1348: 6562+11	F1C4  29      	                add hl, hl              ; Multiply by 16
1349: 6573+11	F1C5  29      	                add hl, hl
1350: 6584+11	F1C6  29      	                add hl, hl
1351: 6595+11	F1C7  29      	                add hl, hl
1352: 6606+10	F1C8  1176F6  	                ld de, disk_dph_base
1353: 6616+11	F1CB  19      	                add hl, de
1354:				; HL - pointer to DPH for selected drive
1355: 6627+11	F1CC  E5      	                push hl
1356:				; C - drive number
1357:				; Modify the DPB OFF entry appropriately. This will be:
1358:				; CPM_SYS_TRACKS + (CPM_DRIVE_TRACKS * <drive number>)
1359: 6638+10	F1CD  212000  	                ld hl, CPM_SYS_TRACKS   ; Initial offset
1360: 6648+10	F1D0  112000  	                ld de, CPM_DRIVE_TRACKS
1361: 6658+4	F1D3  41      	                ld b, c
1362:				; B - drive number
1363:				; DE - tracks per drive
1364:				; HL - track offset
1365: 6662+4	F1D4  78      	                ld a, b
1366: 6666+4	F1D5  A7      	                and a
1367: 6670+7+5	F1D6  2803    	                jr z, sd_off_end        ; End if drive zero (A)
1368: 6677+11	F1D8  19      	sd_off_loop     add hl, de
1369: 6688+8+5	F1D9  10FD    	                djnz sd_off_loop
1370:				; HL - track offset
1371: 6696+16	F1DB  2283F7  	sd_off_end      ld (disk_dpb_off), hl   ; Set DPB OFF appropriately
1372:				;
1373: 6712+10	F1DE  E1      	                pop hl                  ; Restore pointer to DPH
1374:				;
1375: 6722+13	F1DF  3A85F7  	sd_exit         ld a, (bios_options)      ; See BIOS_OPT_xxx definitions.
1376: 6735+7	F1E2  E601    	                and BIOS_OPT_DEBUG_MASK
1377: 6742+7+5	F1E4  281B    	                jr z, sel_no_debug1
1378:				;
1379:				; Print result
1380: 6749+20	F1E6  ED73A8F7	                ld (cpm_sp), sp
1381: 6769+10	F1EA  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1382: 6779+17	F1ED  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1383:				; Monitor context selected.
1384: 6796+11	F1F0  E5      	                push hl
1385: 6807+17	F1F1  CDAB00  	                call MCALL_CWPHWD       ; Print HL in hexadecimal
1386: 6824+7	F1F4  3E3E    	                ld a, ">"
1387: 6831+17	F1F6  CD6F00  	                call MCALL_CONWCH       ; Write character to the console
1388: 6848+10	F1F9  E1      	                pop hl
1389:				; Switch back to the CP/M context.
1390: 6858+17	F1FA  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1391: 6875+20	F1FD  ED7BA8F7	                ld sp, (cpm_sp)
1392:				;
1393: 6895+10	F201  C9      	sel_no_debug1   ret
1394:				;
1395:				;
1396:				; 27: Set track number. Set track number given by BC.
1397: 6905+13	F202  3A85F7  	SETTRK          ld a, (bios_options)      ; See BIOS_OPT_xxx definitions.
1398: 6918+7	F205  E601    	                and BIOS_OPT_DEBUG_MASK
1399: 6925+7+5	F207  2821    	                jr z, set_no_debug
1400:				;
1401:				; Debugging messages.
1402: 6932+20	F209  ED73A8F7	                ld (cpm_sp), sp
1403: 6952+10	F20D  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1404: 6962+17	F210  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1405:				; Monitor context selected.
1406: 6979+10	F213  210EF6  	                ld hl, settrk_msg       ; "<SetTrk "
1407: 6989+17	F216  CD8D00  	                call MCALL_CONWMS       ; Print message
1408: 7006+4	F219  60      	                ld h, b
1409: 7010+4	F21A  69      	                ld l, c
1410: 7014+17	F21B  CDB100  	                call MCALL_CWPDWD       ; Print HL in decimal
1411: 7031+7	F21E  3E3E    	                ld a, ">"
1412: 7038+17	F220  CD6F00  	                call MCALL_CONWCH       ; Write character to the console
1413:				; Switch back to the CP/M context.
1414: 7055+17	F223  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1415: 7072+20	F226  ED7BA8F7	                ld sp, (cpm_sp)
1416:				;
1417: 7092+4	F22A  60      	set_no_debug    ld h, b
1418: 7096+4	F22B  69      	                ld l, c
1419: 7100+16	F22C  228FF7  	                ld (track), hl
1420: 7116+10	F22F  C9      	                ret
1421:				;
1422:				;
1423:				; 30: Set sector number. Set sector number given by BC.
1424: 7126+13	F230  3A85F7  	SETSEC          ld a, (bios_options)      ; See BIOS_OPT_xxx definitions.
1425: 7139+7	F233  E601    	                and BIOS_OPT_DEBUG_MASK
1426: 7146+7+5	F235  2821    	                jr z, ses_no_debug
1427:				;
1428:				; Debugging messages.
1429: 7153+20	F237  ED73A8F7	                ld (cpm_sp), sp
1430: 7173+10	F23B  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1431: 7183+17	F23E  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1432:				; Monitor context selected.
1433: 7200+10	F241  2117F6  	                ld hl, setsec_msg       ; "<SetSec "
1434: 7210+17	F244  CD8D00  	                call MCALL_CONWMS       ; Print message
1435: 7227+4	F247  60      	                ld h, b
1436: 7231+4	F248  69      	                ld l, c
1437: 7235+17	F249  CDB100  	                call MCALL_CWPDWD       ; Print HL in decimal
1438: 7252+7	F24C  3E3E    	                ld a, ">"
1439: 7259+17	F24E  CD6F00  	                call MCALL_CONWCH       ; Write character to the console
1440:				; Switch back to the CP/M context.
1441: 7276+17	F251  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1442: 7293+20	F254  ED7BA8F7	                ld sp, (cpm_sp)
1443:				;
1444: 7313+4	F258  60      	ses_no_debug    ld h, b
1445: 7317+4	F259  69      	                ld l, c
1446: 7321+16	F25A  2291F7  	                ld (sector), hl
1447: 7337+10	F25D  C9      	                ret
1448:				;
1449:				;
1450:				; 33: Set DMA address. Set DMA address given by BC.
1451: 7347+13	F25E  3A85F7  	SETDMA          ld a, (bios_options)      ; See BIOS_OPT_xxx definitions.
1452: 7360+7	F261  E601    	                and BIOS_OPT_DEBUG_MASK
1453: 7367+7+5	F263  2821    	                jr z, sed_no_debug
1454:				;
1455:				; Debugging messages.
1456: 7374+20	F265  ED73A8F7	                ld (cpm_sp), sp
1457: 7394+10	F269  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1458: 7404+17	F26C  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1459:				; Monitor context selected.
1460: 7421+10	F26F  2120F6  	                ld hl, setdma_msg       ; "<SetDMA "
1461: 7431+17	F272  CD8D00  	                call MCALL_CONWMS       ; Print message
1462: 7448+4	F275  60      	                ld h, b
1463: 7452+4	F276  69      	                ld l, c
1464: 7456+17	F277  CDAB00  	                call MCALL_CWPHWD       ; Print HL in hexadecimal
1465: 7473+7	F27A  3E3E    	                ld a, ">"
1466: 7480+17	F27C  CD6F00  	                call MCALL_CONWCH       ; Write character to the console
1467:				; Switch back to the CP/M context.
1468: 7497+17	F27F  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1469: 7514+20	F282  ED7BA8F7	                ld sp, (cpm_sp)
1470:				;
1471: 7534+4	F286  60      	sed_no_debug    ld h, b
1472: 7538+4	F287  69      	                ld l, c
1473: 7542+16	F288  2293F7  	                ld (dma_addr), hl
1474: 7558+10	F28B  C9      	                ret
1475:				;
1476:				;
1477:				; 36: Read a sector.
1478:				; Returns with:
1479:				; A - 0 if OK, 1 otherwise.
1480: 7568+20	F28C  ED73A8F7	READ            ld (cpm_sp), sp
1481: 7588+10	F290  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1482: 7598+17	F293  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1483:				; Monitor context selected.
1484: 7615+17	F296  CD0DF4  	                call find_lba           ; Find LBA sector number
1485: 7632+20	F299  DD2A8CF7	                ld ix, (cpm_part_entry) ; Point to partition table entry
1486: 7652+10	F29D  21ADF7  	                ld hl, sec_buffer
1487:				; CDE - CP/M (128-byte) sector number (offset into partition)
1488:				; HL - destination address for read data
1489: 7662+17	F2A0  CDE400  	                call MCALL_CACRS        ; CP/M read sector
1490:				; A - zero (OK) or error code (SPI_ERR_xxx)
1491: 7679+4	F2A3  A7      	                and a
1492: 7683+7+5	F2A4  204D    	                jr nz, rw_error         ; Jump on error
1493:				;
1494:				; Successful read. Now copy the data to the DMA location.
1495: 7690+17	F2A6  CD85F4  	rd_ok           call mmap_cpm           ; Swap to CP/M memory map
1496: 7707+20	F2A9  ED7BA8F7	                ld sp, (cpm_sp)
1497: 7727+16	F2AD  2A93F7  	                ld hl, (dma_addr)
1498: 7743+4	F2B0  EB      	                ex de, hl
1499: 7747+10	F2B1  21ADF7  	                ld hl, sec_buffer
1500: 7757+10	F2B4  018000  	                ld bc, CPM_SECTOR_SIZE
1501:				; BC - length
1502:				; DE - destination address
1503:				; HL - sector buffer
1504: 7767+16+5	F2B7  EDB0    	                ldir
1505:				;
1506: 7783+13	F2B9  3A85F7  	                ld a, (bios_options)      ; See BIOS_OPT_xxx definitions.
1507: 7796+7	F2BC  E601    	                and BIOS_OPT_DEBUG_MASK
1508: 7803+7+5	F2BE  2831    	                jr z, rd_no_debug
1509:				;
1510:				; Debugging messages.
1511: 7810+20	F2C0  ED73A8F7	                ld (cpm_sp), sp
1512: 7830+10	F2C4  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1513: 7840+17	F2C7  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1514:				; Monitor context selected.
1515: 7857+10	F2CA  2129F6  	                ld hl, readsec_msg      ; "<Read "
1516: 7867+17	F2CD  CD8D00  	                call MCALL_CONWMS       ; Print message
1517:				; Generate CRC of sector.
1518: 7884+10	F2D0  11ADF7  	                ld de, sec_buffer
1519: 7894+10	F2D3  210000  	                ld hl, 0                ; Initial CRC
1520: 7904+7	F2D6  0680    	                ld b, CPM_SECTOR_SIZE
1521: 7911+7	F2D8  1A      	rd_crc_loop     ld a, (de)
1522: 7918+17	F2D9  CDCF00  	                call MCALL_CRC16X       ; CRC-16 (XMODEM)
1523: 7935+6	F2DC  13      	                inc de
1524: 7941+8+5	F2DD  10F9    	                djnz rd_crc_loop
1525:				; HL - CRC of CP/M sector.
1526: 7949+17	F2DF  CDAB00  	                call MCALL_CWPHWD       ; Print HL in hexadecimal
1527: 7966+7	F2E2  3E3E    	                ld a, ">"
1528: 7973+17	F2E4  CD6F00  	                call MCALL_CONWCH       ; Write character to the console
1529: 7990+17	F2E7  CD8A00  	                call MCALL_CWNWLN       ; Write new line characters to console
1530:				; Switch back to the CP/M context.
1531: 8007+17	F2EA  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1532: 8024+20	F2ED  ED7BA8F7	                ld sp, (cpm_sp)
1533:				;
1534: 8044+4	F2F1  AF      	rd_no_debug     xor a                   ; Flag success
1535: 8048+10	F2F2  C9      	                ret
1536:				;
1537:				; Something went wrong. Used by READ and WRITE routines.
1538: 8058+4	F2F3  4F      	rw_error        ld c, a
1539: 8062+17	F2F4  CD8A00  	                call MCALL_CWNWLN       ; Print new line characters
1540: 8079+4	F2F7  79      	                ld a, c
1541: 8083+17	F2F8  CDE100  	                call MCALL_MCPRER       ; Print memory card error text
1542:				; Set CP/M context and return.
1543: 8100+17	F2FB  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1544: 8117+20	F2FE  ED7BA8F7	                ld sp, (cpm_sp)
1545: 8137+7	F302  3E01    	                ld a, 1                 ; Flag error
1546: 8144+10	F304  C9      	                ret
1547:				;
1548:				;
1549:				; 39: Write a sector
1550:				; Returns with:
1551:				; A - 0 if OK, 1 otherwise.
1552:				; First copy the data to the sector buffer.
1553: 8154+16	F305  2A93F7  	WRITE           ld hl, (dma_addr)
1554: 8170+10	F308  11ADF7  	                ld de, sec_buffer
1555: 8180+10	F30B  018000  	                ld bc, CPM_SECTOR_SIZE
1556: 8190+16+5	F30E  EDB0    	                ldir
1557:				; Switch to monitor context.
1558: 8206+20	F310  ED73A8F7	                ld (cpm_sp), sp
1559: 8226+10	F314  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1560: 8236+17	F317  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1561:				; Monitor context selected.
1562: 8253+17	F31A  CD0DF4  	                call find_lba           ; Find LBA sector number
1563: 8270+20	F31D  DD2A8CF7	                ld ix, (cpm_part_entry) ; Point to partition table entry
1564: 8290+10	F321  21ADF7  	                ld hl, sec_buffer
1565:				; CDE - CP/M (128-byte) sector number (offset into partition)
1566:				; HL - destination address for read data
1567: 8300+17	F324  CDE700  	                call MCALL_CACWS        ; CP/M write sector
1568:				; A - zero (OK) or error code (SPI_ERR_xxx)
1569: 8317+4	F327  A7      	                and a
1570: 8321+7+5	F328  20C9    	                jr nz, rw_error         ; Jump on error
1571:				;
1572:				; Successful write.
1573: 8328+17	F32A  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1574: 8345+20	F32D  ED7BA8F7	                ld sp, (cpm_sp)
1575:				;
1576: 8365+13	F331  3A85F7  	                ld a, (bios_options)      ; See BIOS_OPT_xxx definitions.
1577: 8378+7	F334  E601    	                and BIOS_OPT_DEBUG_MASK
1578: 8385+7+5	F336  2831    	                jr z, wr_no_debug
1579:				;
1580:				; Debugging messages.
1581: 8392+20	F338  ED73A8F7	                ld (cpm_sp), sp
1582: 8412+10	F33C  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1583: 8422+17	F33F  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1584:				; Monitor context selected.
1585: 8439+10	F342  2130F6  	                ld hl, writesec_msg     ; "<Write "
1586: 8449+17	F345  CD8D00  	                call MCALL_CONWMS       ; Print message
1587:				; Generate CRC of sector.
1588: 8466+10	F348  11ADF7  	                ld de, sec_buffer
1589: 8476+10	F34B  210000  	                ld hl, 0                ; Initial CRC
1590: 8486+7	F34E  0680    	                ld b, CPM_SECTOR_SIZE
1591: 8493+7	F350  1A      	wr_crc_loop         ld a, (de)
1592: 8500+17	F351  CDCF00  	                call MCALL_CRC16X       ; CRC-16 (XMODEM)
1593: 8517+6	F354  13      	                inc de
1594: 8523+8+5	F355  10F9    	                djnz wr_crc_loop
1595:				; HL - CRC of CP/M sector.
1596: 8531+17	F357  CDAB00  	                call MCALL_CWPHWD       ; Print HL in hexadecimal
1597: 8548+7	F35A  3E3E    	                ld a, ">"
1598: 8555+17	F35C  CD6F00  	                call MCALL_CONWCH       ; Write character to the console
1599: 8572+17	F35F  CD8A00  	                call MCALL_CWNWLN       ; Write new line characters to console
1600:				; Switch back to the CP/M context.
1601: 8589+17	F362  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1602: 8606+20	F365  ED7BA8F7	                ld sp, (cpm_sp)
1603:				;
1604: 8626+4	F369  AF      	wr_no_debug     xor a                   ; Flag success
1605: 8630+10	F36A  C9      	                ret
1606:				;
1607:				;
1608:				; 42: Status of list device (0 if not ready, 1 if ready).
1609: 8640+4	F36B  AF      	LISTST          xor a                   ; Always unready
1610: 8644+10	F36C  C9      	                ret
1611:				;
1612:				;
1613:				; 45: Sector translation for skewing
1614:				; SECTRAN receives a logical sector number relative to zero in BC and a translate
1615:				; table address in DE. The sector number is used as an index into the translate
1616:				; table, with the resulting physical sector number in HL.
1617: 8654+4	F36D  69      	SECTRAN         ld l, c                 ; No translation required
1618: 8658+4	F36E  60      	                ld h, b
1619: 8662+4	F36F  79      	                ld a, c
1620: 8666+10	F370  C9      	                ret
1621:				;
1622:				;
1623:				;
1624:				; **********
1625:				; * CP/M 3 *
1626:				; **********
1627:				;
1628:				;
1629:				; CP/M 3 functions. Most are not supported, but some are implmented as ZARC
1630:				; extensions. Applications should check for ZARC before calling these.
1631:				;
1632:				;48: Status of console output
1633: 8676+13	F371  3A0300  	CONOST          ld a, (IOBYTE)          ; Fetch mapping
1634: 8689+7	F374  E603    	                and IOB_CON_MASK
1635:				; A indicates the relevant device.
1636: 8696+10	F376  CABAF0  	                jp z, tty_out_st        ; 0: console printer device (TTY:)
1637: 8706+4	F379  3D      	                dec a
1638: 8710+10	F37A  CAEEF0  	                jp z, crt_out_st        ; 1: CRT device (CRT:)
1639: 8720+4	F37D  3D      	                dec a
1640: 8724+10	F37E  CA88F3  	                jp z, list_st           ; 2: batch mode, use current list dev.
1641: 8734+4	F381  3D      	                dec a
1642: 8738+10	F382  CAF6F0  	                jp z, uc1_out_st        ; 3: user-defined console device
1643: 8748+17	F385  CD4AF4  	                call bios_panic         ; System error monitor entry
1644:				;
1645:				; Get status from current list device.
1646: 8765+13	F388  3A0300  	list_st         ld a, (IOBYTE)          ; Fetch mapping
1647: 8778+7	F38B  E6C0    	                and IOB_LST_MASK
1648:				; A indicates the relevant device.
1649: 8785+10	F38D  CABAF0  	                jp z, tty_out_st        ; 0: teletype device (TTY:)
1650: 8795+7	F390  D640    	                sub 0x40
1651: 8802+10	F392  CAEEF0  	                jp z, crt_out_st        ; 1: CRT device (CRT:)
1652: 8812+7	F395  D640    	                sub 0x40
1653: 8819+10	F397  CA66F1  	                jp z, lpt_out_st        ; 2: line printer device (LPT:)
1654: 8829+7	F39A  D640    	                sub 0x40
1655: 8836+10	F39C  CA69F1  	                jp z, ul1_out_st        ; 3: user-defined list device (UL1:)
1656: 8846+17	F39F  CD4AF4  	                call bios_panic         ; System error monitor entry
1657:				;
1658:				;
1659:				;51: Status of auxiliary input (called READER in CP/M 2.x)
1660: 8863+13	F3A2  3A0300  	AUXIST          ld a, (IOBYTE)          ; Fetch mapping
1661: 8876+7	F3A5  E60C    	                and IOB_RDR_MASK
1662:				; A indicates the relevant device.
1663: 8883+10	F3A7  CA8CF0  	                jp z, tty_in_st         ; 0: teletype device (TTY:)
1664: 8893+7	F3AA  D604    	                sub 0x04
1665: 8900+10	F3AC  CAF9F0  	                jp z, ptr_in_st         ; 1: high speed reader device (PTR:)
1666: 8910+7	F3AF  D604    	                sub 0x04
1667: 8917+10	F3B1  CA27F1  	                jp z, ur1_in_st         ; 2: user-defined reader #1 (UR1:)
1668: 8927+7	F3B4  D604    	                sub 0x04
1669: 8934+10	F3B6  CA2CF1  	                jp z, ur2_in_st         ; 3: user-defined reader #2 (UR2:)
1670: 8944+17	F3B9  CD4AF4  	                call bios_panic         ; System error monitor entry
1671:				;
1672:				;
1673:				;54: Status of auxiliary output (called PUNCH in CP/M 2.x)
1674: 8961+13	F3BC  3A0300  	AUXOST          ld a, (IOBYTE)          ; Fetch mapping
1675: 8974+7	F3BF  E630    	                and IOB_PUN_MASK
1676:				; A indicates the relevant device.
1677: 8981+10	F3C1  CABAF0  	                jp z, tty_out_st        ; 0: teletype device (TTY:)
1678: 8991+7	F3C4  D610    	                sub 0x10
1679: 8998+10	F3C6  CA31F1  	                jp z, ptp_out_st        ; 1: high speed punch device (PTP:)
1680: 9008+7	F3C9  D610    	                sub 0x10
1681: 9015+10	F3CB  CA60F1  	                jp z, up1_out_st        ; 2: user-defined punch #1 (UP1:)
1682: 9025+7	F3CE  D610    	                sub 0x10
1683: 9032+10	F3D0  CA63F1  	                jp z, up2_out_st        ; 3: user-defined punch #2 (UP2:)
1684: 9042+17	F3D3  CD4AF4  	                call bios_panic         ; System error monitor entry
1685:				;
1686:				;
1687:				;57: Address of devices table
1688: 9059+17	F3D6  CD4AF4  	DEVTBL          call bios_panic         ; System error monitor entry
1689:				;
1690:				;
1691:				;60: Initialise a device
1692: 9076+17	F3D9  CD4AF4  	DEVINI          call bios_panic         ; System error monitor entry
1693:				;
1694:				;
1695:				;63: Address of discs table
1696: 9093+17	F3DC  CD4AF4  	DRVTBL          call bios_panic         ; System error monitor entry
1697:				;
1698:				;
1699:				;66: Read/write multiple sectors
1700: 9110+17	F3DF  CD4AF4  	MULTIO          call bios_panic         ; System error monitor entry
1701:				;
1702:				;
1703:				;69: Flush host buffers
1704: 9127+17	F3E2  CD4AF4  	FLUSH           call bios_panic         ; System error monitor entry
1705:				;
1706:				;
1707:				;72: Move a block of memory
1708: 9144+17	F3E5  CD4AF4  	MOVE            call bios_panic         ; System error monitor entry
1709:				;
1710:				;
1711:				;75: Real time clock
1712: 9161+17	F3E8  CD4AF4  	TIME            call bios_panic         ; System error monitor entry
1713:				;
1714:				;
1715:				;78: Select memory bank
1716: 9178+17	F3EB  CD4AF4  	SELMEM          call bios_panic         ; System error monitor entry
1717:				;
1718:				;
1719:				;81: Select bank for DMA operation
1720: 9195+17	F3EE  CD4AF4  	SETBNK          call bios_panic         ; System error monitor entry
1721:				;
1722:				;
1723:				;84: Preload banks for MOVE
1724: 9212+17	F3F1  CD4AF4  	XMOVE           call bios_panic         ; System error monitor entry
1725:				;
1726:				;
1727:				;87: System-depedent functions
1728: 9229+17	F3F4  CD4AF4  	USERF           call bios_panic         ; System error monitor entry
1729:				;
1730:				;
1731:				;90: Reserved
1732: 9246+17	F3F7  CD4AF4  	RESERV1         call bios_panic         ; System error monitor entry
1733:				;
1734:				;
1735:				;93: Reserved
1736: 9263+17	F3FA  CD4AF4  	RESERV2         call bios_panic         ; System error monitor entry
1737:				;
1738:				;
1739:				;
1740:				; ***************
1741:				; * Subroutines *
1742:				; ***************
1743:				;
1744:				;
1745:				; Write message to console. This obeys the IOBYTE console redirection rules,
1746:				; unlike calls to the monitor console routines. Call with:
1747:				; HL - pointer to null terminated message.
1748: 9280+11	F3FD  C5      	con_out_msg     push bc
1749: 9291+7	F3FE  7E      	com_loop        ld a, (hl)
1750: 9298+4	F3FF  A7      	                and a
1751: 9302+7+5	F400  2809    	                jr z, com_exit
1752: 9309+4	F402  4F      	                ld c, a
1753: 9313+11	F403  E5      	                push hl
1754: 9324+17	F404  CD06EF  	                call CONOUT             ; Console character output
1755: 9341+10	F407  E1      	                pop hl
1756: 9351+6	F408  23      	                inc hl
1757: 9357+12	F409  18F3    	                jr com_loop
1758: 9369+10	F40B  C1      	com_exit        pop bc
1759: 9379+10	F40C  C9      	                ret
1760:				;
1761:				;
1762:				; Calculate CP/M logical sector number based on selected track and sector numbers.
1763:				; LBA = 256 * track + sector
1764:				; Returns with:
1765:				; CDE - CP/M (128-byte) sector number (offset into partition)
1766:     -	0001          	                assert DISK_SPT = 256
1767: 9389+11	F40D  E5      	find_lba        push hl
1768: 9400+10	F40E  218FF7  	                ld hl, track
1769: 9410+7	F411  56      	                ld d, (hl)
1770: 9417+6	F412  23      	                inc hl
1771: 9423+7	F413  4E      	                ld c, (hl)
1772: 9430+10	F414  2191F7  	                ld hl, sector
1773: 9440+7	F417  5E      	                ld e, (hl)
1774: 9447+10	F418  E1      	                pop hl
1775: 9457+10	F419  C9      	                ret
1776:				;
1777:				;
1778:				; Start CP/M.
1779: 9467+17	F41A  CD85F4  	go_cpm          call mmap_cpm           ; Ensure CP/M memory map is selected
1780:				; Build jump to WBOOT at location zero.
1781: 9484+7	F41D  3EC3    	                ld a, jp
1782: 9491+13	F41F  320000  	                ld (0), a
1783: 9504+10	F422  2103EC  	                ld hl, wboot_entry      ; Warm boot entry point
1784: 9514+16	F425  220100  	                ld (1), hl
1785:				;
1786:				; Set BDOS entry point.
1787: 9530+13	F428  320500  	                ld (BDOS), a            ; Set jump instruction
1788: 9543+10	F42B  2106DE  	                ld hl, BDOS_START
1789: 9553+16	F42E  220600  	                ld (BDOS + 1), hl
1790:				;
1791:				; Set DMA address directly rather than using SETDMA. This avoids a crash in
1792:				; debugging mode due to using the monitor call stack space twice and therefore
1793:				; overwriting the return address.
1794: 9569+10	F431  218000  	                ld hl, 0x0080           ; Set default DMA address
1795: 9579+16	F434  2293F7  	                ld (dma_addr), hl
1796:				;
1797: 9595+13	F437  3A0400  	                ld a, (CDISK)
1798: 9608+4	F43A  4F      	                ld c, a
1799:				; C - current disk number
1800: 9612+10	F43B  C300D6  	                jp CCP_START            ; Pass control to the CCP
1801:				;
1802:				;
1803:				; An MMC error has occurred. Display error message and return to monitor.
1804: 9622+17	F43E  CD7CF4  	mmc_error       call mmap_monitor       ; Swap to monitor memory map
1805: 9639+17	F441  CD8A00  	                call MCALL_CWNWLN       ; Print new line characters
1806: 9656+17	F444  CDE100  	                call MCALL_MCPRER       ; Print memory card error text
1807: 9673+17	F447  CD4AF4  	                call bios_panic
1808:				;
1809:				;
1810:				; Jump to the monitor's "panic" code to return to the debugger in case of a
1811:				; serious error. Go here with a call instruction as this leaves the caller address
1812:				; on the stack, which may be useful when debugging.
1813: 9690+20	F44A  ED73A8F7	bios_panic      ld (cpm_sp), sp
1814: 9710+10	F44E  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1815: 9720+17	F451  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1816:				; Monitor context selected.
1817: 9737+17	F454  CD6C00  	                call MCALL_PANIC        ; System error monitor entry
1818:				; Just in case someone attempts to continue execution from the monitor.
1819: 9754+12	F457  18F1    	                jr bios_panic
1820:				;
1821:				;
1822:				; CP/M programmes should call this to enable or disable supervisor access
1823:				; for banks 0 to 2. Bank 3 (0xc000 to 0xffff) is left unchanged as the BIOS
1824:				; always requires supervisor mode in order to function. Without supervisor
1825:				; mode, any attempt to access I/O will result in a NMI and subsequent return
1826:				; to the monitor. Call with:
1827:				; A - non-zero to enable supervisor mode, zero to disable.
1828:				; Stack location is not critical as the page numbers are not changed.
1829: 9766+11	F459  C5      	set_super       push bc
1830: 9777+11	F45A  D5      	                push de
1831: 9788+11	F45B  E5      	                push hl
1832: 9799+7	F45C  1E00    	                ld e, 0
1833: 9806+4	F45E  A7      	                and a
1834: 9810+7+5	F45F  2802    	                jr z, sets_mask_dn      ; Jump if disable requested
1835: 9817+7	F461  1E40    	                ld e, MMAP_SUPER_MASK
1836: 9824+7	F463  0603    	sets_mask_dn    ld b, 3                 ; Loop for banks 0 to 2
1837: 9831+7	F465  0E04    	                ld c, IOA_MMAP_0        ; I/O address
1838: 9838+10	F467  2186F7  	                ld hl, mem_pages        ; Point to allocated page numbers
1839: 9848+7	F46A  7E      	sets_loop       ld a, (hl)
1840: 9855+7	F46B  E63F    	                and MMAP_PAGE_MASK      ; Isolate page bits
1841: 9862+4	F46D  B3      	                or e                    ; Set supervisor mode if requested
1842: 9866+7	F46E  77      	                ld (hl), a
1843: 9873+12	F46F  ED79    	                out (c), a              ; Set memory mapping
1844: 9885+6	F471  23      	                inc hl
1845: 9891+4	F472  0C      	                inc c
1846: 9895+8+5	F473  10F5    	                djnz sets_loop
1847:				; Bank 3 (0xc000 to 0xffff) is left unchanged as the BIOS always requires
1848:				; supervisor mode in order to function.
1849: 9903+17	F475  CD85F4  	                call mmap_cpm           ; Apply the new map state
1850: 9920+10	F478  E1      	                pop hl
1851: 9930+10	F479  D1      	                pop de
1852: 9940+10	F47A  C1      	                pop bc
1853: 9950+10	F47B  C9      	                ret
1854:				;
1855:				;
1856:				;
1857:				; Set monitor memory map. Ensure stack is in bank 3 to avoid trouble.
1858:				; Set bank 0 (0x0000 to 0x3fff) read-only with I/O access.
1859: 9960+7	F47C  3EFF    	mmap_monitor    ld a, MMAP_MON_B0_PAGE + MMAP_PROT_MASK + MMAP_SUPER_MASK
1860: 9967+11	F47E  D304    	                out (IOA_MMAP_0), a
1861:				; Bank 1 (0x4000 to 0x7fff) writeable (monitor's variables).
1862: 9978+7	F480  3E3E    	                ld a, MMAP_MON_B1_PAGE
1863: 9985+11	F482  D305    	                out (IOA_MMAP_1), a
1864:				; Bank 2 (0x8000 to 0xbfff) not used, but may be set as required.
1865:				; Bank 3 (0xc000 to 0xffff) unchanged.
1866: 9996+10	F484  C9      	                ret
1867:				;
1868:				; Set CP/M memory map. Ensure stack is in bank 3 to avoid trouble.
1869:				; Set bank 0 to 2 to the allocated pages.
1870:10006+11	F485  E5      	mmap_cpm        push hl
1871:10017+10	F486  2186F7  	                ld hl, mem_pages        ; Point to allocated page numbers
1872:10027+7	F489  7E      	                ld a, (hl)
1873:10034+11	F48A  D304    	                out (IOA_MMAP_0), a     ; Bank 0 (0x0000 to 0x3fff)
1874:10045+6	F48C  23      	                inc hl
1875:10051+7	F48D  7E      	                ld a, (hl)
1876:10058+11	F48E  D305    	                out (IOA_MMAP_1), a     ; Bank 1 (0x4000 to 0x7fff)
1877:10069+6	F490  23      	                inc hl
1878:10075+7	F491  7E      	                ld a, (hl)
1879:10082+11	F492  D306    	                out (IOA_MMAP_2), a     ; Bank 2 (0x8000 to 0xbfff)
1880:				; Bank 3 (0xc000 to 0xffff) unchanged.
1881:10093+10	F494  E1      	                pop hl
1882:10103+10	F495  C9      	                ret
1883:				;
1884:				;
1885:				; This routine allows CP/M applications to call some monitor functions. Any
1886:				; function that accesses memory must be used with caution as banks 0 and 1 will
1887:				; be changed to select the monitor's environment. Call with:
1888:				; DE - pointer to monitor function
1889:				; Alternate registers - parameters for the function to be called.
1890:				; Returns with results in alternate register set.
1891:10113+20	F496  ED73A8F7	mon_call        ld (cpm_sp), sp
1892:10133+10	F49A  318CFC  	                ld sp, mc_stk_top_p1    ; Use monitor call stack space
1893:				; Set the routine address.
1894:10143+4	F49D  7B      	                ld a, e                 ; Set LSB
1895:10147+13	F49E  32ABF4  	                ld (mc_call_instr + 1), a
1896:10160+4	F4A1  7A      	                ld a, d                 ; Set MSB
1897:10164+13	F4A2  32ACF4  	                ld (mc_call_instr + 2), a
1898:10177+17	F4A5  CD7CF4  	                call mmap_monitor       ; Swap to monitor memory map
1899:				; Monitor context selected. Make the call.
1900:10194+4	F4A8  08      	                ex af, af'
1901:10198+4	F4A9  D9      	                exx
1902:10202+17	F4AA  CD0000  	mc_call_instr   call 0                  ; Address will be inserted
1903:10219+4	F4AD  08      	                ex af, af'
1904:10223+4	F4AE  D9      	                exx
1905:				; Switch back to the CP/M context.
1906:10227+17	F4AF  CD85F4  	                call mmap_cpm           ; Swap to CP/M memory map
1907:10244+20	F4B2  ED7BA8F7	                ld sp, (cpm_sp)
1908:10264+10	F4B6  C9      	                ret
1909:				;
1910:				;
1911:				;
1912:				; ******************************
1913:				; * Interrupt Service Routines *
1914:				; ******************************
1915:				;
1916:				;
1917:				; These routines minimise stack requirements as the CP/M CCP stack (for example)
1918:				; is very shallow.
1919:				;
1920:				; Tick interrupt service routine.
1921:10274+20	F4B7  ED73AAF7	tick_serv       ld (bg_sp), sp          ; Swap to interrupt stack
1922:10294+10	F4BB  314CFC  	                ld sp, int_stk_top_p1
1923:				;
1924:10304+11	F4BE  F5      	                push af
1925:10315+11	F4BF  E5      	                push hl
1926:				;
1927:				; Update console input translation timer.
1928:10326+13	F4C0  3A39F8  	                ld a, (cit_timer)
1929:10339+4	F4C3  3D      	                dec a
1930:10343+10	F4C4  FACAF4  	                jp m, ts_cit_done     ; Skip store if negative
1931:10353+13	F4C7  3239F8  	                ld (cit_timer), a
1932:				;
1933:				; Update elapsed time.
1934:10366+10	F4CA  219AF7  	ts_cit_done   ld hl, el_time
1935:10376+7	F4CD  3E64    	                ld a, MS_PER_TICK
1936:10383+7	F4CF  86      	                add (hl)
1937:10390+7	F4D0  77      	                ld (hl), a
1938:10397+7+5	F4D1  300A    	                jr nc, ts_eti_done
1939:10404+6	F4D3  23      	                inc hl
1940:10410+11	F4D4  34      	                inc (hl)
1941:10421+7+5	F4D5  2006    	                jr nz, ts_eti_done
1942:10428+6	F4D7  23      	                inc hl
1943:10434+11	F4D8  34      	                inc (hl)
1944:10445+7+5	F4D9  2002    	                jr nz, ts_eti_done
1945:10452+6	F4DB  23      	                inc hl
1946:10458+11	F4DC  34      	                inc (hl)
1947:				;
1948:				; Update tick divider
1949:10469+10	F4DD  2195F7  	ts_eti_done     ld hl, tikdiv
1950:10479+11	F4E0  35      	                dec (hl)
1951:10490+10	F4E1  FAF6F4  	                jp m, ts_exit           ; Exit unless overflow
1952:				; Goes here once per second.
1953:10500+10	F4E4  3609    	                ld (hl), TICK_FREQ - 1  ; Reset divider
1954:				; Increment time.
1955:10510+10	F4E6  2196F7  	                ld hl, tinow
1956:10520+11	F4E9  34      	                inc (hl)
1957:10531+7+5	F4EA  200A    	                jr nz, ts_exit
1958:10538+6	F4EC  23      	                inc hl
1959:10544+11	F4ED  34      	                inc (hl)
1960:10555+7+5	F4EE  2006    	                jr nz, ts_exit
1961:10562+6	F4F0  23      	                inc hl
1962:10568+11	F4F1  34      	                inc (hl)
1963:10579+7+5	F4F2  2002    	                jr nz, ts_exit
1964:10586+6	F4F4  23      	                inc hl
1965:10592+11	F4F5  34      	                inc (hl)
1966:				;
1967:10603+10	F4F6  E1      	ts_exit         pop hl
1968:10613+10	F4F7  F1      	                pop af
1969:				;
1970:10623+20	F4F8  ED7BAAF7	                ld sp, (bg_sp)          ; Restore SP
1971:10643+4	F4FC  FB      	                ei
1972:10647+14	F4FD  ED4D    	                reti
1973:				;
1974:				;
1975:				; Serial port 1 write interrupt service routine. This simply disables the
1976:				; interrupt, but as it is an interrupt it will also release the I/O code from its
1977:				; halt state.
1978:10661+20	F4FF  ED73AAF7	ser1w_serv      ld (bg_sp), sp          ; Swap to interrupt stack
1979:10681+10	F503  314CFC  	                ld sp, int_stk_top_p1
1980:				;
1981:10691+11	F506  F5      	                push af
1982:				; Disable this interrupt to prevent us from locking up, forever servicing this
1983:				; interrupt.
1984:10702+11	F507  DB08    	                in (IOA_INT_EN)
1985:10713+7	F509  E6FE    	                and not (INT_SER1_TX_MASK)
1986:10720+11	F50B  D308    	                out (IOA_INT_EN)
1987:10731+10	F50D  F1      	                pop af
1988:				;
1989:10741+20	F50E  ED7BAAF7	                ld sp, (bg_sp)          ; Restore SP
1990:10761+4	F512  FB      	                ei
1991:10765+14	F513  ED4D    	                reti
1992:				;
1993:				;
1994:				; Serial port 1 read interrupt service routine. This simply disables the
1995:				; interrupt, but as it is an interrupt it will also release the I/O code from its
1996:				; halt state.
1997:10779+20	F515  ED73AAF7	ser1r_serv      ld (bg_sp), sp          ; Swap to interrupt stack
1998:10799+10	F519  314CFC  	                ld sp, int_stk_top_p1
1999:				;
2000:10809+11	F51C  F5      	                push af
2001:				; Disable this interrupt to prevent us from locking up, forever servicing this
2002:				; interrupt.
2003:10820+11	F51D  DB08    	                in (IOA_INT_EN)
2004:10831+7	F51F  E6FD    	                and not (INT_SER1_RX_MASK)
2005:10838+11	F521  D308    	                out (IOA_INT_EN)
2006:10849+10	F523  F1      	                pop af
2007:				;
2008:10859+20	F524  ED7BAAF7	                ld sp, (bg_sp)          ; Restore SP
2009:10879+4	F528  FB      	                ei
2010:10883+14	F529  ED4D    	                reti
2011:				;
2012:				;
2013:				; Serial port 2 write interrupt service routine. This simply disables the
2014:				; interrupt, but as it is an interrupt it will also release the I/O code from its
2015:				; halt state.
2016:10897+20	F52B  ED73AAF7	ser2w_serv      ld (bg_sp), sp          ; Swap to interrupt stack
2017:10917+10	F52F  314CFC  	                ld sp, int_stk_top_p1
2018:				;
2019:10927+11	F532  F5      	                push af
2020:				; Disable this interrupt to prevent us from locking up, forever servicing this
2021:				; interrupt.
2022:10938+11	F533  DB08    	                in (IOA_INT_EN)
2023:10949+7	F535  E6FB    	                and not (INT_SER2_TX_MASK)
2024:10956+11	F537  D308    	                out (IOA_INT_EN)
2025:10967+10	F539  F1      	                pop af
2026:				;
2027:10977+20	F53A  ED7BAAF7	                ld sp, (bg_sp)          ; Restore SP
2028:10997+4	F53E  FB      	                ei
2029:11001+14	F53F  ED4D    	                reti
2030:				;
2031:				;
2032:				; Serial port 2 read interrupt service routine. This simply disables the
2033:				; interrupt, but as it is an interrupt it will also release the I/O code from its
2034:				; halt state.
2035:11015+20	F541  ED73AAF7	ser2r_serv      ld (bg_sp), sp          ; Swap to interrupt stack
2036:11035+10	F545  314CFC  	                ld sp, int_stk_top_p1
2037:				;
2038:11045+11	F548  F5      	                push af
2039:				; Disable this interrupt to prevent us from locking up, forever servicing this
2040:				; interrupt.
2041:11056+11	F549  DB08    	                in (IOA_INT_EN)
2042:11067+7	F54B  E6F7    	                and not (INT_SER2_RX_MASK)
2043:11074+11	F54D  D308    	                out (IOA_INT_EN)
2044:11085+10	F54F  F1      	                pop af
2045:				;
2046:11095+20	F550  ED7BAAF7	                ld sp, (bg_sp)          ; Restore SP
2047:11115+4	F554  FB      	                ei
2048:11119+14	F555  ED4D    	                reti
2049:				;
2050:				;
2051:				; Set interrupt vector to point to a new service routine.
2052:				; Call with:
2053:				; A - number of vector to change
2054:				; DE - points to the new service routine
2055:11133+11	F557  E5      	int_set_vec     push hl
2056:11144+10	F558  21E0FF  	                ld hl, INT_VEC_TABLE    ; Base of vector table
2057:11154+4	F55B  87      	                add a                   ; Each entry is two bytes long
2058:11158+4	F55C  85      	                add l
2059:11162+4	F55D  6F      	                ld l, a
2060:				; HL - vector address
2061:11166+7	F55E  73      	                ld (hl), e              ; LS byte of address
2062:11173+6	F55F  23      	                inc hl
2063:11179+7	F560  72      	                ld (hl), d              ; MS byte of address
2064:11186+10	F561  E1      	                pop hl
2065:11196+10	F562  C9      	                ret
2066:				;
2067:				;
2068:				; Enable interrupts if safe. This allows nested disable / enable pairs,
2069:				; with interrupts only enabled at the lowest level.
2070:11206+13	F563  3A8BF7  	int_enable      ld a, (itdsct)
2071:				; Each itena call should be preceded by one or more calls to itdis,
2072:				; so itena with itdsct = 0 is an error.
2073:11219+4	F566  A7      	                and a
2074:11223+10+7	F567  CC4AF4  	                call z, bios_panic      ; System panic on underflow
2075:11233+4	F56A  3D      	                dec a
2076:11237+13	F56B  328BF7  	                ld (itdsct), a
2077:11250+5+6	F56E  C0      	                ret nz                  ; Exit if not at lowest level
2078:11255+13	F56F  3A8AF7  	                ld a, (itenfl)
2079:11268+4	F572  A7      	                and a
2080:11272+5+6	F573  C8      	                ret z                   ; Exit if not in interrupt mode
2081:11277+4	F574  FB      	                ei
2082:11281+10	F575  C9      	                ret
2083:				;
2084:				;
2085:				; Disable interrupt and keep count.
2086:11291+4	F576  F3      	int_disable     di
2087:11295+13	F577  3A8BF7  	                ld a, (itdsct)
2088:11308+4	F57A  3C      	                inc a
2089:11312+10+7	F57B  CC4AF4  	                call z, bios_panic      ; System panic on overflow
2090:11322+13	F57E  328BF7  	                ld (itdsct), a
2091:11335+10	F581  C9      	                ret
2092:				;
2093:				;
2094:				; Read time and date. This is similar to the monitor's routine of the same name,
2095:				; but this version reads the interrupt maintained time instead. Register mapping
2096:				; is identical except that the tick divider is returned too.
2097:				; Returns with:
2098:				; A - Tick divider (0 to TICK_FREQ -1)
2099:				; DEHL - 32-bit time
2100:11345+15	F582  FDE5    	tird            push iy
2101:11360+17	F584  CD76F5  	                call int_disable        ; Ensure interrupts are disabled
2102:11377+14	F587  FD2196F7	                ld iy, tinow
2103:11391+19	F58B  FD6E00  	                ld l, (iy + 0)          ; LS byte
2104:11410+19	F58E  FD6601  	                ld h, (iy + 1)
2105:11429+19	F591  FD5E02  	                ld e, (iy + 2)
2106:11448+19	F594  FD5603  	                ld d, (iy + 3)          ; MS byte
2107:11467+14	F597  FDE1    	                pop iy
2108:11481+13	F599  3A95F7  	                ld a, (tikdiv)          ; Tick divider
2109:11494+11	F59C  F5      	                push af
2110:11505+17	F59D  CD63F5  	                call int_enable         ; Enable interrupts if safe
2111:11522+10	F5A0  F1      	                pop af
2112:11532+10	F5A1  C9      	                ret
2113:				;
2114:				;
2115:				; Set timer. This is incremented by MS_PER_TICK on each tick interrupt to
2116:				; maintain elapsed time in ms.
2117:				; BCDE - 32-bit time in ms (0 to approximately 49.7 days).
2118:11542+15	F5A2  FDE5    	set_timer       push iy
2119:11557+17	F5A4  CD76F5  	                call int_disable        ; Ensure interrupts are disabled
2120:11574+14	F5A7  FD219AF7	                ld iy, el_time
2121:11588+19	F5AB  FD7300  	                ld (iy + 0), e          ; LS byte
2122:11607+19	F5AE  FD7201  	                ld (iy + 1), d
2123:11626+19	F5B1  FD7102  	                ld (iy + 2), c
2124:11645+19	F5B4  FD7003  	                ld (iy + 3), b          ; MS byte
2125:11664+14	F5B7  FDE1    	                pop iy
2126:11678+17	F5B9  CD63F5  	                call int_enable         ; Enable interrupts if safe
2127:11695+10	F5BC  C9      	                ret
2128:				;
2129:				;
2130:				; Get timer. This is incremented by MS_PER_TICK on each tick interrupt to
2131:				; maintain elapsed time in ms.
2132:				; BCDE - 32-bit time in ms (0 to approximately 49.7 days).
2133:11705+15	F5BD  FDE5    	get_timer       push iy
2134:11720+17	F5BF  CD76F5  	                call int_disable        ; Ensure interrupts are disabled
2135:11737+14	F5C2  FD219AF7	                ld iy, el_time
2136:11751+19	F5C6  FD5E00  	                ld e, (iy + 0)          ; LS byte
2137:11770+19	F5C9  FD5601  	                ld d, (iy + 1)
2138:11789+19	F5CC  FD4E02  	                ld c, (iy + 2)
2139:11808+19	F5CF  FD4603  	                ld b, (iy + 3)          ; MS byte
2140:11827+14	F5D2  FDE1    	                pop iy
2141:11841+17	F5D4  CD63F5  	                call int_enable         ; Enable interrupts if safe
2142:11858+10	F5D7  C9      	                ret
2143:				;
2144:				;
2145:				;
2146:				; *************
2147:				; * Constants *
2148:				; *************
2149:				;
2150:				;
2151:     -	F5D8  5A415243	signon_msg      byte "ZARC CP/M V2.2 BIOS V"
	              2043502F
	              4D205632
	              2E322042
	              494F5320
	              56
2152:     -	F5ED  312E350D	                byte BIOS_MAJ_VER + "0", ".", BIOS_MIN_VER + "0", 0x0d, 0x0a, 0
	              0A00
2153:     -	F5F3          	term_rst_msg    
2154:				;               byte ASCII_ESC, "[!p"   ; DECSTR (soft terminal reset)
2155:				; DECSTR should make the following redundant, but does not appear to be
2156:				; universally recognised. Minicom doesn't, for example.
2157:     -	F5F3  1B5B3F32	                byte ASCII_ESC, "[?25h" ; DECTCEM (enable cursor)
	              3568
2158:				;                byte ASCII_ESC, "[r"    ; DECSTBM (reset top and bottom margins)
2159:				; DECSTBM also homes the cursor on Minicom at least. This is undesirable.
2160:     -	F5F9  1B5B306D	                byte ASCII_ESC, "[0m"   ; Set normal video (SGR)
2161:				;                byte ASCII_ESC, "[1;1H", ASCII_ESC, "[2J"  ; Clear screen
2162:     -	F5FD  00      	                byte 0
2163:				; Debugging messages.
2164:     -	F5FE  3C486F6D	home_msg        byte "<Home>", 0
	              653E00
2165:     -	F605  3C53656C	seldsk_msg      byte "<SelDsk ", 0
	              44736B20
	              00
2166:     -	F60E  3C536574	settrk_msg      byte "<SetTrk ", 0
	              54726B20
	              00
2167:     -	F617  3C536574	setsec_msg      byte "<SetSec ", 0
	              53656320
	              00
2168:     -	F620  3C536574	setdma_msg      byte "<SetDMA ", 0
	              444D4120
	              00
2169:     -	F629  3C526561	readsec_msg     byte "<Read ", 0
	              642000
2170:     -	F630  3C577269	writesec_msg    byte "<Write ", 0
	              74652000
2171:     -	F638  436F6C64	cold_crc_msg    byte "Cold start, BDOS & CCP CRC: ", 0
	              20737461
	              72742C20
	              42444F53
	              20262043
	              43502043
	              52433A20
	              00
2172:     -	F655  5761726D	warm_crc_msg    byte "Warm start, CCP CRC: ", 0
	              20737461
	              72742C20
	              43435020
	              4352433A
	              2000
2173:     -	F66B  52544320	rtc_err_msg     byte "RTC error ", 0
	              6572726F
	              722000
2174:				;
2175:				; Console translation messages.
2176:				;csr_home_msg    byte ASCII_ESC, "[1;1H$"
2177:				;cls_msg         byte ASCII_ESC, "[1;1H", ASCII_ESC, "[2J$"
2178:				;
2179:				;
2180:				; Disk Parameter Headers (DPH)
2181:				; From http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch6.htm:
2182:				; Each disk drive has an associated (16-byte) disk parameter header that contains
2183:				; information about the disk drive and provides a scratch pad area for certain
2184:				; BDOS operations. The format of the disk parameter header for each drive is shown
2185:				; in Figure 6-2, where each element is a word (16-bit) value.
2186:				;
2187:				dph_gen         macro d
2188:				                word 0                  ; XLT No sector translation
2189:				                word 0, 0, 0            ; BDOS scratch area
2190:				                word bdos_dirbf         ; DIRBUF BDOS directory scratch area
2191:				                word disk_dpb           ; Pointer to DPB
2192:				                word 0                  ; CSV No check area required for fixed disk
2193:				                word bdos_all_`d        ; ALV Allocation area
2194:				                endm
2195:				;
2196:				; Build DPH list.
2197:     -	F676          	disk_dph_base
2198:     -	0000          	drive           set 0
2199:     -	F676  00000000	                rept NUM_DISKS
	              00000000
	              8CFC76F7
	              00003CF8
	              00000000
	              00000000
	              8CFC76F7
	              00007CF8
	              00000000
	              00000000
	              8CFC76F7
	              0000BCF8
	              00000000
	              00000000
	              8CFC76F7
	              0000FCF8
	              00000000
	              00000000
	              8CFC76F7
	              00003CF9
	              00000000
	              00000000
	              8CFC76F7
	              00007CF9
	              00000000
	              00000000
	              8CFC76F7
	              0000BCF9
	              00000000
	              00000000
	              8CFC76F7
	              0000FCF9
	              00000000
	              00000000
	              8CFC76F7
	              00003CFA
	              00000000
	              00000000
	              8CFC76F7
	              00007CFA
	              00000000
	              00000000
	              8CFC76F7
	              0000BCFA
	              00000000
	              00000000
	              8CFC76F7
	              0000FCFA
	              00000000
	              00000000
	              8CFC76F7
	              00003CFB
	              00000000
	              00000000
	              8CFC76F7
	              00007CFB
	              00000000
	              00000000
	              8CFC76F7
	              0000BCFB
	              00000000
	              00000000
	              8CFC76F7
	              0000FCFB
2203:				;
2204:				;
2205:				; Disk Parameter Block (DPB).
2206:				; This is used for all drives, but the OFF entry is adjusted by SELDSK to the
2207:				; appropriate value.
2208:				; See FS_Calculations.ods for derivation.
2209:     -	F776  0001    	disk_dpb        word DISK_SPT   ; SPT sectors per track
2210:     -	F778  04      	                byte 4          ; BSH data allocation block shift factor
2211:     -	F779  0F      	                byte 15         ; BLM is the data allocation block mask (2^[BSH-1])
2212:     -	F77A  00      	                byte 0          ; EXM is the extent mask
2213:     -	F77B  FF01    	                word DISK_DSM   ; DSM maximum block number
2214:     -	F77D  FF01    	                word 511        ; DRM maximum directory entry number
2215:     -	F77F  FF      	                byte 0xff       ; AL0, AL1 determine reserved directory blocks
2216:     -	F780  00      	                byte 0
2217:     -	F781  0000    	                word 0          ; CKS is the size of the directory check vector
2218:     -	F783  0000    	disk_dpb_off    word 0          ; OFF number of reserved tracks
2219:				;
2220:				; Anything after this point cannot be assumed to be loaded from MMC.
2221:     -	0001          	                assert $ <= BIOS_START + BIOS_MAX_SIZE  ; Don't exceed size allocation
2222:				;
2223:				;
2224:				;
2225:				; *************
2226:				; * Variables *
2227:				; *************
2228:				;
2229:				;
2230:				; Private monitor variables located in bank 1.
2231:				; Note: linker "-c" option is used, so no data is initialised here.
2232:				                dseg                ; Data segment
2233:				;
2234:     -	F785          	bios_options    defs 1              ; Options. See BIOS_OPT_xxx definitions.
2235:     -	F786          	mem_pages       defs MMAP_CPM_PAGES ; Pages numbers allocated
2236:     -	F78A          	itenfl          defs 1              ; Int. enable (I/O mode) (0 = ints disabled)
2237:     -	F78B          	itdsct          defs 1              ; DI nest count
2238:     -	F78C          	cpm_part_entry  defs 2              ; Pointer to partition table entry
2239:     -	F78E          	sel_drive       defs 1              ; Drive number
2240:     -	F78F          	track           defs 2              ; Selected disk track
2241:     -	F791          	sector          defs 2              ; Selected disk sector
2242:     -	F793          	dma_addr        defs 2              ; Selected "DMA" address
2243:     -	F795          	tikdiv          defs 1              ; Tick divider
2244:     -	F796          	tinow           defs 4              ; Current time and date
2245:     -	F79A          	el_time         defs 4              ; Elapsed time (ms)
2246:     -	F79E          	time_tm         defs TM_SIZE        ; Date / time structure
2247:     -	F7A8          	cpm_sp          defs 2              ; CP/M environment stack pointer
2248:     -	F7AA          	bg_sp           defs 2              ; Background stack pointer (interrupts)
2249:     -	F7AC          	load_secs       defs 1              ; Number of CCP / BDOS sectors loaded
2250:     -	F7AD          	sec_buffer      defs CPM_SECTOR_SIZE    ; Sector buffer
2251:				; Console output translation.
2252:     -	F82D          	cot_state       defs 1              ; Console output translation state
2253:     -	F82E          	cot_buffer      defs COT_BUF_MAX_LEN    ; Sequence buffer
2254:     -	F832          	cot_count       defs 1              ; Number of characters in buffer
2255:				; Console input translation.
2256:     -	F833          	cit_state       defs 1              ; Console input translation state
2257:     -	F834          	cit_buffer      defs CIT_BUF_MAX_LEN    ; Sequence buffer
2258:     -	F838          	cit_count       defs 1              ; Number of characters in buffer
2259:     -	F839          	cit_timer       defs 1              ; Console input translation timer
2260:     -	F83A          	cit_buff_ptr    defs 2              ; Pointer within cit_buffer
2261:				;
2262:				; Generate allocation buffers for each drive. The start addresses are
2263:				; bdos_all_<drive>.
2264:				all_buff_gen    macro d
2265:				bdos_all_`d     defs (DISK_DSM / 8) + 1  ; Allocation vector for this drive
2266:				                endm
2267:				;
2268:     -	0000          	drive           set 0
2269:     -	        	                rept NUM_DISKS
2273:				;
2274:     -	FC3C          	                defs INT_STACK_SIZE ; Interrupt service routine stack
2275:     -	FC4C          	int_stk_top_p1
2276:     -	FC4C          	                defs STACKS_SIZE    ; Monitor call stack
2277:     -	FC8C          	mc_stk_top_p1                       ; Stack top + 1
2278:				;
2279:				;
2280:				; Scratch ram area for BDOS use.
2281:     -	FC8C          	bdos_begdat     equ $               ; Beginning of BDOS data area
2282:				;
2283:     -	FC8C          	bdos_dirbf      defs 128            ; Scratch directory area
2284:				;
2285:     -	FD0C          	bdos_enddat	    equ $               ; End of BDOS data area
2286:				;
2287:     -	0001          	                assert $ <= INT_VEC_TABLE   ; Don't overwrite interrupt vectors
2288:				;
2289:     -	FD0C          	                end



Statistics:

     4	passes
     0	jr promotions
   735	symbols
  2949	bytes

   357	macro calls
  2245	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_DEL      =7F        127
ASCII_ENQ      =05        5
ASCII_ESC      =1B        27
ASCII_FF       =0C        12
ASCII_HT       =09        9
ASCII_LF       =0A        10
ASCII_RS       =1E        30
ASCII_SUB      =1A        26
ASCII_SYN      =16        22
ASCII_VT       =0B        11
AUXIST          F3A2      62370
AUXOST          F3BC      62396
BDOS           =05        5
BDOS_CLOSE_FILE=10        16
BDOS_CON_IN    =01        1
BDOS_CON_OUT   =02        2
BDOS_DELETE_FILE=13        19
BDOS_DIRECT_CON_IO=06        6
BDOS_GET_ALLOC_ADDR=1B        27
BDOS_GET_CON_STAT=0B        11
BDOS_GET_CURR_DISK=19        25
BDOS_GET_DPB   =1F        31
BDOS_GET_FILE_SIZE=23        35
BDOS_GET_IO_BYTE=07        7
BDOS_GET_LOGIN_VEC=18        24
BDOS_GET_RO_VEC=1D        29
BDOS_GET_SET_USER=20        32
BDOS_LST_OUT   =05        5
BDOS_MAKE_FILE =16        22
BDOS_OPEN_FILE =0F        15
BDOS_PRINT_STRING=09        9
BDOS_PUN_OUT   =04        4
BDOS_RDR_IN    =03        3
BDOS_READ_CON_BUFF=0A        10
BDOS_READ_RANDOM=21        33
BDOS_READ_SEQ  =14        20
BDOS_READ_SEQ_EOF=01        1
BDOS_RENAME_FILE=17        23
BDOS_RESET_DISK_SYS=0D        13
BDOS_RESET_DRIVES=25        37
BDOS_SEARCH_FIRST=11        17
BDOS_SEARCH_NEXT=12        18
BDOS_SEL_DISK  =0E        14
BDOS_SET_DMA_ADDR=1A        26
BDOS_SET_FILE_ATTR=1E        30
BDOS_SET_IO_BYTE=08        8
BDOS_SET_RANDOM_REC=24        36
BDOS_START     =DE06      56838
BDOS_SYS_RST   =00        0
BDOS_VERSION   =0C        12
BDOS_WRITE_PROT=1C        28
BDOS_WRITE_RANDOM=22        34
BDOS_WRITE_RAN_ZFILL=28        40
BDOS_WRITE_SEQ =15        21
BIOS_AUXIST    =33        51
BIOS_AUXOST    =36        54
BIOS_CONIN     =06        6
BIOS_CONOST    =30        48
BIOS_CONOUT    =09        9
BIOS_CONST     =03        3
BIOS_CPM_START_SEC=2C        44
BIOS_DEVINI    =3C        60
BIOS_DEVTBL    =39        57
BIOS_DRVTBL    =3F        63
BIOS_FLUSH     =45        69
BIOS_GET_TIMER =7B        123
BIOS_HOME      =15        21
BIOS_ID        =60        96
BIOS_INT_DISABLE=6F        111
BIOS_INT_ENABLE=72        114
BIOS_JPTBL_NEXT=7E        126
BIOS_LISTST    =2A        42
BIOS_MAJ_VER   =01        1
BIOS_MAX_SIZE  =1000      4096
BIOS_MIN_VER   =05        5
BIOS_MON_CALL  =69        105
BIOS_MOVE      =48        72
BIOS_MULTIO    =42        66
BIOS_OPT_DEBUG_BIT=00        0
BIOS_OPT_DEBUG_MASK=01        1
BIOS_OPT_NOINTS_BIT=01        1
BIOS_OPT_NOINTS_MASK=02        2
BIOS_OPT_RAWCON_BIT=02        2
BIOS_OPT_RAWCON_MASK=04        4
BIOS_PLIST     =0C        12
BIOS_PUNCH     =0F        15
BIOS_READ      =24        36
BIOS_READER    =12        18
BIOS_RESERV1   =5A        90
BIOS_RESERV2   =5D        93
BIOS_SECTRAN   =2D        45
BIOS_SELDSK    =18        24
BIOS_SELMEM    =4E        78
BIOS_SETBNK    =51        81
BIOS_SETDMA    =21        33
BIOS_SETSEC    =1E        30
BIOS_SETTRK    =1B        27
BIOS_SET_TIMER =78        120
BIOS_START     =EC00      60416
BIOS_STARTUP   =66        102
BIOS_SUPER     =6C        108
BIOS_TIME      =4B        75
BIOS_TIRD      =75        117
BIOS_USERF     =57        87
BIOS_VER       =63        99
BIOS_WBOOT     =00        0
BIOS_WRITE     =27        39
BIOS_XMOVE     =54        84
BOOT            ED56      60758
CCP_BDOS_SECTS =2C        44
CCP_SECTS      =10        16
CCP_START      =D600      54784
CDISK          =04        4
CITST_NORM     =00        0
CITST_REPLAY   =01        1
CITST_STATES   =02        2
CIT_BUF_MAX_LEN=04        4
CONIN           EE0F      60943
CONOST          F371      62321
CONOUT          EF06      61190
CONST           EDD5      60885
COTST_ESC      =01        1
COTST_LOAD     =02        2
COTST_NORM     =00        0
COTST_STATES   =04        4
COTST_Y        =03        3
COT_BUF_MAX_LEN=04        4
CPM_BIAS       =A200      41472
CPM_DISK_SIZE  =00100000  1048576
CPM_DRIVE_TRACKS=20        32
CPM_MIN_PRT_SIZE=01100000  17825792
CPM_MIN_PRT_SIZE_MS=8800      34816
CPM_SECTOR_SIZE=80        128
CPM_SYS_SIZE   =00100000  1048576
CPM_SYS_TRACKS =20        32
CPM_TRACK_SIZE =8000      32768
DEF_BUFFER     =80        128
DEF_BUFFER_SIZE=80        128
DEVINI          F3D9      62425
DEVTBL          F3D6      62422
DIRE_ALLOC     =10        16
DIRE_EX        =0C        12
DIRE_NAME      =01        1
DIRE_RC        =0F        15
DIRE_S1        =0D        13
DIRE_S2        =0E        14
DIRE_SIZE      =20        32
DIRE_TYP       =09        9
DIRE_USER      =00        0
DISK_DSM       = 1FF      511
DISK_SPT       = 100      256
DPART_END_CYL  =07        7
DPART_END_HD   =05        5
DPART_END_SEC  =06        6
DPART_SIZE     =10        16
DPART_SIZE_SECS=0C        12
DPART_START_CYL=03        3
DPART_START_HD =01        1
DPART_START_LBA=08        8
DPART_START_SEC=02        2
DPART_STATUS   =00        0
DPART_TYPE     =04        4
DPB_AL0        =09        9
DPB_AL1        =0A        10
DPB_BLM        =03        3
DPB_BSH        =02        2
DPB_CKS        =0B        11
DPB_DRM        =07        7
DPB_DSM        =05        5
DPB_EXM        =04        4
DPB_OFF        =0D        13
DPB_SIZE       =0F        15
DPB_SPT        =00        0
DPH_ALV        =0E        14
DPH_CSV        =0C        12
DPH_DIRBF      =08        8
DPH_DPB        =0A        10
DPH_SCRATCH0   =02        2
DPH_SCRATCH1   =04        4
DPH_SCRATCH2   =06        6
DPH_SIZE       =10        16
DPH_XLT        =00        0
DRVTBL          F3DC      62428
DSK_BOOT_SIGN  =AA55      43605
DSK_BOOT_SIGN_OFFSET= 1FE      510
DSK_MAX_PARTS  =04        4
DSK_PART1_OFFSET= 1BE      446
DSK_PART_TYP_EXPER=7F        127
FCB1           =5C        92
FCB2           =6C        108
FCB_ALLOC      =10        16
FCB_CR         =20        32
FCB_DRIVE      =00        0
FCB_EX         =0C        12
FCB_NAME       =01        1
FCB_RC         =0F        15
FCB_RECORD     =21        33
FCB_S1         =0D        13
FCB_S2         =0E        14
FCB_SIZE       =24        36
FCB_TYP        =09        9
FILEEXT_SIZE   =03        3
FILENAME_SIZE  =08        8
FILE_EOF       =1A        26
FLUSH           F3E2      62434
HEAP_TOP       =7FFF      32767
HOME            F16C      61804
I2C_CSR_ACKN_BIT=00        0
I2C_CSR_ACKN_MASK=01        1
I2C_CSR_BUSY_BIT=07        7
I2C_CSR_BUSY_MASK=80        128
I2C_CSR_START_BIT=01        1
I2C_CSR_START_MASK=02        2
I2C_CSR_STOP_BIT=02        2
I2C_CSR_STOP_MASK=04        4
INTS_NUM       =08        8
INT_SER1_RX_BIT=01        1
INT_SER1_RX_MASK=02        2
INT_SER1_RX_VEC=01        1
INT_SER1_TX_BIT=00        0
INT_SER1_TX_MASK=01        1
INT_SER1_TX_VEC=00        0
INT_SER2_RX_BIT=03        3
INT_SER2_RX_MASK=08        8
INT_SER2_RX_VEC=03        3
INT_SER2_TX_BIT=02        2
INT_SER2_TX_MASK=04        4
INT_SER2_TX_VEC=02        2
INT_STACK_SIZE =10        16
INT_TICK_BIT   =04        4
INT_TICK_MASK  =10        16
INT_TICK_VEC   =04        4
INT_VEC_TABLE  =FFE0      65504
IOA_CONTROL    =02        2
IOA_CRC_0      =24        36
IOA_CRC_1      =25        37
IOA_CRC_DATA   =26        38
IOA_FPGA_MAJREV=00        0
IOA_FPGA_MINREV=01        1
IOA_FP_SW      =03        3
IOA_I2C_CSR    =18        24
IOA_I2C_DATA   =19        25
IOA_INT_EN     =08        8
IOA_INT_PEND   =0A        10
IOA_MMAP_0     =04        4
IOA_MMAP_1     =05        5
IOA_MMAP_2     =06        6
IOA_MMAP_3     =07        7
IOA_NMI_REASONS=0C        12
IOA_SER1_CSR   =10        16
IOA_SER1_DATA  =11        17
IOA_SER2_CSR   =12        18
IOA_SER2_DATA  =13        19
IOA_SPI_CSR    =20        32
IOA_SPI_DATA   =21        33
IOBYTE         =03        3
IOB_CON_MASK   =03        3
IOB_LST_MASK   =C0        192
IOB_PUN_MASK   =30        48
IOB_RDR_MASK   =0C        12
LISTST          F36B      62315
MAX_USER       =0F        15
MCALL_CACRS    =E4        228
MCALL_CACWS    =E7        231
MCALL_CAFLUS   =EA        234
MCALL_CONRCH   =72        114
MCALL_CONSTA   =75        117
MCALL_CONWCH   =6F        111
MCALL_CONWMN   =90        144
MCALL_CONWMS   =8D        141
MCALL_CRC16X   =CF        207
MCALL_CWNWLN   =8A        138
MCALL_CWPDBY   =AE        174
MCALL_CWPDLO   =B4        180
MCALL_CWPDWD   =B1        177
MCALL_CWPHBY   =A8        168
MCALL_CWPHNB   =A5        165
MCALL_CWPHWD   =AB        171
MCALL_CWPSPC   =9F        159
MCALL_CWPTM    =DE        222
MCALL_CWVICH   =9C        156
MCALL_JPTBL_NEXT=F6        246
MCALL_MADBBU   =C6        198
MCALL_MADLBU   =C0        192
MCALL_MADWBU   =C3        195
MCALL_MAMLBU   =CC        204
MCALL_MAMWWU   =C9        201
MCALL_MCPRER   =E1        225
MCALL_MON_ENTRY=69        105
MCALL_MPALL    =ED        237
MCALL_MPFREE   =F0        240
MCALL_MPSTAT   =F3        243
MCALL_MTWDLI   =A2        162
MCALL_PANIC    =6C        108
MCALL_RDDULO   =BD        189
MCALL_RDDUWD   =BA        186
MCALL_RDHXWD   =B7        183
MCALL_S1RCH    =7B        123
MCALL_S1STA    =7E        126
MCALL_S1WCH    =78        120
MCALL_S2RCH    =84        132
MCALL_S2STA    =87        135
MCALL_S2WCH    =81        129
MCALL_SKPSPC   =93        147
MCALL_TIITOS   =D8        216
MCALL_TIRD     =D2        210
MCALL_TISTOI   =DB        219
MCALL_TIWR     =D5        213
MCALL_TOLOCA   =99        153
MCALL_TOUPCA   =96        150
MC_STATES      =02        2
MMAP_BANK0_END =3FFF      16383
MMAP_BANK0_START=00        0
MMAP_BANK1_END =7FFF      32767
MMAP_BANK1_START=4000      16384
MMAP_BANK2_END =BFFF      49151
MMAP_BANK2_START=8000      32768
MMAP_BANK3_END =FFFF      65535
MMAP_BANK3_START=C000      49152
MMAP_BANKS     =04        4
MMAP_CPM_PAGES =04        4
MMAP_MON_B0_PAGE=3F        63
MMAP_MON_B1_PAGE=3E        62
MMAP_PAGES     =40        64
MMAP_PAGE_MASK =3F        63
MMAP_PAGE_SIZE =4000      16384
MMAP_PROT_BIT  =07        7
MMAP_PROT_MASK =80        128
MMAP_SUPER_BIT =06        6
MMAP_SUPER_MASK=40        64
MMC_ACMD_MC_SEND_OP_COND=29        41
MMC_ARG1       =01        1
MMC_ARG2       =02        2
MMC_ARG3       =03        3
MMC_ARG4       =04        4
MMC_CID_CRC    =0F        15
MMC_CID_MDT    =0E        14
MMC_CID_MID    =00        0
MMC_CID_OID    =01        1
MMC_CID_PNM    =03        3
MMC_CID_PNM_SIZE=06        6
MMC_CID_PRV    =09        9
MMC_CID_PSN    =0A        10
MMC_CID_SIZE   =10        16
MMC_CMD        =00        0
MMC_CMD_APP_CMD=37        55
MMC_CMD_CRC_ON_OFF=3B        59
MMC_CMD_GO_IDLE_STATE=00        0
MMC_CMD_READ_SINGLE_BLOCK=11        17
MMC_CMD_SEND_CID=0A        10
MMC_CMD_SEND_CSD=09        9
MMC_CMD_SEND_OP_COND=01        1
MMC_CMD_SEND_STATUS=0D        13
MMC_CMD_SET_BLOCKLEN=10        16
MMC_CMD_START  =40        64
MMC_CMD_STOP   =01        1
MMC_CMD_WRITE_BLOCK=18        24
MMC_CRC        =05        5
MMC_CSD_15_8   =0E        14
MMC_CSD_23_16  =0D        13
MMC_CSD_31_24  =0C        12
MMC_CSD_39_32  =0B        11
MMC_CSD_47_40  =0A        10
MMC_CSD_55_48  =09        9
MMC_CSD_63_56  =08        8
MMC_CSD_71_64  =07        7
MMC_CSD_79_72  =06        6
MMC_CSD_87_80  =05        5
MMC_CSD_95_88  =04        4
MMC_CSD_CRC    =0F        15
MMC_CSD_NSAC   =02        2
MMC_CSD_SIZE   =10        16
MMC_CSD_TAAC   =01        1
MMC_CSD_TR_SPD =03        3
MMC_CSD_VERSION=00        0
MMC_LOG2_SEC_SIZE=09        9
MMC_R1_ADDR_ERR_BIT=05        5
MMC_R1_ADDR_ERR_MASK=20        32
MMC_R1_CMD_CRC_ERR_BIT=03        3
MMC_R1_CMD_CRC_ERR_MASK=08        8
MMC_R1_ERA_RST_BIT=01        1
MMC_R1_ERA_RST_MASK=02        2
MMC_R1_ERA_SEQ_ERR_BIT=04        4
MMC_R1_ERA_SEQ_ERR_MASK=10        16
MMC_R1_IDLE_BIT=00        0
MMC_R1_IDLE_MASK=01        1
MMC_R1_ILL_CMD_BIT=02        2
MMC_R1_ILL_CMD_MASK=04        4
MMC_R1_PAR_ERR_BIT=06        6
MMC_R1_PAR_ERR_MASK=40        64
MMC_R1_START_BIT=07        7
MMC_R1_START_MASK=80        128
MMC_SECTOR_SIZE= 200      512
MMC_SIZE       =06        6
MMC_STAT_IDLE  =00        0
MMC_STAT_INIT  =01        1
MOVE            F3E5      62437
MPA_NAME_LEN   =04        4
MST_AF         =1C        28
MST_AF_P       =14        20
MST_BC         =1A        26
MST_BC_P       =12        18
MST_DE         =18        24
MST_DE_P       =10        16
MST_HL         =16        22
MST_HL_P       =0E        14
MST_I          =1E        30
MST_IEN        =00        0
MST_IX         =0C        12
MST_IY         =0A        10
MST_MMAP0      =02        2
MST_MMAP1      =03        3
MST_MMAP2      =04        4
MST_MMAP3      =05        5
MST_MMAP_EN    =01        1
MST_PC         =08        8
MST_R          =1F        31
MST_SIZE       =20        32
MST_SP         =06        6
MS_PER_TICK    =64        100
MTWDLI_ABBREV_BIT=00        0
MTWDLI_ABBREV_MASK=01        1
MTWDLI_ICASE_BIT=01        1
MTWDLI_ICASE_MASK=02        2
MTWDLI_TERM_BIT=07        7
MTWDLI_TERM_MASK=80        128
MULTIO          F3DF      62431
NMI_PROT_VIOL_BIT=01        1
NMI_PROT_VIOL_MASK=02        2
NMI_REASONS_ALL=0F        15
NMI_REASONS_NUM=04        4
NMI_SUPER_VIOL_BIT=02        2
NMI_SUPER_VIOL_MASK=04        4
NMI_SWITCH_BIT =00        0
NMI_SWITCH_MASK=01        1
NMI_TRACE_BIT  =03        3
NMI_TRACE_MASK =08        8
NUM_DISKS      =10        16
NUM_DISKS_MAX  =10        16
PLIST           F03E      61502
PORT_SER1      =00        0
PORT_SER2      =01        1
PORT_STATES    =02        2
PUNCH           F058      61528
READ            F28C      62092
READER          F072      61554
RESERV1         F3F7      62455
RESERV2         F3FA      62458
SECTRAN         F36D      62317
SELDSK          F18F      61839
SELMEM          F3EB      62443
SER_CSR_FRAME_ERR_BIT=03        3
SER_CSR_FRAME_ERR_MASK=08        8
SER_CSR_RX_ALHALF_BIT=01        1
SER_CSR_RX_ALHALF_MASK=02        2
SER_CSR_RX_EMPTY_BIT=00        0
SER_CSR_RX_EMPTY_MASK=01        1
SER_CSR_RX_FULL_BIT=02        2
SER_CSR_RX_FULL_MASK=04        4
SER_CSR_TX_ALHALF_BIT=05        5
SER_CSR_TX_ALHALF_MASK=20        32
SER_CSR_TX_EMPTY_BIT=04        4
SER_CSR_TX_EMPTY_MASK=10        16
SER_CSR_TX_FULL_BIT=06        6
SER_CSR_TX_FULL_MASK=40        64
SETBNK          F3EE      62446
SETDMA          F25E      62046
SETSEC          F230      62000
SETTRK          F202      61954
SPI_CSR_BUSY_BIT=07        7
SPI_CSR_BUSY_MASK=80        128
SPI_CSR_FAST_BIT=00        0
SPI_CSR_FAST_MASK=01        1
SPI_CSR_MC_SS_BIT=01        1
SPI_CSR_MC_SS_MASK=02        2
STACKS_SIZE    =40        64
SYSCTRL_MAPARM_BIT=03        3
SYSCTRL_MAPARM_MASK=08        8
SYSCTRL_MMAPN_BIT=04        4
SYSCTRL_MMAPN_MASK=10        16
SYSCTRL_MMAP_BIT=01        1
SYSCTRL_MMAP_MASK=02        2
SYSCTRL_NMCLR_BIT=02        2
SYSCTRL_NMCLR_MASK=04        4
SYSCTRL_RESERVED_BIT=07        7
SYSCTRL_RESERVED_MASK=80        128
SYSCTRL_TRARM_BIT=00        0
SYSCTRL_TRARM_MASK=01        1
SYSCTRL_TRPRE0_BIT=05        5
SYSCTRL_TRPRE0_MASK=20        32
SYSCTRL_TRPRE1_BIT=06        6
SYSCTRL_TRPRE1_MASK=40        64
TICK_FREQ      =0A        10
TIME            F3E8      62440
TIM_EPOCH_YEAR =46        70
TMDST_DST      =02        2
TMDST_GMT      =01        1
TMDST_NUM      =03        3
TMDST_UNKNOWN  =00        0
TM_DST         =09        9
TM_HOURS       =02        2
TM_MDAY        =03        3
TM_MINS        =01        1
TM_MON         =04        4
TM_SECS        =00        0
TM_SIZE        =0A        10
TM_WDAY        =06        6
TM_YDAY        =07        7
TM_YEAR        =05        5
TPA_START      = 100      256
TRM_NONE       =00        0
TRM_SINGLE     =01        1
TRM_STATES     =04        4
TRM_TO_ADDR    =02        2
TRM_XPT        =03        3
USERF           F3F4      62452
WBOOT           EDCA      60874
WRITE           F305      62213
XMOVE           F3F1      62449
Z80_NMI_VEC    =66        102
Z80_RST00_VEC  =00        0
Z80_RST08_VEC  =08        8
Z80_RST10_VEC  =10        16
Z80_RST18_VEC  =18        24
Z80_RST20_VEC  =20        32
Z80_RST28_VEC  =28        40
Z80_RST30_VEC  =30        48
Z80_RST38_VEC  =38        56
ZKEY_CSR_DOWN  =1E        30
ZKEY_CSR_LEFT  =01        1
ZKEY_CSR_RIGHT =06        6
ZKEY_CSR_UP    =1F        31
ZKEY_DELETE    =7F        127
ZKEY_END       =04        4
ZKEY_HOME      =02        2
ZKEY_INSERT    =16        22
ZKEY_PAGE_DOWN =1C        28
ZKEY_PAGE_UP   =1D        29
bdos_all_0      F83C      63548
bdos_all_1      F87C      63612
bdos_all_10     FABC      64188
bdos_all_11     FAFC      64252
bdos_all_12     FB3C      64316
bdos_all_13     FB7C      64380
bdos_all_14     FBBC      64444
bdos_all_15     FBFC      64508
bdos_all_2      F8BC      63676
bdos_all_3      F8FC      63740
bdos_all_4      F93C      63804
bdos_all_5      F97C      63868
bdos_all_6      F9BC      63932
bdos_all_7      F9FC      63996
bdos_all_8      FA3C      64060
bdos_all_9      FA7C      64124
bdos_begdat    =FC8C      64652
bdos_dirbf      FC8C      64652
bdos_enddat    =FD0C      64780
bg_sp           F7AA      63402
bios_options    F785      63365
bios_panic      F44A      62538
bol_crc_loop    EDAE      60846
bol_do_crc      EDA8      60840
bol_no_debug    EDBE      60862
boot_ldlp_nc    ED89      60809
boot_load       ED63      60771
boot_load_loop  ED78      60792
cit_buff_ptr    F83A      63546
cit_buffer      F834      63540
cit_count       F838      63544
cit_csi         EE42      60994
cit_do_replay   EE97      61079
cit_getch       EEBC      61116
cit_norm        EE25      60965
cit_replay      EEA4      61092
cit_ret_char    EEBA      61114
cit_state       F833      63539
cit_store       EED3      61139
cit_timer       F839      63545
cold_crc_msg    F638      63032
com_exit        F40B      62475
com_loop        F3FE      62462
con_out_msg     F3FD      62461
const_raw       EDDE      60894
cot_buffer      F82E      63534
cot_cmd         EF83      61315
cot_count       F832      63538
cot_csi         EFA1      61345
cot_dec         EFE8      61416
cot_dec_carry   F001      61441
cot_dec_digit   EFF4      61428
cot_dec_div     EFF9      61433
cot_dec_loop    EFFB      61435
cot_esc         EF39      61241
cot_load        EFB0      61360
cot_norm        EF25      61221
cot_not_arw     EF46      61254
cot_pass        EF6F      61295
cot_pass_lp     EF76      61302
cot_set_csr     EFAA      61354
cot_sgr         EF90      61328
cot_state       F82D      63533
cot_store       F00B      61451
cot_to_norm     EF8B      61323
cot_y           EFBF      61375
cpm_part_entry  F78C      63372
cpm_sp          F7A8      63400
crt_in          F0EB      61675
crt_in_st       F0E9      61673
crt_out         F0F0      61680
crt_out_st      F0EE      61678
disk_dpb        F776      63350
disk_dpb_off    F783      63363
disk_dph_base   F676      63094
dma_addr        F793      63379
drive          =10        16
el_time         F79A      63386
enum_counter   =02        2
find_lba        F40D      62477
get_timer       F5BD      62909
go_cpm          F41A      62490
hm_no_debug     F18A      61834
home_msg        F5FE      62974
int_disable     F576      62838
int_enable      F563      62819
int_set_vec     F557      62807
int_stk_top_p1  FC4C      64588
itdsct          F78B      63371
itenfl          F78A      63370
jptbl_addr     =7E        126
list_st         F388      62344
load_secs       F7AC      63404
lpt_out         F168      61800
lpt_out_st      F166      61798
mc_call_instr   F4AA      62634
mc_stk_top_p1   FC8C      64652
mem_pages       F786      63366
mmap_cpm        F485      62597
mmap_monitor    F47C      62588
mmc_error       F43E      62526
mon_call        F496      62614
ptp_out         F13C      61756
ptp_out_st      F131      61745
ptpost_char     F139      61753
ptr_in          F104      61700
ptr_in_st       F0F9      61689
ptrist_char     F101      61697
raw_conin       EEEF      61167
raw_conout      F027      61479
rd_crc_loop     F2D8      62168
rd_no_debug     F2F1      62193
rd_ok           F2A6      62118
rdr_st          EDF5      60917
readsec_msg     F629      63017
rtc_err_msg     F66B      63083
rw_error        F2F3      62195
s1rch_in        F0B7      61623
s1rch_in_ei     F0B6      61622
s1rch_loop      F0A5      61605
s1wch_loop      F0D3      61651
s1wch_out       F0E5      61669
s1wch_out_ei    F0E4      61668
s2rch_in        F124      61732
s2rch_in_ei     F123      61731
s2rch_loop      F112      61714
s2wch_loop      F14A      61770
s2wch_out       F15C      61788
s2wch_out_ei    F15B      61787
sd_exit         F1DF      61919
sd_off_end      F1DB      61915
sd_off_loop     F1D8      61912
sec_buffer      F7AD      63405
sector          F791      63377
sed_no_debug    F286      62086
sel_drive       F78E      63374
sel_no_debug    F1B6      61878
sel_no_debug1   F201      61953
seldsk_msg      F605      62981
ser1r_serv      F515      62741
ser1w_serv      F4FF      62719
ser2r_serv      F541      62785
ser2w_serv      F52B      62763
ses_no_debug    F258      62040
set_no_debug    F22A      61994
set_super       F459      62553
set_timer       F5A2      62882
setdma_msg      F620      63008
sets_loop       F46A      62570
sets_mask_dn    F463      62563
setsec_msg      F617      62999
settrk_msg      F60E      62990
signon_msg      F5D8      62936
startup         EC81      60545
str_offset     =10        16
strt_clr_tim_lp ECB8      60600
strt_ints       ECD2      60626
strt_ints_done  ED3B      60731
strt_rtc_done   ED2B      60715
strt_rtc_ok     ED16      60694
term_rst_msg    F5F3      62963
tick_serv       F4B7      62647
tikdiv          F795      63381
time_tm         F79E      63390
tinow           F796      63382
tird            F582      62850
track           F78F      63375
ts_cit_done     F4CA      62666
ts_eti_done     F4DD      62685
ts_exit         F4F6      62710
tty_in          F097      61591
tty_in_st       F08C      61580
tty_out         F0C5      61637
tty_out_st      F0BA      61626
ttyist_char     F094      61588
ttyost_char     F0C2      61634
uc1_in          F0F3      61683
uc1_in_st       F0F1      61681
uc1_out         F0F8      61688
uc1_out_st      F0F6      61686
ul1_out         F16B      61803
ul1_out_st      F169      61801
up1_out         F162      61794
up1_out_st      F160      61792
up2_out         F165      61797
up2_out_st      F163      61795
ur1_in          F129      61737
ur1_in_st       F127      61735
ur2_in          F12E      61742
ur2_in_st       F12C      61740
warm_crc_msg    F655      63061
wboot_entry     EC03      60419
wr_crc_loop     F350      62288
wr_no_debug     F369      62313
writesec_msg    F630      63024
